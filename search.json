[
  {
    "objectID": "tutorials/miscellaneous-using-notebook-widgets.html",
    "href": "tutorials/miscellaneous-using-notebook-widgets.html",
    "title": "Using ipyWidgets",
    "section": "",
    "text": "In this notebook, we will use ipyWidgets to make dynamic selections of the data being visualized.\n\nimport matplotlib.pyplot as plt\nfrom plotnine import ggplot, aes\nimport plotnine as p9\nimport numpy as np\nimport itertools\nfrom ipywidgets import widgets\nfrom IPython.display import display\n\nfrom plotnine.data import mtcars\n\nFirst of all, install ipywidgets:\npip install ipywidgets\n\n# for jupyter notebooks:\njupyter nbextension enable --py widgetsnbextension\n\n# for jupyter lab (requires npm):\nnpm i @jupyter-widgets/jupyterlab-manager\nLet’s have alook on the plot with all the data. We are comparing cars with their horse-power in the X axis and miles-per-gallon in the Y axis. The points are collored by car weight.\n\n# This has to be used the first time you make a plot. This magic allows the notebook to update plots.\n%matplotlib notebook\n\np = (\n    ggplot(mtcars, aes(x=\"hp\", y=\"mpg\", color=\"wt\"))\n    + p9.geom_point()\n    + p9.theme_linedraw()\n)\np\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow we will get relevant values for the creation of plots with sub-sets of data.\nInitially, select cars based on number of cylinders\n\n# Prepre the list we will use to selec sub-sets of data based on number of cylinders.\ncylList = np.unique(mtcars[\"cyl\"])\n\n\n# The first selection is a drop-down menu for number of cylinders\ncylSelect = widgets.Dropdown(\n    options=list(cylList),\n    value=cylList[1],\n    description=\"Cylinders:\",\n    disabled=False,\n)\n\n# For the widgets to update the same plot, instead of creating one new image every time\n# a selection changes. We keep track of the matplotlib image and axis, so we create only one\n# figure and set of axis, for the first plot, and then just re-use the figure and axis\n# with plotnine's \"_draw_using_figure\" function.\nfig = None\naxs = None\n\n\ndef get_current_artists():\n    # Return artists attached to all the matplotlib axes\n    axes = plt.gca()\n    return itertools.chain(\n        axes.lines, axes.collections, axes.artists, axes.patches, axes.texts\n    )\n\n\n# This is the main function that is called to update the plot every time we chage a selection.\ndef plotUpdate(*args):\n    # Use global variables for matplotlib's figure and axis.\n    global fig, axs\n\n    # Get current values of the selection widget\n    cylValue = cylSelect.value\n\n    # Create a temporary dataset that is constrained by the user's selections.\n    tmpDat = mtcars.loc[(mtcars[\"cyl\"] == cylValue), :]\n\n    # Create plotnine's plot\n\n    # Using the maximum and minimum values we gatehred before, we can keep the plot axis from\n    # changing with the cyinder selection\n    p = (\n        ggplot(tmpDat, aes(x=\"hp\", y=\"mpg\", color=\"wt\"))\n        + p9.geom_point()\n        + p9.theme_linedraw()\n    )\n    if fig is None:\n        # If this is the first time a plot is made in the notebook, we let plotnine create a new\n        # matplotlib figure and axis.\n        fig = p.draw()\n        axs = fig.axes\n    else:\n        # p = copy(p)\n        # This helps keeping old selected data from being visualized after a new selection is made.\n        # We delete all previously reated artists from the matplotlib axis.\n        for artist in get_current_artists():\n            artist.remove()\n\n        # If a plot is being updated, we re-use the figure an axis created before.\n        p._draw_using_figure(fig, axs)\n\n\ncylSelect.observe(plotUpdate, \"value\")\n\n# Display the widgets\ndisplay(cylSelect)\n\n# Plots the first image, with inintial values.\nplotUpdate()\n\n# Matplotlib function to make the image fit within the plot dimensions.\nplt.tight_layout()\n\n# Trick to get the first rendered image to follow the previous \"tight_layout\" command.\n# without this, only after the first update would the figure be fit inside its dimensions.\ncylSelect.value = cylList[0]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHaving axis ranges change between selections does not help probing the data.\n\n# We now get the maximum ranges of relevant variables to keep axis constant between images.\n\n# Get range of weight\nminWt = min(mtcars[\"wt\"])\nmaxWt = max(mtcars[\"wt\"])\n# We get all unique values of weigh, sort them, and transform the numpy.array into a python list.\nwtOptions = list(np.sort(np.unique(mtcars.loc[mtcars[\"cyl\"] == cylList[0], \"wt\"])))\n\nminHP = min(mtcars[\"hp\"])\nmaxHP = max(mtcars[\"hp\"])\n\nminMPG = min(mtcars[\"mpg\"])\nmaxMPG = max(mtcars[\"mpg\"])\n\n\n# The first selection is a drop-down menu for number of cylinders\ncylSelect = widgets.Dropdown(\n    options=list(cylList),\n    value=cylList[1],\n    description=\"Cylinders:\",\n    disabled=False,\n)\n\n# For the widgets to update the same plot, instead of creating one new image every time\n# a selection changes. We keep track of the matplotlib image and axis, so we create only one\n# figure and set of axis, for the first plot, and then just re-use the figure and axis\n# with plotnine's \"_draw_using_figure\" function.\nfig = None\naxs = None\n\n\n# This is the main function that is called to update the plot every time we chage a selection.\ndef plotUpdate(*args):\n    # Use global variables for matplotlib's figure and axis.\n    global fig, axs\n\n    # Get current values of the selection widget\n    cylValue = cylSelect.value\n\n    # Create a temporary dataset that is constrained by the user's selections.\n    tmpDat = mtcars.loc[(mtcars[\"cyl\"] == cylValue), :]\n\n    # Create plotnine's plot\n\n    # Using the maximum and minimum values we gatehred before, we can keep the plot axis from\n    # changing with the cyinder selection\n    p = (\n        ggplot(tmpDat, aes(x=\"hp\", y=\"mpg\", color=\"wt\"))\n        + p9.geom_point()\n        + p9.theme_linedraw()\n        + p9.lims(x=[minHP, maxHP], y=[minMPG, maxMPG])\n        + p9.scale_color_continuous(limits=(minWt, maxWt))\n    )\n\n    if fig is None:\n        fig = p.draw()\n        axs = fig.axes\n    else:\n        # p = copy(p)\n        for artist in get_current_artists():\n            artist.remove()\n        p._draw_using_figure(fig, axs)\n\n\ncylSelect.observe(plotUpdate, \"value\")\n\n# Display the widgets\ndisplay(cylSelect)\n\n# Plots the first image, with inintial values.\nplotUpdate()\n\n# Matplotlib function to make the image fit within the plot dimensions.\nplt.tight_layout()\n\n# Trick to get the first rendered image to follow the previous \"tight_layout\" command.\n# without this, only after the first update would the figure be fit inside its dimensions.\ncylSelect.value = cylList[0]\n\n\n\n\n\n\n\n\n\n\nNow we can make our selection more complicated by restricting the car data being visualized. Using a range slider we can restric data based on car weight.\n\n# The first selection is a drop-down menu for number of cylinders\ncylSelect = widgets.Dropdown(\n    options=list(cylList),\n    value=cylList[1],\n    description=\"Cylinders:\",\n    disabled=False,\n)\n\n# The second selection is a range of weights\nwtSelect = widgets.SelectionRangeSlider(\n    options=wtOptions,\n    index=(0, len(wtOptions) - 1),\n    description=\"Weight\",\n    disabled=False,\n)\n\nwidgetsCtl = widgets.HBox([cylSelect, wtSelect])\n\n\n# The range of weights needs to always be dependent on the cylinder selection.\ndef updateRange(*args):\n    \"\"\"Updates the selection range from the slider depending on the cylinder selection.\"\"\"\n    cylValue = cylSelect.value\n\n    wtOptions = list(np.sort(np.unique(mtcars.loc[mtcars[\"cyl\"] == cylValue, \"wt\"])))\n\n    wtSelect.options = wtOptions\n    wtSelect.index = (0, len(wtOptions) - 1)\n\n\ncylSelect.observe(updateRange, \"value\")\n\n# For the widgets to update the same plot, instead of creating one new image every time\n# a selection changes. We keep track of the matplotlib image and axis, so we create only one\n# figure and set of axis, for the first plot, and then just re-use the figure and axis\n# with plotnine's \"_draw_using_figure\" function.\nfig = None\naxs = None\n\n\n# This is the main function that is called to update the plot every time we chage a selection.\ndef plotUpdate(*args):\n    # Use global variables for matplotlib's figure and axis.\n    global fig, axs\n\n    # Get current values of the selection widgets\n    cylValue = cylSelect.value\n    wrRange = wtSelect.value\n\n    # Create a temporary dataset that is constrained by the user's selections.\n    tmpDat = mtcars.loc[\n        (mtcars[\"cyl\"] == cylValue)\n        & (mtcars[\"wt\"] &gt;= wrRange[0])\n        & (mtcars[\"wt\"] &lt;= wrRange[1]),\n        :,\n    ]\n\n    # Create plotnine's plot\n\n    p = (\n        ggplot(tmpDat, aes(x=\"hp\", y=\"mpg\", color=\"wt\"))\n        + p9.geom_point()\n        + p9.theme_linedraw()\n        + p9.lims(x=[minHP, maxHP], y=[minMPG, maxMPG])\n        + p9.scale_color_continuous(limits=(minWt, maxWt))\n    )\n\n    if fig is None:\n        fig = p.draw()\n        axs = fig.axes\n    else:\n        for artist in get_current_artists():\n            artist.remove()\n        p._draw_using_figure(fig, axs)\n\n\ncylSelect.observe(plotUpdate, \"value\")\nwtSelect.observe(plotUpdate, \"value\")\n\n# Display the widgets\ndisplay(widgetsCtl)\n\n# Plots the first image, with inintial values.\nplotUpdate()\n\n# Matplotlib function to make the image fit within the plot dimensions.\nplt.tight_layout()\n\n# Trick to get the first rendered image to follow the previous \"tight_layout\" command.\n# without this, only after the first update would the figure be fit inside its dimensions.\ncylSelect.value = cylList[0]\n\n\n\n\n\n\n\n\n\n\nFinally, we can change some plot properties to make the final figure more understandable.\n\n# The first selection is a drop-down menu for number of cylinders\ncylSelect = widgets.Dropdown(\n    options=list(cylList),\n    value=cylList[1],\n    description=\"Cylinders:\",\n    disabled=False,\n)\n\n# The second selection is a range of weights\nwtSelect = widgets.SelectionRangeSlider(\n    options=wtOptions,\n    index=(0, len(wtOptions) - 1),\n    description=\"Weight\",\n    disabled=False,\n)\n\nwidgetsCtl = widgets.HBox([cylSelect, wtSelect])\n\n\n# The range of weights needs to always be dependent on the cylinder selection.\ndef updateRange(*args):\n    \"\"\"Updates the selection range from the slider depending on the cylinder selection.\"\"\"\n    cylValue = cylSelect.value\n\n    wtOptions = list(np.sort(np.unique(mtcars.loc[mtcars[\"cyl\"] == cylValue, \"wt\"])))\n\n    wtSelect.options = wtOptions\n    wtSelect.index = (0, len(wtOptions) - 1)\n\n\ncylSelect.observe(updateRange, \"value\")\n\nfig = None\naxs = None\n\n\n# This is the main function that is called to update the plot every time we chage a selection.\ndef plotUpdate(*args):\n    # Use global variables for matplotlib's figure and axis.\n    global fig, axs\n\n    # Get current values of the selection widgets\n    cylValue = cylSelect.value\n    wrRange = wtSelect.value\n\n    # Create a temporary dataset that is constrained by the user's selections of\n    # number of cylinders and weight.\n    tmpDat = mtcars.loc[\n        (mtcars[\"cyl\"] == cylValue)\n        & (mtcars[\"wt\"] &gt;= wrRange[0])\n        & (mtcars[\"wt\"] &lt;= wrRange[1]),\n        :,\n    ]\n\n    # Create plotnine's plot showing all data ins smaller grey points, and\n    # the selected data with coloured points.\n    p = (\n        ggplot(tmpDat, aes(x=\"hp\", y=\"mpg\", color=\"wt\"))\n        + p9.geom_point(mtcars, color=\"grey\")\n        + p9.geom_point(size=3)\n        + p9.theme_linedraw()\n        + p9.xlim([minHP, maxHP])\n        + p9.ylim([minMPG, maxMPG])\n        + p9.scale_color_continuous(\n            name=\"spring\", limits=(np.floor(minWt), np.ceil(maxWt))\n        )\n        + p9.labs(x=\"Horse-Power\", y=\"Miles Per Gallon\", color=\"Weight\")\n    )\n\n    if fig is None:\n        fig = p.draw()\n        axs = fig.axes\n    else:\n        for artist in get_current_artists():\n            artist.remove()\n        p._draw_using_figure(fig, axs)\n\n\ncylSelect.observe(plotUpdate, \"value\")\nwtSelect.observe(plotUpdate, \"value\")\n\n# Display the widgets\ndisplay(widgetsCtl)\n\n# Plots the first image, with inintial values.\nplotUpdate()\n\n# Matplotlib function to make the image fit within the plot dimensions.\nplt.tight_layout()\n\n# Trick to get the first rendered image to follow the previous \"tight_layout\" command.\n# without this, only after the first update would the figure be fit inside its dimensions.\ncylSelect.value = cylList[0]"
  },
  {
    "objectID": "tutorials/miscellaneous-show-counts-on-a-stacked-bar-plot.html",
    "href": "tutorials/miscellaneous-show-counts-on-a-stacked-bar-plot.html",
    "title": "Show counts on a stacked bar plot",
    "section": "",
    "text": "from plotnine import ggplot, aes, after_stat, geom_bar, geom_text\nfrom plotnine.data import mtcars\n\nA stacked bar plot.\n\n(ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(am)\")) + geom_bar(position=\"fill\"))\n\n\n\n\n\n\n\n\nWe want to know how many items are in each of the bars, so we add a geom_text with the same stat as geom_bar and map the label aesthetic to the computed count.\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(am)\"))\n    + geom_bar(position=\"fill\")\n    + geom_text(aes(label=after_stat(\"count\")), stat=\"count\")\n)\n\n\n\n\n\n\n\n\nNot what we wanted.\nWe forgot to give geom_text the same position as geom_bar. Let us fix that.\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(am)\"))\n    + geom_bar(position=\"fill\")\n    + geom_text(aes(label=after_stat(\"count\")), stat=\"count\", position=\"fill\")\n)\n\n\n\n\n\n\n\n\nThat is more like it"
  },
  {
    "objectID": "tutorials/miscellaneous-precomputed-boxplot.html",
    "href": "tutorials/miscellaneous-precomputed-boxplot.html",
    "title": "Using precomputed boxplots",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_boxplot\n)\nfrom plotnine.data import pageviews\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nPlotting a boxplot when a dataset fits in memory is simple as shown below:\n\npageviews['hour'] = pageviews.date_hour.dt.hour\ndisplay(f'Dataset contains {pageviews.shape[0]} rows')\npageviews.head()\n\n'Dataset contains 348 rows'\n\n\n\n\n\n\n\n\n\ndate_hour\npageviews\nhour\n\n\n\n\n0\n2013-02-11 21:00:00\n8860.982383\n21\n\n\n1\n2013-02-11 22:00:00\n8637.474753\n22\n\n\n2\n2013-02-11 23:00:00\n9020.593099\n23\n\n\n3\n2013-02-12 00:00:00\n8437.500380\n0\n\n\n4\n2013-02-12 01:00:00\n9157.399672\n1\n\n\n\n\n\n\n\n\n(\n    ggplot(pageviews)\n    + geom_boxplot(aes(x='factor(hour)', y='pageviews'))\n)\n\n\n\n\n\n\n\n\nBut suppose we had 348 million rows in a datastore. This becomes impractical to fetch and compute the boxplot on the fly. Instead we can precompute the aggregate statistics and use that to plot the boxplot directly.\nBelow we calculate the aggregate statistics in Pandas, but this could also be done in SQL/Pyspark on your datastore of choice. For simplicity, in this example, outliers haven’t been removed before determining aggregate statistics.\n\ndef q25(x):\n    return x.quantile(0.25)\n\ndef q75(x):\n    return x.quantile(0.75)\n\n\nprecomputed_metrics = pageviews.groupby(\"hour\").agg({'pageviews': [np.min, q25, np.median, q75, np.max]})\nprecomputed_metrics.columns = [col_name[1] for col_name in precomputed_metrics.columns]  \nprecomputed_metrics = precomputed_metrics.reset_index()\nprecomputed_metrics.head()\n\n\n\n\n\n\n\n\nhour\nmin\nq25\nmedian\nq75\nmax\n\n\n\n\n0\n0\n8437.500380\n8842.109077\n9297.046035\n9600.362430\n11762.446233\n\n\n1\n1\n8852.123978\n9177.938537\n9457.821814\n10530.072887\n11974.437292\n\n\n2\n2\n8793.076686\n9176.462389\n9704.885172\n10446.315276\n12105.406628\n\n\n3\n3\n8683.606449\n9574.722286\n10615.670464\n11290.246605\n11651.443193\n\n\n4\n4\n8252.974951\n9898.998785\n10959.909095\n11409.657288\n11603.711837\n\n\n\n\n\n\n\nA simpler boxplot (without outlier points shown) can then be plotted:\n\n(\n    ggplot(precomputed_metrics)\n    + geom_boxplot(aes(x='factor(hour)', ymin='min', lower=\"q25\", middle=\"median\", upper=\"q75\", ymax=\"max\"), stat = \"identity\")\n)"
  },
  {
    "objectID": "tutorials/miscellaneous-manipulating-date-breaks-and-date-labels.html",
    "href": "tutorials/miscellaneous-manipulating-date-breaks-and-date-labels.html",
    "title": "Manipulating date breaks and date labels",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    scale_x_datetime,\n    labs,\n    theme_set,\n    theme_linedraw,\n)\nfrom plotnine.data import economics\n\nfrom mizani.breaks import date_breaks\nfrom mizani.formatters import date_format\n\ntheme_set(theme_linedraw())  # default theme\n\nUsing the economics dataset\n\neconomics.head()\n\n\n\n\n\n\n\n\ndate\npce\npop\npsavert\nuempmed\nunemploy\n\n\n\n\n0\n1967-07-01\n507.4\n198712\n12.5\n4.5\n2944\n\n\n1\n1967-08-01\n510.5\n198911\n12.5\n4.7\n2945\n\n\n2\n1967-09-01\n516.3\n199113\n11.7\n4.6\n2958\n\n\n3\n1967-10-01\n512.9\n199311\n12.5\n4.9\n3143\n\n\n4\n1967-11-01\n518.1\n199498\n12.5\n4.7\n3066\n\n\n\n\n\n\n\nHow does the saving rate vary with time?\n\n(\n    ggplot(economics)\n    + geom_point(aes(\"date\", \"psavert\"))\n    + labs(y=\"personal saving rate\")\n)\n\n\n\n\n\n\n\n\nYikes! the calculated breaks are awful, we need to intervene. We do so using the date_breaks and date_format functions from mizani.\nSet breaks every 10 years\n\n(\n    ggplot(economics)\n    + geom_point(aes(\"date\", \"psavert\"))\n    + scale_x_datetime(breaks=date_breaks(\"10 years\"))  # new\n    + labs(y=\"personal saving rate\")\n)\n\n\n\n\n\n\n\n\nThat is better. Since all the breaks are at the beginning of the year, we can omit the month and day. Using date_format we override the format string. For more on the options for the format string see the strftime behavior.\n\n(\n    ggplot(economics)\n    + geom_point(aes(\"date\", \"psavert\"))\n    + scale_x_datetime(\n        breaks=date_breaks(\"10 years\"), labels=date_format(\"%Y\")\n    )  # modified\n    + labs(y=\"personal saving rate\")\n)\n\n\n\n\n\n\n\n\nWe can achieve the same result with a custom formating function.\n\ndef custom_date_format1(breaks):\n    \"\"\"\n    Function to format the date\n    \"\"\"\n    return [x.year if x.month == 1 and x.day == 1 else \"\" for x in breaks]\n\n\n(\n    ggplot(economics)\n    + geom_point(aes(\"date\", \"psavert\"))\n    + scale_x_datetime(  # modified\n        breaks=date_breaks(\"10 years\"), labels=custom_date_format1\n    )\n    + labs(y=\"personal saving rate\")\n)\n\n\n\n\n\n\n\n\nWe can use a custom formatting function to get results that are not obtainable with the date_format function. For example if we have monthly breaks over a handful of years we can mix date formats as follows; specify beginning of the year and every other month. Such tricks can be used reduce overcrowding.\n\nfrom datetime import date\n\n\ndef custom_date_format2(breaks):\n    \"\"\"\n    Function to format the date\n    \"\"\"\n    res = []\n    for x in breaks:\n        # First day of the year\n        if x.month == 1 and x.day == 1:\n            fmt = \"%Y\"\n        # Every other month\n        elif x.month % 2 != 0:\n            fmt = \"%b\"\n        else:\n            fmt = \"\"\n\n        res.append(date.strftime(x, fmt))\n\n    return res\n\n\n(\n    ggplot(economics.loc[40:60, :])  # modified\n    + geom_point(aes(\"date\", \"psavert\"))\n    + scale_x_datetime(\n        breaks=date_breaks(\"1 months\"), labels=custom_date_format2, minor_breaks=[]\n    )\n    + labs(y=\"personal saving rate\")\n)\n\n\n\n\n\n\n\n\nWe removed the labels but not the breaks, leaving behind dangling ticks for the skipped months. We can fix that by wrapping date_breaks around a filtering function.\n\ndef custom_date_format3(breaks):\n    \"\"\"\n    Function to format the date\n    \"\"\"\n    res = []\n    for x in breaks:\n        # First day of the year\n        if x.month == 1:\n            fmt = \"%Y\"\n        else:\n            fmt = \"%b\"\n\n        res.append(date.strftime(x, fmt))\n\n    return res\n\n\ndef custom_date_breaks(width=None):\n    \"\"\"\n    Create a function that calculates date breaks\n\n    It delegates the work to `date_breaks`\n    \"\"\"\n\n    def filter_func(limits):\n        breaks = date_breaks(width)(limits)\n        # filter\n        return [x for x in breaks if x.month % 2]\n\n    return filter_func\n\n\n(\n    ggplot(economics.loc[40:60, :])\n    + geom_point(aes(\"date\", \"psavert\"))\n    + scale_x_datetime(  # modified\n        breaks=custom_date_breaks(\"1 months\"), labels=custom_date_format3\n    )\n    + labs(y=\"personal saving rate\")\n)\n\n\n\n\n\n\n\n\nThe breaks and labels functions are tightly coupled to give us exactly what we want.\nCredit: This example was motivated by the github user lorin (Lorin Hochstein) and his endeavor to control date breaks and date labels."
  },
  {
    "objectID": "tutorials/miscellaneous-altering-colors.html",
    "href": "tutorials/miscellaneous-altering-colors.html",
    "title": "Using slightly altered colors to make a distinction between related data",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_path,\n    geom_point,\n    geom_col,\n    scale_color_discrete,\n    guides,\n    guide_legend,\n)\n\nFirst, we make up some data. The data we create has y for actual data value and yfit for a hypothetical fitted model. It also has a category column cat.\n\nn = 10\ndf = pd.DataFrame(\n    {\n        \"x\": np.arange(n),\n        \"y\": np.arange(n),\n        \"yfit\": np.arange(n) + np.tile([-0.2, 0.2], n // 2),\n        \"cat\": [\"a\", \"b\"] * (n // 2),\n    }\n)\n\nInitial plot\n\n(\n    ggplot(df)\n    + geom_col(aes(\"x\", \"y\", fill=\"cat\"))\n    + geom_point(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + geom_path(aes(\"x\", y=\"yfit\", color=\"cat\"))\n)\n\n\n\n\n\n\n\n\nThere is a clash of colors between the actual data (the bars) and the fitted model (the points and lines). A simple solution is to adjust the colors of the fitted data slightly. We do that by varying the lightness of the default color scale, make them a little darker.\n\n(\n    ggplot(df)\n    + geom_col(aes(\"x\", \"y\", fill=\"cat\"))\n    + geom_point(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + geom_path(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + scale_color_discrete(l=0.4)  # new\n)\n\n\n\n\n\n\n\n\nThere are two main pieces of information in the plot, but we a single combined legend. Since we use separate aesthetics for the actual data and fitted model, we can have distinct legends for both.\nWe manually define the legend for the fill and color aesthetics, this overrides the automatic legend creation.\n\n(\n    ggplot(df)\n    + geom_col(aes(\"x\", \"y\", fill=\"cat\"))\n    + geom_point(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + geom_path(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + scale_color_discrete(l=0.4)\n    + guides(  # new\n        fill=guide_legend(title=\"Data\"), color=guide_legend(title=\"Model\")\n    )\n)"
  },
  {
    "objectID": "reference/examples/theme_classic.html",
    "href": "reference/examples/theme_classic.html",
    "title": "Classic",
    "section": "",
    "text": "from plotnine import ggplot, aes, labs, theme_classic, geom_point\nfrom plotnine.data import mtcars\n\n\n# Gallery, themes\n(\n    ggplot(mtcars, aes(x=\"wt\", y=\"mpg\", colour=\"factor(gear)\"))\n    + geom_point()\n    + labs(\n        title= \"Fuel economy declines as weight increases\",\n        subtitle=\"(1973-74)\",\n        caption=\"Data from the 1974 Motor Trend US magazine.\",\n        x=\"Weight (1000 lbs)\",\n        y=\"Fuel economy (mpg)\",\n        colour=\"Gears\"\n    )\n    + theme_classic()\n)"
  },
  {
    "objectID": "reference/examples/theme.html",
    "href": "reference/examples/theme.html",
    "title": "plotnine {{< var version >}}",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    facet_grid,\n    labs,\n    guide_legend,\n    guides,\n    theme,\n    element_text,\n    element_line,\n    element_rect,\n    theme_set,\n    theme_void,\n)\nfrom plotnine.data import mtcars\n\n# We use theme_void as the base theme so that the modifications\n# we make in the code are transparent in the output\ntheme_set(theme_void())\nmtcars.head()\n\n\n\n\n\n\n\n\nname\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\n0\nMazda RX4\n21.0\n6\n160.0\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\n1\nMazda RX4 Wag\n21.0\n6\n160.0\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\n2\nDatsun 710\n22.8\n4\n108.0\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\n3\nHornet 4 Drive\n21.4\n6\n258.0\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\n4\nHornet Sportabout\n18.7\n8\n360.0\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\nThe base plots we will use for the demonstation and some colors.\np1 = (\n    ggplot(mtcars, aes(\"wt\", \"mpg\", color=\"factor(cyl)\"))\n    + geom_point()\n    + labs(title=\"mpg vs wt\")\n)\n\np2 = p1 + facet_grid(\"gear\", \"am\")\n\nblack = \"#222222\"\ngray = \"#666666\"\nred = \"#FF3333\"\ngreen = \"#66CC00\"\nblue = \"#3333FF\"\npurple = \"#9933FF\"\norange = \"#FF8000\"\nyellow = \"#FFFF33\"\nWhat the plots look like unmodified (unthemed).\np1\np2\nThere are 3 main top level theming elements:\nNote that none of the themeables control/modify the plotted data. e.g You cannot use text to change the appearance of objects plotted with geom_text.\ntext\np1 + theme(text=element_text(color=purple))\nrect\np1 + theme(rect=element_rect(color=black, size=3, fill=\"#EEBB0050\"))\nline\np1 + theme(line=element_line(color=black))"
  },
  {
    "objectID": "reference/examples/theme.html#theming-specific-items",
    "href": "reference/examples/theme.html#theming-specific-items",
    "title": "plotnine {{< var version >}}",
    "section": "Theming specific items",
    "text": "Theming specific items\n\naxis_line and axis_text\n\np1 + theme(\n    axis_line=element_line(size=2),\n    axis_line_x=element_line(color=red),\n    axis_line_y=element_line(color=blue),\n    axis_text=element_text(margin={\"t\": 5, \"r\": 5}),\n    axis_text_x=element_text(color=black),\n    axis_text_y=element_text(color=purple),\n)\n\n\n\n\n\n\n\n\n\np1 + theme(\n    axis_line=element_line(size=0.7, color=gray),\n    # We are focusing on the ticks, make them long\n    axis_ticks_length=20,\n    axis_ticks_length_minor=10,\n    axis_ticks_length_major=20,\n    axis_ticks=element_line(size=2),\n    axis_ticks_major=element_line(color=purple),\n    axis_ticks_major_x=element_line(size=4),  # override size=2\n    axis_ticks_major_y=element_line(color=yellow),  # override color=purple\n    axis_ticks_minor=element_line(color=red),\n    axis_ticks_minor_x=element_line(),  # do not override anything\n    axis_ticks_minor_y=element_line(color=gray),  # override color=red\n)\n\n\n\n\n\n\n\n\n\n\naxis_title and axis_ticks_pad\n\np1 + theme(\n    axis_line=element_line(size=0.7, color=gray),\n    axis_ticks=element_line(),\n    axis_title=element_text(),\n    axis_title_x=element_text(color=blue),\n    axis_title_y=element_text(color=red),\n    # The gap between the title and the ticks\n    axis_ticks_pad=20,\n    axis_ticks_pad_major=20,\n    axis_ticks_pad_minor=20,\n)\n\n\n\n\n\n\n\n\n\n\naxis_ticks_direction\n\np1 + theme(\n    axis_line=element_line(size=0.7, color=gray),\n    axis_ticks=element_line(),\n    axis_ticks_direction=\"in\",\n    axis_ticks_direction_x=\"in\",\n    axis_ticks_direction_y=\"out\",\n)\n\n\n\n\n\n\n\n\n\n\nLegend_box\nNot all themeables that affect the legend box are demonstrated\n\n(\n    p1\n    + aes(fill=\"drat\")\n    + theme(\n        legend_position=\"left\",\n        legend_direction=\"horizontal\",  # affected by the ncol=2\n        legend_box_margin=5,\n        legend_background=element_rect(color=purple, size=2, fill=\"white\"),\n        legend_box=\"vertical\",\n        legend_key=element_rect(fill=gray, alpha=0.3),\n        legend_title=element_text(color=orange, va=\"top\"),\n        legend_text=element_text(weight=\"bold\"),\n        legend_key_spacing=10,  # overridden\n        legend_key_spacing_x=15,\n        legend_key_spacing_y=5,\n    )\n    # so we can see legend_entry_spacing in action\n    + guides(color=guide_legend(ncol=2))\n)\n\n\n\n\n\n\n\n\n\n\nplot_background, panel_background and panel_border\n\np2 + theme(\n    plot_background=element_rect(fill=\"gray\", alpha=0.3),\n    panel_background=element_rect(fill=purple, alpha=0.2),\n    panel_border=element_rect(color=red, size=1),\n    panel_spacing=0.025,\n)\n\n\n\n\n\n\n\n\n\n\npanel_grid\n\np1 + theme(\n    panel_grid=element_line(color=purple),\n    panel_grid_major=element_line(size=1.4, alpha=1),\n    panel_grid_major_x=element_line(linetype=\"dashed\"),\n    panel_grid_major_y=element_line(linetype=\"dashdot\"),\n    panel_grid_minor=element_line(alpha=0.25),\n    panel_grid_minor_x=element_line(color=red),\n    panel_grid_minor_y=element_line(color=green),\n    panel_ontop=False,  # puts the points behind the grid\n)\n\n\n\n\n\n\n\n\n\n\nstrip_background, strip_align and strip_text\n\np2 + theme(\n    panel_spacing=0.025,\n    panel_background=element_rect(fill=gray, alpha=0.2),\n    strip_background=element_rect(color=purple, fill=orange, size=1.4, alpha=0.95),\n    strip_background_x=element_rect(x=1 / 6, width=2 / 3),  # you can get really crazy\n    strip_background_y=element_rect(),\n    strip_align=0,\n    strip_align_x=0.2,\n    strip_align_y=0.2,\n    strip_text=element_text(weight=\"bold\"),\n    strip_text_x=element_text(color=red),\n    strip_text_y=element_text(color=blue),\n)\n\n\n\n\n\n\n\n\n\n\naspect_ratio and figure_size\nThe aspect_ratio takes precedence over the figure_size, and it modifies the height. The effective width and height are:\nwidth = figure_size[0]\nheight = figure_size[0] * aspect_ratio\n\np1 + theme(\n    panel_background=element_rect(fill=gray, alpha=0.2),\n    figure_size=(8, 6),  # inches\n    aspect_ratio=1 / 3,  # height:width\n)"
  },
  {
    "objectID": "reference/examples/scale_x_continuous.html",
    "href": "reference/examples/scale_x_continuous.html",
    "title": "Guitar Neck ###",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    geom_path,\n    scale_x_continuous,\n    scale_y_continuous,\n    guides,\n    theme,\n    element_line,\n    element_rect,\n)\nfrom mizani.transforms import trans\n\nUsing a transformed x-axis to visualise guitar chords\nThe x-axis is transformed to resemble the narrowing width of frets on a 25.5 inch Strat. To do that we create custom transformation.\nThe key parts of any transform object are the transform and inverse functions.\n\nclass frets_trans(trans):\n    \"\"\"\n    Frets Transformation\n    \"\"\"\n\n    number_of_frets = 23  # Including fret 0\n    domain = (0, number_of_frets - 1)\n\n    @staticmethod\n    def transform(x):\n        x = np.asarray(x)\n        return 25.5 - (25.5 / (2 ** (x / 12)))\n\n    @staticmethod\n    def inverse(x):\n        x = np.asarray(x)\n        return 12 * np.log2(25.5 / (25.5 - x))\n\n    @classmethod\n    def breaks_(cls, limits):\n        # Fixed major breaks\n        return cls.domain\n\n    @classmethod\n    def minor_breaks(cls, major, limits):\n        # The major breaks as passed to this method are in transformed space.\n        # The minor breaks are calculated in data space to reveal the\n        # non-linearity of the scale.\n        _major = cls.inverse(major)\n        minor = cls.transform(np.linspace(*_major, cls.number_of_frets))\n        return minor\n\nThe above transform is different from most in that, breaks and minor breaks do not change. This is common of very specialized scales. It can also be a key requirement when creating graphics for demontration purposes.\nSome chord Data\n\n# Notes: the 0 fret is an open strum, all other frets are played half-way between fret bars.\n# The strings are 1:low E, 2: A, 3: D, 4: G, 5: B, 6: E\nc_chord = pd.DataFrame({\"Fret\": [0, 2.5, 1.5, 0, 0.5, 0], \"String\": [1, 2, 3, 4, 5, 6]})\n\n# Sequence based on the number of notes in the chord\nc_chord[\"Sequence\"] = list(range(1, 1 + len(c_chord[\"Fret\"])))\n\n# Standard markings for a Stratocaster\nmarkings = pd.DataFrame(\n    {\n        \"Fret\": [2.5, 4.5, 6.5, 8.5, 11.5, 11.5, 14.5, 16.5, 18.5, 20.5],\n        \"String\": [3.5, 3.5, 3.5, 3.5, 2, 5, 3.5, 3.5, 3.5, 3.5],\n    }\n)\n\nVisualizing the chord\n\n# Gallery, elaborate\n\n# Look and feel of the graphic\nneck_color = \"#FFDDCC\"\nfret_color = \"#998888\"\nstring_color = \"#AA9944\"\n\nneck_theme = theme(\n    figure_size=(10, 2),\n    panel_background=element_rect(fill=neck_color),\n    panel_grid_major_y=element_line(color=string_color, size=2.2),\n    panel_grid_major_x=element_line(color=fret_color, size=2.2),\n    panel_grid_minor_x=element_line(color=fret_color, size=1),\n)\n\n(\n    ggplot(c_chord, aes(\"Fret\", \"String\"))\n    + geom_path(aes(color=\"Sequence\"), size=3)\n    + geom_point(aes(color=\"Sequence\"), fill=\"#FFFFFF\", size=3)\n    + geom_point(data=markings, fill=\"#000000\", size=4)\n    + scale_x_continuous(trans=frets_trans)\n    + scale_y_continuous(breaks=range(0, 7), minor_breaks=[])\n    + guides(color=False)\n    + neck_theme\n)\n\n\n\n\n\n\n\n\nCredit: This example was motivated by Jonathan Vitale who wanted to create graphics for a guitar scale trainer."
  },
  {
    "objectID": "reference/examples/scale_fill_continuous.html",
    "href": "reference/examples/scale_fill_continuous.html",
    "title": "Simple heatmap",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    theme_matplotlib,\n    theme_set,\n    geom_tile,\n    scale_fill_continuous,\n    coord_cartesian\n)\n\nfrom plotnine.data import faithfuld\n\n# Set default theme for all the plots\ntheme_set(theme_matplotlib())\n\nMap data to color gradient\nWithout specifically calling scale_fill_continuous(), a default scale is applied to geom_tile().\n\nfaithfuld.head()\n\n\n\n\n\n\n\n\neruptions\nwaiting\ndensity\n\n\n\n\n0\n1.600000\n43.0\n0.003216\n\n\n1\n1.647297\n43.0\n0.003835\n\n\n2\n1.694595\n43.0\n0.004436\n\n\n3\n1.741892\n43.0\n0.004978\n\n\n4\n1.789189\n43.0\n0.005424\n\n\n\n\n\n\n\n\n(\n    ggplot(faithfuld, aes(\"waiting\", \"eruptions\", fill=\"density\")) \n    + geom_tile()\n)\n\n\n\n\n\n\n\n\nNotice that adding scale_fill_continuous() will not change the default plot.\n\n(\n    ggplot(faithfuld, aes(\"waiting\", \"eruptions\", fill=\"density\"))\n    + geom_tile()\n    + scale_fill_continuous()\n)\n\n\n\n\n\n\n\n\nThe scale aesthetics can be edited to other color maps. Use the cmap_name argument to specify an alternative palette. Find other available color maps in the matplotlib documentation.\n\n# Gallery, tiles\n\n(\n    ggplot(faithfuld, aes(\"waiting\", \"eruptions\", fill=\"density\"))\n    + geom_tile()\n    + scale_fill_continuous(cmap_name=\"plasma\")\n    + coord_cartesian(expand=False)\n)"
  },
  {
    "objectID": "reference/examples/reorder.html",
    "href": "reference/examples/reorder.html",
    "title": "plotnine {{< var version >}}",
    "section": "",
    "text": "import pandas as pd\nfrom plotnine import ggplot, aes, geom_col\n\ndf = pd.DataFrame({\n    \"x\": [\"b\", \"d\", \"c\", \"a\"],\n    \"y\": [1, 2, 3, 4]\n})\n\nggplot(df, aes(\"reorder(x, y)\", \"y\")) + geom_col()"
  },
  {
    "objectID": "reference/examples/geom_vline.html",
    "href": "reference/examples/geom_vline.html",
    "title": "Vertical line",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    geom_vline,\n    facet_grid,\n    labs,\n    element_rect,\n    theme,\n    theme_matplotlib,\n    theme_set,\n)\nfrom plotnine.data import mpg\n\n# Set default theme\n# matplotlib + the background of 538\ntheme_set(\n    theme_matplotlib()\n    + theme(\n        plot_background=element_rect(fill=\"#F0F0F0\"),\n        panel_background=element_rect(fill=\"#F0F0F0\"),\n        panel_spacing=0.015,\n        \n    )\n)\n\ngeom_vline() draws a vertical line, and is useful as a guide.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nIt’s useful to use geom_vline() with some data, so we start with a basic scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nAdd a vertical line to the scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_vline(xintercept=5)  # add one vertical line\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can add many vertical lines:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_vline(xintercept=[4, 5, 7])  # add many vertical lines using a list\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_vline(\n        xintercept=[4, 5, 7],\n        colour=[\"red\", \"orange\", \"green\"],  # add colour\n        size=[1, 2, 3],  # set line thickness\n        linetype=\"dotted\",  # set line type\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nAdd vertical lines to a facet plot:\n\nFacets with a Vertical Line\n\n# Gallery, lines\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_vline(xintercept=5, color=\"brown\", size=1)  # add a vertical line...\n    + facet_grid(\"drv\")  # ... to a facet plot\n    + labs(x=\"displacement\", y=\"horsepower\")\n)"
  },
  {
    "objectID": "reference/examples/geom_tile.html",
    "href": "reference/examples/geom_tile.html",
    "title": "Periodic Table",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_tile,\n    geom_text,\n    scale_y_reverse,\n    scale_y_discrete,\n    scale_fill_brewer,\n    scale_color_manual,\n    coord_equal,\n    theme,\n    theme_void,\n    element_blank,\n    element_rect,\n    element_text,\n)\n\nGraphing of highly organised tabular information\nRead the data.\n\nelements = pd.read_csv(\"data/elements.csv\")\nelements.head()\n\n\n\n\n\n\n\n\natomic number\nsymbol\nname\natomic mass\nCPK\nelectronic configuration\nelectronegativity\natomic radius\nion radius\nvan der Waals radius\n...\nEA\nstandard state\nbonding type\nmelting point\nboiling point\ndensity\nmetal\nyear discovered\ngroup\nperiod\n\n\n\n\n0\n1\nH\nHydrogen\n1.00794\n#FFFFFF\n1s1\n2.20\n37.0\nNaN\n120.0\n...\n-73.0\ngas\ndiatomic\n14.0\n20.0\n0.00009\nnonmetal\n1766\n1\n1\n\n\n1\n2\nHe\nHelium\n4.002602\n#D9FFFF\n1s2\nNaN\n32.0\nNaN\n140.0\n...\n0.0\ngas\natomic\nNaN\n4.0\n0.00000\nnoble gas\n1868\n18\n1\n\n\n2\n3\nLi\nLithium\n6.941\n#CC80FF\n[He] 2s1\n0.98\n134.0\n76 (+1)\n182.0\n...\n-60.0\nsolid\nmetallic\n454.0\n1615.0\n0.54000\nalkali metal\n1817\n1\n2\n\n\n3\n4\nBe\nBeryllium\n9.012182\n#C2FF00\n[He] 2s2\n1.57\n90.0\n45 (+2)\nNaN\n...\n0.0\nsolid\nmetallic\n1560.0\n2743.0\n1.85000\nalkaline earth metal\n1798\n2\n2\n\n\n4\n5\nB\nBoron\n10.811\n#FFB5B5\n[He] 2s2 2p1\n2.04\n82.0\n27 (+3)\nNaN\n...\n-27.0\nsolid\ncovalent network\n2348.0\n4273.0\n2.46000\nmetalloid\n1807\n13\n2\n\n\n\n\n5 rows × 21 columns\n\n\n\nAlter the data types of the information that will be plotted. This makes it convenient to work with.\n\nelements[\"group\"] = [-1 if g == \"-\" else int(g) for g in elements.group]\nelements[\"bonding type\"] = elements[\"bonding type\"].astype(\"category\")\nelements[\"metal\"] = elements[\"metal\"].astype(\"category\")\nelements[\"atomic_number\"] = elements[\"atomic number\"].astype(str)\n\nThe periodic table has two tables, a top and bottom. The elements in the top have groups, and those in the bottom have no groups. We make separate dataframes for both – they have different alignments.\n\ntop = elements.query(\"group != -1\").copy()\nbottom = elements.query(\"group == -1\").copy()\n\nThe top table is nice and well behaving. The x location of the elements indicate the group and the y locations the period.\n\ntop[\"x\"] = top.group\ntop[\"y\"] = top.period\n\nThe bottom table has 2 rows, with the atomic number increasing to the right. We create an x based on the atomic number and add a horizontal shift. As the dataframe is ordered by atomic number, the operation is easier. The bottom elements are labelled with a “period”. We add a vertical shift to give us a good y location that gives the appearance of two tables.\n\nnrows = 2\nhshift = 3.5\nvshift = 3\nbottom[\"x\"] = np.tile(np.arange(len(bottom) // nrows), nrows) + hshift\nbottom[\"y\"] = bottom.period + vshift\n\nWe will be plotting using tiles and we want to have some space between the tiles. We have set the x and y locations above to take up a unit of space. To get a good effect, the tile dimensions should be less than 1.\n\ntile_width = 0.95\ntile_height = 0.95\n\nFirst peak\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n)\n\n\n\n\n\n\n\n\nThe table upside down. We could have been more careful when creating the y locations since the periods are drawn in descending order. But, we can fix that with a reverse scale.\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + scale_y_reverse()  # new\n)\n\n\n\n\n\n\n\n\nLet us apply some color to it.\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")  # new\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + scale_y_reverse()\n)\n\n\n\n\n\n\n\n\n\nNow for some trick\nGoal: To add text to the tiles\nThere are four pieces of text that we shall add to the tiles, that is 4 geom_text additions. As we have two tables, that comes to 8 geom_text additions. When any geom is added to a ggplot object, behind the scenes a layer is created and added. We can create a group of layers that can be added to a ggplot object in one go using a list.\nWe use a function that accepts a dataframe, and returns a list of geoms.\n\ndef inner_text(data):\n    layers = [\n        geom_text(\n            data,\n            aes(label=\"atomic_number\"),\n            nudge_x=-0.40,\n            nudge_y=0.40,\n            ha=\"left\",\n            va=\"top\",\n            fontweight=\"normal\",\n            size=6,\n        ),\n        geom_text(data, aes(label=\"symbol\"), nudge_y=0.1, size=9),\n        geom_text(\n            data, aes(label=\"name\"), nudge_y=-0.125, fontweight=\"normal\", size=4.5\n        ),\n        geom_text(\n            data, aes(label=\"atomic mass\"), nudge_y=-0.3, fontweight=\"normal\", size=4.5\n        ),\n    ]\n    return layers\n\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)  # new\n    + inner_text(bottom)  # new\n    + scale_y_reverse()\n)\n\n\n\n\n\n\n\n\nIt is crowded in there and the tiles do not have equal dimentions. Use the theme create a larger figure. coord_equal give us equal units along the axes, this makes the tiles square.\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)\n    + inner_text(bottom)\n    + scale_y_reverse()\n    + coord_equal(expand=False)  # new\n    + theme(figure_size=(12, 6))  # new\n)\n\n\n\n\n\n\n\n\nIt is has all the information we want, except one for complication. Elements Lu and Lr also belong in the bottom table. One way to show this duality is to have tiles with two colors split horizontally.\nThe colors are determined by the metal field, and we know the x and y locations. We create a dataframe with this information to create a half-tile. A half-tile is centered at the quarter mark.\n\nsplit_df = pd.DataFrame(\n    {\n        \"x\": 3 - tile_width / 4,\n        \"y\": [6, 7],\n        \"metal\": pd.Categorical([\"lanthanoid\", \"actinoid\"]),\n    }\n)\n\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(split_df, aes(width=tile_width / 2, height=tile_height))  # new\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)\n    + inner_text(bottom)\n    + scale_y_reverse()\n    + coord_equal(expand=False)\n    + theme(figure_size=(12, 6))\n)\n\n\n\n\n\n\n\n\nChange the fill color for a different look and use a theme that clears out all the clutter.\n\nfrom plotnine import guides\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(split_df, aes(width=tile_width / 2, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)\n    + inner_text(bottom)\n    + scale_y_reverse()\n    + scale_fill_brewer(type=\"qual\", palette=3)  # new\n    + coord_equal(expand=False)\n    + theme_void()  # new\n    + theme(\n        figure_size=(12, 6),\n        plot_margin_left=0.01,\n        plot_margin_right=0.01,\n        plot_background=element_rect(fill=\"white\"),\n    )  # new\n)\n\n\n\n\n\n\n\n\nAdd the group number along the top most row of each column, and period number along the left side of the top table.\nFor the period number, we set the breaks on the y scale.\n\n# The location of the group number is the top most (and therefore smallest period)\n# element with the group\ngroupdf = top.groupby(\"group\").agg(y=(\"period\", \"min\")).reset_index()\n\nFinally,\n\n# Gallery, tiles\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(split_df, aes(width=tile_width / 2, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)\n    + inner_text(bottom)\n    + geom_text(\n        groupdf,\n        aes(\"group\", \"y\", label=\"group\"),\n        color=\"gray\",\n        nudge_y=0.525,\n        va=\"bottom\",\n        fontweight=\"normal\",\n        size=9,\n        inherit_aes=False,\n    )  # new\n    + scale_y_reverse(breaks=range(1, 8), limits=(0, 10.5))  # modified\n    + scale_fill_brewer(type=\"qual\", palette=3)\n    + coord_equal(expand=False)\n    + theme_void()\n    + theme(\n        figure_size=(12, 6),\n        plot_margin_left=0.01,\n        plot_margin_right=0.01,\n        plot_background=element_rect(fill=\"white\"),\n        axis_text_y=element_text(margin={\"r\": 5}, color=\"gray\", size=9),  # new\n    )\n)\n\n\n\n\n\n\n\n\nWhat we could have done different:\n\nAfter we set the x and y positions in th the top and bottom dataframes, we could have concatenated them back together. Then, that Layers trick would not save us much.\n\nPro tip: Save the plot as a pdf.\n\n\nAnnotated Heatmap\nConditinous data recorded at discrete time intervals over many cycles\nRead data\n\nflights = pd.read_csv(\"data/flights.csv\")\nmonths = flights[\"month\"].unique()  # Months ordered January, ..., December\nflights[\"month\"] = pd.Categorical(flights[\"month\"], categories=months)\nflights.head()\n\n\n\n\n\n\n\n\nyear\nmonth\npassengers\n\n\n\n\n0\n1949\nJanuary\n112\n\n\n1\n1949\nFebruary\n118\n\n\n2\n1949\nMarch\n132\n\n\n3\n1949\nApril\n129\n\n\n4\n1949\nMay\n121\n\n\n\n\n\n\n\n\n# We use 'factor(year)' -- a discrete -- instead of 'year' so that all the years\n# are displayed along the x-axis.\n# The .95s create spacing between the tiles.\n\n(\n    ggplot(flights, aes(\"factor(year)\", \"month\", fill=\"passengers\"))\n    + geom_tile(aes(width=0.95, height=0.95))\n    + geom_text(aes(label=\"passengers\"), size=9)\n)\n\n\n\n\n\n\n\n\nThat looks like what we want, but it could do with a few tweaks. First the contrast between the tiles and the text is not good for the lower passenger numbers. We use pd.cut to partition the number of passengers into two discrete groups.\n\nflights[\"p_group\"] = pd.cut(\n    flights[\"passengers\"], (0, 300, 1000), labels=(\"low\", \"high\")\n)\nflights.head()\n\n\n\n\n\n\n\n\nyear\nmonth\npassengers\np_group\n\n\n\n\n0\n1949\nJanuary\n112\nlow\n\n\n1\n1949\nFebruary\n118\nlow\n\n\n2\n1949\nMarch\n132\nlow\n\n\n3\n1949\nApril\n129\nlow\n\n\n4\n1949\nMay\n121\nlow\n\n\n\n\n\n\n\n\n(\n    ggplot(flights, aes(\"factor(year)\", \"month\", fill=\"passengers\"))\n    + geom_tile(aes(width=0.95, height=0.95))\n    + geom_text(aes(label=\"passengers\", color=\"p_group\"), size=9, show_legend=False)  # modified\n    + scale_color_manual([\"white\", \"black\"])  # new\n)\n\n\n\n\n\n\n\n\nLast tweaks, put January at the top and remove the axis ticks and plot background.\n\n# Gallery, tiles\n\n(\n    ggplot(flights, aes(\"factor(year)\", \"month\", fill=\"passengers\"))\n    + geom_tile(aes(width=0.95, height=0.95))\n    + geom_text(aes(label=\"passengers\", color=\"p_group\"), size=9, show_legend=False)\n    + scale_color_manual([\"white\", \"black\"])  # new\n    + scale_y_discrete(limits=months[::-1])  # new\n    + theme(  # new\n        axis_ticks=element_blank(),\n        panel_background=element_rect(fill=\"white\"),\n    )\n)\n\n\n\n\n\n\n\n\nYou can get similar results if you replace\n + geom_tile(aes(width=.95, height=.95))\n + geom_text(aes(label='passengers', color='p_group'), size=9, show_legend=False)\nwith\n+ geom_label(aes(label='passengers', color='p_group'), size=9, show_legend=False)\nCredit: This example is a recreation of this seaborn example."
  },
  {
    "objectID": "reference/examples/geom_smooth.html",
    "href": "reference/examples/geom_smooth.html",
    "title": "Smoothed conditional means",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_point, geom_smooth, labs, theme_matplotlib, theme_set\nfrom plotnine.data import mpg\n\ntheme_set(theme_matplotlib())\n\nAids the eye in seeing patterns in the presence of overplotting.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_smooth()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nUse span to control the “wiggliness” of the default loess smoother. The span is the fraction of points used to fit each local regression: small numbers make a wigglier curve, larger numbers make a smoother curve.\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_smooth(span=0.3)\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can remove confidence interval around smooth with se=False:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_smooth(span=0.3, se=False)\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nInstead of a loess smooth, you can use any other modelling function:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_smooth(method=\"lm\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\n\nPoints & Linear Models\n\n# Gallery, points\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\", color=\"factor(drv)\"))\n    + geom_point()\n    + geom_smooth(method=\"lm\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)"
  },
  {
    "objectID": "reference/examples/geom_point.html",
    "href": "reference/examples/geom_point.html",
    "title": "Basic Scatter Plot",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    theme_matplotlib,\n    theme_set,\n)\n\n# Set default theme for all the plots\ntheme_set(theme_matplotlib())\n\n\nnp.random.seed(123)\nn = 150\n\ndf = pd.DataFrame({\n    \"x\": np.random.randint(0, 101, n),\n    \"y\": np.random.randint(0, 101, n),\n    \"var1\": np.random.randint(1, 6, n),\n    \"var2\": np.random.randint(0, 11, n)\n})\n\n\n# Gallery, points\n(\n    ggplot(df, aes(\"x\", \"y\"))\n    + geom_point()\n)\n\n\n\n\n\n\n\n\n\nColoured Point Bubbles\n\n(\n    ggplot(df, aes(\"x\", \"y\", size=\"var1\"))\n    + geom_point(aes(color=\"var2\"))\n)\n\n\n\n\n\n\n\n\n\n# Gallery, points\n(\n    ggplot(df, aes(\"x\", \"y\", size=\"var1\"))\n    + geom_point(aes(fill=\"var2\"), stroke=0, alpha=0.5)\n    + geom_point(aes(color=\"var2\"), fill=\"none\")\n)"
  },
  {
    "objectID": "reference/examples/geom_map.html",
    "href": "reference/examples/geom_map.html",
    "title": "plotnine {{< var version >}}",
    "section": "",
    "text": "import geopandas as gp\nimport geodatasets\nfrom plotnine import (\n    ggplot,\n    aes,\n    coord_fixed,\n    facet_wrap,\n    geom_map,\n    geom_text,\n    labs,\n    scale_fill_brewer,\n    scale_fill_continuous,\n    scale_x_continuous,\n    scale_y_continuous,\n    scale_size_continuous,\n    stage,\n    coord_cartesian,\n    element_line,\n    element_rect,\n    element_text,\n    theme_void,\n    theme,\n)\n\nDefine some useful functions\n\ndef good_centroid(geometry):\n    \"\"\"\n    Calculate \"good\" centroids for polygons in the geometry\n\n    The polygon is projected onto the Equal Area Cylindrical projection,\n    the centroids are computed, then mapped back onto the original\n    coordinate system.\n    \"\"\"\n    return geometry.to_crs(\"+proj=cea\").centroid.to_crs(geometry.crs)\n\n\ndef overlay_color(rgb_hex_colors, light=\"white\", dark=\"black\", threshold=0.5):\n    \"\"\"\n    Decide which color is suitable to write onto the given colors\n    \"\"\"\n    def luminance(rgb_hex):\n        \"\"\"\n        Calculate the Luminance ([0, 1]) of a hex color\n        \"\"\"\n        r = int(rgb_hex[1:3], 16)\n        g = int(rgb_hex[3:5], 16)\n        b = int(rgb_hex[5:], 16)\n        luma = (r*0.299 + g*0.587 + b*0.0722) / 256\n        return luma\n    return [light if luminance(x) &lt; threshold  else dark for x in rgb_hex_colors]\n\n\nA Map from geodatasets\nWe are going to use a dataset from the geodatasets package. We can explore the dataset providers at geodatasets.data, each of which has one or more datasets:\nWe choose the dataset of Sudden Infant Death (SIDS) counts from counties in North Carolina. We can see some meta information about that dataset. You can view the details with geodatasets.data.geoda.sids.\nDownload the dataset we want (it is automatically cached).\n\ngeodatasets.fetch(\"geoda sids\")\n\nRead data\n\nsids = gp.read_file(geodatasets.get_path(\"geoda.sids\"))\nsids.head()\n\n\n\n\n\n\n\n\nAREA\nPERIMETER\nCNTY_\nCNTY_ID\nNAME\nFIPS\nFIPSNO\nCRESS_ID\nBIR74\nSID74\nNWBIR74\nBIR79\nSID79\nNWBIR79\ngeometry\n\n\n\n\n0\n0.114\n1.442\n1825\n1825\nAshe\n37009\n37009\n5\n1091.0\n1.0\n10.0\n1364.0\n0.0\n19.0\nPOLYGON ((-81.47276 36.23436, -81.54084 36.272...\n\n\n1\n0.061\n1.231\n1827\n1827\nAlleghany\n37005\n37005\n3\n487.0\n0.0\n10.0\n542.0\n3.0\n12.0\nPOLYGON ((-81.23989 36.36536, -81.24069 36.379...\n\n\n2\n0.143\n1.630\n1828\n1828\nSurry\n37171\n37171\n86\n3188.0\n5.0\n208.0\n3616.0\n6.0\n260.0\nPOLYGON ((-80.45634 36.24256, -80.47639 36.254...\n\n\n3\n0.070\n2.968\n1831\n1831\nCurrituck\n37053\n37053\n27\n508.0\n1.0\n123.0\n830.0\n2.0\n145.0\nMULTIPOLYGON (((-76.00897 36.3196, -76.01735 3...\n\n\n4\n0.153\n2.206\n1832\n1832\nNorthampton\n37131\n37131\n66\n1421.0\n9.0\n1066.0\n1606.0\n3.0\n1197.0\nPOLYGON ((-77.21767 36.24098, -77.23461 36.214...\n\n\n\n\n\n\n\nThe sids data has two periods 1974 - 1978 and 1979 - 1985. For each period there is a number of births and a number of deaths. We want to visually compare the deaths per 1000 in each county for the two periods.\n\ndata = sids.copy()\n\n# Calculate the death per 1000\ndata[\"1974 - 1978\"] = (data[\"SID74\"] / data[\"BIR74\"]) * 1000\ndata[\"1979 - 1984\"] = (data[\"SID79\"] / data[\"BIR79\"]) * 1000\n\n# Calculate center coordinates for the counties\ndata[\"center_lon\"] = good_centroid(data.geometry).x\ndata[\"center_lat\"] = good_centroid(data.geometry).y\n\n# Make the data\ndata = data.melt(\n    id_vars=[\"NAME\", \"geometry\", \"center_lon\", \"center_lat\"],\n    value_vars=[\"1974 - 1978\", \"1979 - 1984\"],\n    var_name=\"period\",\n    value_name=\"deaths_per_1k\",\n).rename(\n    {\"NAME\": \"county\"},\n    axis=1\n)\n\ndata.head()\n\n\n\n\n\n\n\n\ncounty\ngeometry\ncenter_lon\ncenter_lat\nperiod\ndeaths_per_1k\n\n\n\n\n0\nAshe\nPOLYGON ((-81.47276 36.23436, -81.54084 36.272...\n-81.498245\n36.431263\n1974 - 1978\n0.916590\n\n\n1\nAlleghany\nPOLYGON ((-81.23989 36.36536, -81.24069 36.379...\n-81.125138\n36.490963\n1974 - 1978\n0.000000\n\n\n2\nSurry\nPOLYGON ((-80.45634 36.24256, -80.47639 36.254...\n-80.685736\n36.412381\n1974 - 1978\n1.568381\n\n\n3\nCurrituck\nMULTIPOLYGON (((-76.00897 36.3196, -76.01735 3...\n-76.027392\n36.407026\n1974 - 1978\n1.968504\n\n\n4\nNorthampton\nPOLYGON ((-77.21767 36.24098, -77.23461 36.214...\n-77.410484\n36.422110\n1974 - 1978\n6.333568\n\n\n\n\n\n\n\nPlot the data\n\n# Gallery, maps\n\n(\n    ggplot(data)\n    + geom_map(aes(fill=\"deaths_per_1k\"))\n    + geom_text(\n        aes(\n            \"center_lon\",\n            \"center_lat\",\n            label=\"county\",\n            color=stage(\"deaths_per_1k\", after_scale=\"overlay_color(color)\")\n        ),\n        size=6,\n        show_legend=False\n    )\n    + scale_fill_continuous(\n        name=\"Deaths Per 1000\",\n        cmap_name=\"plasma\",\n        breaks=[0, 2.5, 5, 7.5, 10],\n        labels=[\"0\", \"2.5\", \"5\", \"7.5\", \"10\"],\n        limits=[0, 10],\n    )\n    + facet_wrap(\n        \"period\",\n        ncol=1,\n        labeller=lambda s: f\"Sudden Infant Deaths in the Period {s}\"\n    )\n    + coord_fixed(expand=False)\n    + theme_void()\n    + theme(\n        figure_size=(12, 8),\n        legend_position=(0, 0),\n        legend_direction=\"horizontal\",\n        legend_title_position=\"top\",\n        plot_margin=0.01,\n        plot_background=element_rect(fill=\"white\"),\n        panel_spacing=0.025,\n        legend_frame=element_rect(color=\"black\"),\n        legend_ticks=element_line(color=\"black\"),\n        strip_text=element_text(size=12),\n    )\n)\n\n\n\n\n\n\n\n\n\n\nThe Territories of Westeros\nLayering different features on a Map\nRead data and select features in Westeros only.\n\ncontinents = gp.read_file(\"data/lands-of-ice-and-fire/continents.shp\")\nislands = gp.read_file(\"data/lands-of-ice-and-fire/islands.shp\")\nlakes = gp.read_file(\"data/lands-of-ice-and-fire/lakes.shp\")\nrivers = gp.read_file(\"data/lands-of-ice-and-fire/rivers.shp\")\npolitical = gp.read_file(\"data/lands-of-ice-and-fire/political.shp\")\nwall = gp.read_file(\"data/lands-of-ice-and-fire/wall.shp\")\nroads = gp.read_file(\"data/lands-of-ice-and-fire/roads.shp\")\nlocations = gp.read_file(\"data/lands-of-ice-and-fire/locations.shp\")\n\nwesteros = continents.query('name==\"Westeros\"')\nislands = islands.query('continent==\"Westeros\" and name!=\"Summer Islands\"')\nlakes = lakes.query('continent==\"Westeros\"')\nrivers = rivers.query('continent==\"Westeros\"')\nroads = roads.query('continent==\"Westeros\"')\n\nwg = westeros.geometry[0]\nbool_idx = [wg.contains(g) for g in locations.geometry]\nwesteros_locations = locations[bool_idx]\ncities = westeros_locations[westeros_locations[\"type\"] == \"City\"].copy()\n\nCreate map by placing the features in layers in an order that limits obstraction.\nThe GeoDataFrame.geometry.centroid property has the center coordinates of polygons, we use these to place the labels of the political regions.\n\n# Gallery, maps\n\n# colors\nwater_color = \"#a3ccff\"\nwall_color = \"white\"\nroad_color = \"brown\"\n\n\n# Create label text by merging the territory name and\n# the claimant to the territory\ndef fmt_labels(names, claimants):\n    labels = []\n    for name, claimant in zip(names, claimants):\n        if name:\n            labels.append(\"{} ({})\".format(name, claimant))\n        else:\n            labels.append(\"({})\".format(claimant))\n    return labels\n\n\ndef calculate_center(df):\n    \"\"\"\n    Calculate the centre of a geometry\n\n    This method first converts to a planar crs, gets the centroid\n    then converts back to the original crs. This gives a more\n    accurate\n    \"\"\"\n    original_crs = df.crs\n    planar_crs = \"EPSG:3857\"\n    return df[\"geometry\"].to_crs(planar_crs).centroid.to_crs(original_crs)\n\n\npolitical[\"center\"] = calculate_center(political)\ncities[\"center\"] = calculate_center(cities)\n\n(\n    ggplot()\n    + geom_map(westeros, fill=None)\n    + geom_map(islands, fill=None)\n    + geom_map(political, aes(fill=\"ClaimedBy\"), color=None, show_legend=False)\n    + geom_map(wall, color=wall_color, size=2)\n    + geom_map(lakes, fill=water_color, color=None)\n    + geom_map(rivers, aes(size=\"size\"), color=water_color, show_legend=False)\n    + geom_map(roads, aes(size=\"size\"), color=road_color, alpha=0.5, show_legend=False)\n    + geom_map(cities, size=1)\n    + geom_text(\n        political,\n        aes(\"center.x\", \"center.y\", label=\"fmt_labels(name, ClaimedBy)\"),\n        size=8,\n        fontweight=\"bold\",\n    )\n    + geom_text(\n        cities,\n        aes(\"center.x\", \"center.y\", label=\"name\"),\n        size=8,\n        ha=\"left\",\n        nudge_x=0.20,\n    )\n    + labs(title=\"The Political Territories of Westeros\")\n    + scale_fill_brewer(type=\"qual\", palette=8)\n    + scale_x_continuous(expand=(0, 0, 0, 1))\n    + scale_y_continuous(expand=(0, 1, 0, 0))\n    + scale_size_continuous(range=(0.4, 1))\n    + coord_cartesian()\n    + theme_void()\n    + theme(figure_size=(8, 12), panel_background=element_rect(fill=water_color))\n)\n\n\n\n\n\n\n\n\nCredit: cadaei of the cartographersguild website forum."
  },
  {
    "objectID": "reference/examples/geom_line.html",
    "href": "reference/examples/geom_line.html",
    "title": "Line plots",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    geom_line,\n    facet_wrap,\n    labs,\n    scale_x_datetime,\n    element_text,\n    theme_538\n)\nfrom plotnine.data import meat\n\ngeom_line() connects the dots, and is useful for time series data.\n\nmeat.head()\n\n\n\n\n\n\n\n\ndate\nbeef\nveal\npork\nlamb_and_mutton\nbroilers\nother_chicken\nturkey\n\n\n\n\n0\n1944-01-01\n751.0\n85.0\n1280.0\n89.0\nNaN\nNaN\nNaN\n\n\n1\n1944-02-01\n713.0\n77.0\n1169.0\n72.0\nNaN\nNaN\nNaN\n\n\n2\n1944-03-01\n741.0\n90.0\n1128.0\n75.0\nNaN\nNaN\nNaN\n\n\n3\n1944-04-01\n650.0\n89.0\n978.0\n66.0\nNaN\nNaN\nNaN\n\n\n4\n1944-05-01\n681.0\n106.0\n1029.0\n78.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\nMake it tidy.\n\nmeat_long = meat.melt(\n    id_vars=\"date\",\n    value_vars=[\"beef\", \"veal\", \"pork\", \"lamb_and_mutton\", \"broilers\", \"turkey\"],\n    var_name=\"animal\",\n    value_name=\"weight\"\n).dropna()\n\nmeat_long.head()\n\n\n\n\n\n\n\n\ndate\nanimal\nweight\n\n\n\n\n0\n1944-01-01\nbeef\n751.0\n\n\n1\n1944-02-01\nbeef\n713.0\n\n\n2\n1944-03-01\nbeef\n741.0\n\n\n3\n1944-04-01\nbeef\n650.0\n\n\n4\n1944-05-01\nbeef\n681.0\n\n\n\n\n\n\n\nFirst try\n\np = (\n    ggplot(meat_long, aes(x=\"date\", y=\"weight\"))\n    + geom_line()\n)\np\n\n\n\n\n\n\n\n\nIt looks crowded because each there is more than one monthly entry at each x-point. We can get a single trend line by getting a monthly aggregate of the weights.\n\nmeat_long_monthly_agg = meat_long.groupby(\"date\").agg({\"weight\": \"sum\"}).reset_index()\nmeat_long_monthly_agg\n\n\n\n\n\n\n\n\ndate\nweight\n\n\n\n\n0\n1944-01-01\n2205.0\n\n\n1\n1944-02-01\n2031.0\n\n\n2\n1944-03-01\n2034.0\n\n\n3\n1944-04-01\n1783.0\n\n\n4\n1944-05-01\n1894.0\n\n\n...\n...\n...\n\n\n955\n2023-08-01\n9319.1\n\n\n956\n2023-09-01\n8586.1\n\n\n957\n2023-10-01\n9452.5\n\n\n958\n2023-11-01\n8951.1\n\n\n959\n2023-12-01\n8555.1\n\n\n\n\n960 rows × 2 columns\n\n\n\n\nA Single Trend Line\n\n(\n    ggplot(meat_long_monthly_agg, aes(x=\"date\", y=\"weight\"))\n    + geom_line()\n)\n\n\n\n\n\n\n\n\nAdd some style\n\n# Gallery, lines\n(\n    ggplot(meat_long_monthly_agg, aes(x=\"date\", y=\"weight\"))\n    + geom_line()\n    # Styling\n    + scale_x_datetime(date_breaks=\"10 years\", date_labels=\"%Y\")\n    + theme_538()\n)\n\n\n\n\n\n\n\n\nOr we can group by the animals to get a trend line for each animal\n\n\nMultiple Trend Lines\n\n(\n    ggplot(meat_long, aes(x=\"date\", y=\"weight\", group=\"animal\"))\n    + geom_line()\n    # Styling\n    + scale_x_datetime(date_breaks=\"10 years\", date_labels=\"%Y\")\n    + theme_538()\n)\n\n\n\n\n\n\n\n\nMake each group be a different color.\n\n# Gallery, lines\n(\n    ggplot(meat_long, aes(x=\"date\", y=\"weight\", color=\"animal\"))\n    + geom_line()\n    # Styling\n    + scale_x_datetime(date_breaks=\"10 years\", date_labels=\"%Y\")\n    + theme_538()\n)\n\n\n\n\n\n\n\n\n\n\nA Trend Line Per Facet\nPlot each group on a separate panel. The legend is no longer required and we adjust to the smaller panels by reducing the size of the line, size of the text and the number of grid lines.\n\n# Gallery, lines\ndef titled(strip_title):\n    return \" \".join(s.title() if s != \"and\" else s for s in strip_title.split(\"_\"))\n\n(\n    ggplot(meat_long, aes(\"date\", \"weight\", color=\"animal\"))\n    + geom_line(size=.5, show_legend=False)\n    + facet_wrap(\"animal\", labeller=titled)\n    + scale_x_datetime(date_breaks=\"20 years\", date_labels=\"%Y\")\n    + labs(\n        x=\"Date\",\n        y=\"Weight (million pounds)\",\n        title=\"Meat Production\"\n    )\n    + theme_538(base_size=9)\n)"
  },
  {
    "objectID": "reference/examples/geom_histogram.html",
    "href": "reference/examples/geom_histogram.html",
    "title": "Histograms",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    after_stat,\n    geom_histogram,\n    facet_wrap,\n    facet_grid,\n    coord_flip,\n    scale_y_continuous,\n    scale_y_sqrt,\n    scale_y_log10,\n    scale_fill_manual,\n    theme_bw,\n    theme_xkcd,\n)\nfrom plotnine.data import diamonds\nfrom mizani.formatters import percent_format\n\nVisualise the distribution of a variable by dividing the x-axis into bins and counting the number of observations in each bin. Histograms display the counts with bars.\nYou can define the number of bins (e.g. divide the data five bins) or define the binwidth (e.g. each bin is size 10).\nDistributions can be visualised as: * count, * normalised count, * density, * normalised density, * scaled density as a percentage.\n\ndiamonds.head(5)\n\n\n\n\n\n\n\n\ncarat\ncut\ncolor\nclarity\ndepth\ntable\nprice\nx\ny\nz\n\n\n\n\n0\n0.23\nIdeal\nE\nSI2\n61.5\n55.0\n326\n3.95\n3.98\n2.43\n\n\n1\n0.21\nPremium\nE\nSI1\n59.8\n61.0\n326\n3.89\n3.84\n2.31\n\n\n2\n0.23\nGood\nE\nVS1\n56.9\n65.0\n327\n4.05\n4.07\n2.31\n\n\n3\n0.29\nPremium\nI\nVS2\n62.4\n58.0\n334\n4.20\n4.23\n2.63\n\n\n4\n0.31\nGood\nJ\nSI2\n63.3\n58.0\n335\n4.34\n4.35\n2.75\n\n\n\n\n\n\n\n\nBasic Histogram\nIf you create a basic histogram, you will be prompted to define the binwidth or number of bins.\n\n# Gallery, distributions\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram()\n)\n\n\n\n\n\n\n\n\nYou can define the width of the bins, by specifying the binwidth inside geom_histogram().\n\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram(binwidth=0.5)  # specify the binwidth\n)\n\n\n\n\n\n\n\n\nOr you can define the number of bins by specifying bins inside geom_histogram(). Note, the example below uses 10 bins, however you can’t see them all because some of the bins are too small to be noticeable.\n\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram(bins=10)  # specify the number of bins\n)\n\n\n\n\n\n\n\n\nThere are different ways to visualise the distribution, you can specify this using the y argument within aes(). In the example below I’m using the default setting: raw count with after_stat('count').\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"count\"),  # specify each bin is a count\n        ),\n    )\n    + geom_histogram(binwidth=0.50)\n)\n\n\n\n\n\n\n\n\nYou can normalise the raw count to 1 by using after_stat('ncount'):\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"ncount\"),  # normalise the count to 1\n        ),\n    )\n    + geom_histogram(binwidth=0.50)\n)\n\n\n\n\n\n\n\n\nYou can display the density of points in a bin, (this is scaled to integrate to 1) by using after_stat('density'):\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"density\"),  # density\n        ),\n    )\n    + geom_histogram(binwidth=0.50)\n)\n\n\n\n\n\n\n\n\nThe proportion of bins can be shown, in the example below the bin=0.5 accounts for about ~55% of the data:\n\n(\n    ggplot(\n        diamonds,\n        aes(x=\"carat\", y=after_stat(\"width*density\")),  # show proportion\n    )\n    + geom_histogram(binwidth=0.5)\n)\n\n\n\n\n\n\n\n\nWe can also display counts as percentages by using the percent_format() which requires the mizani.formatters library:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"width*density\")))\n    + geom_histogram(binwidth=0.5)\n    + scale_y_continuous(labels=percent_format())  # display labels as a percentage\n)\n\n\n\n\n\n\n\n\nInstead of using stat you can use stat_bin defined within geom_histogram(), this is useful if you want to layer a few different plots in the one figure.\n\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram(binwidth=0.5, alpha=0.5)\n    + geom_histogram(binwidth=0.2, alpha=0.5, fill=\"green\")\n)\n\n\n\n\n\n\n\n\nYou can also flip the x-y coordinates:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"density\")))\n    + geom_histogram(binwidth=0.5)\n    + coord_flip()\n)\n\n\n\n\n\n\n\n\nYou can visualise counts by other variables using fill within aes():\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"count\"), fill=\"cut\"))\n    + geom_histogram(binwidth=0.5)\n)\n\n\n\n\n\n\n\n\nYou can visualise too-small-to-see bars by transforming the y-axis scaling by using scale_y_sqrt() square-root scale or scale_y_log10() for a log-scale (similarly use scale_x_sqrt() and scale_x_log10() to transform the x-axis).\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"count\")))\n    + geom_histogram(binwidth=0.5)\n    + scale_y_sqrt()  # square root scale\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"count\")))\n    + geom_histogram(binwidth=0.5)\n    + scale_y_log10()  # log scale\n)\n\n\n\n\n\n\n\n\nChange the look of your plot:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"density\")))\n    + geom_histogram(\n        binwidth=0.5,\n        fill=\"green\",  # change the fill colour (one colour)\n        colour=\"pink\",  # change the outline\n        size=2,  # change the thickness of the outline\n        alpha=0.7,  # change the transparency\n    )\n    + theme_xkcd()  # play with themes (look/arrangement)\n)\n\n\n\n\n\n\n\n\nAnother change, this time changing the fill colours manually:\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"density\"),\n            fill=\"cut\",  # change the fill colour using another variable\n        ),\n    )\n    + scale_fill_manual(\n        values=[\"#000000\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\"]\n    )  # change the fill colour\n    + geom_histogram(\n        binwidth=0.5,\n        colour=\"#D55E00\",  # change the outline\n        size=1,  # change the thickness of the outline\n        alpha=0.7,  # change the transparency\n    )\n    + theme_bw()  # play with themes (look/arrangement)\n)\n\n\n\n\n\n\n\n\nWhen faceting histograms with scaled counts/densities, they are normalised by each facet, and not overall. Here’s an example of a facet wrap:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"ncount\")))\n    + geom_histogram(binwidth=0.5)\n    + facet_wrap(\"color\")  # facet wrap\n)\n\n\n\n\n\n\n\n\nHere’s an example of a facet grid with the count normalised in each grid:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"ncount\")))\n    + geom_histogram(binwidth=0.5)\n    + facet_grid(\"cut\", \"color\")\n)"
  },
  {
    "objectID": "reference/examples/geom_count.html",
    "href": "reference/examples/geom_count.html",
    "title": "Categorized Data Plot",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_count, scale_size_continuous\nfrom plotnine.data import diamonds\n\ngeom_count() makes the point size proportional to the number of points at a location\n\ndiamonds.head()\n\n\n\n\n\n\n\n\ncarat\ncut\ncolor\nclarity\ndepth\ntable\nprice\nx\ny\nz\n\n\n\n\n0\n0.23\nIdeal\nE\nSI2\n61.5\n55.0\n326\n3.95\n3.98\n2.43\n\n\n1\n0.21\nPremium\nE\nSI1\n59.8\n61.0\n326\n3.89\n3.84\n2.31\n\n\n2\n0.23\nGood\nE\nVS1\n56.9\n65.0\n327\n4.05\n4.07\n2.31\n\n\n3\n0.29\nPremium\nI\nVS2\n62.4\n58.0\n334\n4.20\n4.23\n2.63\n\n\n4\n0.31\nGood\nJ\nSI2\n63.3\n58.0\n335\n4.34\n4.35\n2.75\n\n\n\n\n\n\n\n\n(\n    ggplot(diamonds)\n    + geom_count(aes(x=\"cut\", y=\"color\"))\n)\n\n\n\n\n\n\n\n\nWe can adjust the size range of the points with scale_size_continuous\n\n(\n    ggplot(diamonds)\n    + geom_count(aes(x=\"cut\", y=\"color\"))\n    + scale_size_continuous(range=[1, 20])\n)"
  },
  {
    "objectID": "reference/examples/geom_boxplot.html",
    "href": "reference/examples/geom_boxplot.html",
    "title": "A box and whiskers plot",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_boxplot,\n    geom_jitter,\n    scale_x_discrete,\n    coord_flip,\n)\nfrom plotnine.data import pageviews\nThe boxplot compactly displays the distribution of a continuous variable.\nRead more: + wikipedia + ggplot2 docs\nflights = pd.read_csv(\"data/flights.csv\")\nflights.head()\n\n\n\n\n\n\n\n\nyear\nmonth\npassengers\n\n\n\n\n0\n1949\nJanuary\n112\n\n\n1\n1949\nFebruary\n118\n\n\n2\n1949\nMarch\n132\n\n\n3\n1949\nApril\n129\n\n\n4\n1949\nMay\n121\nBasic boxplot\nmonths = [month[:3] for month in flights.month[:12]]\nprint(months)\n\n['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']"
  },
  {
    "objectID": "reference/examples/geom_boxplot.html#precomputed-boxplots",
    "href": "reference/examples/geom_boxplot.html#precomputed-boxplots",
    "title": "A box and whiskers plot",
    "section": "Precomputed boxplots",
    "text": "Precomputed boxplots\nFor datasets that do not fit in memory, you can precompute the boxplot metrics (for example by aggregating the statistics using database queries) and then use geom_boxplot with stat=\"identity\".\n\n# Precompute the metrics\ndef q25(x):\n    return x.quantile(0.25)\n\ndef q75(x):\n    return x.quantile(0.75)\n    \npageviews[\"hour\"] = pageviews.date_hour.dt.hour\nprecomputed_metrics = pageviews.groupby(\"hour\").agg({'pageviews': [\"min\", q25, \"median\", q75, \"max\"]})\nprecomputed_metrics.columns = [col_name[1] for col_name in precomputed_metrics.columns]  \nprecomputed_metrics = precomputed_metrics.reset_index()\nprecomputed_metrics.head()\n\n\n\n\n\n\n\n\nhour\nmin\nq25\nmedian\nq75\nmax\n\n\n\n\n0\n0\n8437.500380\n8842.109077\n9297.046035\n9600.362430\n11762.446233\n\n\n1\n1\n8852.123978\n9177.938537\n9457.821814\n10530.072887\n11974.437292\n\n\n2\n2\n8793.076686\n9176.462389\n9704.885172\n10446.315276\n12105.406628\n\n\n3\n3\n8683.606449\n9574.722286\n10615.670464\n11290.246605\n11651.443193\n\n\n4\n4\n8252.974951\n9898.998785\n10959.909095\n11409.657288\n11603.711837\n\n\n\n\n\n\n\n\n(\n    ggplot(precomputed_metrics)\n    + geom_boxplot(\n        aes(x=\"factor(hour)\", ymin=\"min\", lower=\"q25\", middle=\"median\", upper=\"q75\", ymax=\"max\"),\n        stat=\"identity\"\n    )\n)"
  },
  {
    "objectID": "reference/examples/geom_area.html",
    "href": "reference/examples/geom_area.html",
    "title": "Area Under Line",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    geom_area,\n    geom_line,\n    scale_x_date,\n    scale_y_continuous,\n    theme_linedraw,\n    theme_set,\n)\nfrom plotnine.data import economics\n\n# Set default theme\ntheme_set(theme_linedraw())\n\n\n# Gallery, areas\n(\n    ggplot(economics, aes(x=\"date\", y=\"unemploy\"))\n    + geom_line()\n    + geom_area(fill=\"#e5c8d6\", color=\"#9e2f68\")\n    + scale_x_date(expand=(0, 0), date_labels=\"%Y\")\n    + scale_y_continuous(expand=(0, 0, 0.1, 0))\n    + theme_linedraw()\n)"
  },
  {
    "objectID": "reference/examples/factor.html",
    "href": "reference/examples/factor.html",
    "title": "plotnine {{< var version >}}",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_bar\nfrom plotnine.data import mtcars\n\nggplot(mtcars, aes(x=\"factor(cyl)\")) + geom_bar()"
  },
  {
    "objectID": "reference/examples/facet_grid.html",
    "href": "reference/examples/facet_grid.html",
    "title": "Facet grid",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_point, labs, facet_grid, theme, element_text, element_rect\nfrom plotnine.data import mpg\n\nfacet_grid() is used to form a grid of plots, where the rows and columns of the grid are set by the faceting variables. It is useful for visualising two discrete variables.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nBasic scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nFacet a discrete variable into rows:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid(\"drv\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nFacet a discrete variable into columns:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid(cols=\"cyl\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nFacet two discrete variables into rows and columns:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid(\"drv\", \"cyl\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nTo change the plot order of the rows or columns in the facet grid, reorder the levels of the faceting variable in the data.\n\n# re-order categories\nmpg[\"drv\"] = mpg[\"drv\"].cat.reorder_categories([\"f\", \"r\", \"4\"])\n\n\n# facet plot with reorded drv category\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid(\"drv\", \"cyl\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can choose if the scale of x- and y-axes are fixed or variable by using the scales argument within the facet_grid() command:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid(\"drv\", scales=\"free\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can add additional information to your facet labels, by using the labeller argument within the facet_grid() command. Below we use labeller = 'label_both' to include the column name in the facet label.\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid(\"drv\", labeller=\"label_both\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can add two discrete variables to a facet:\n\n# add additional column for plotting exercise\nmpg[\"transmission\"] = mpg[\"trans\"].map(\n    lambda x: \"auto\" if \"auto\" in x else \"man\" if \"man\" in x else \"\"\n)\n\n\n# inspect new column transmission which identifies cars as having an automatic or manual transmission\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\ntransmission\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\nauto\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\nman\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\nman\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\nauto\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\nauto\n\n\n\n\n\n\n\n\n# facet plot with two variables on one facet\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid([\"drv\", \"transmission\"])  # use a list to add additional faceting variables\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nFacet labels can be rotated to make them easier to read using strip_text_y = element_text(angle = 0) for row labels within the theme() command (use strip_text_x = element_text(angle = 0) for column labels).\nIf the labels do not fit in the strip, adjust the width of the strip using strip_background_y for rows (use strip_background_x for columns). You may also need to adjust the text position so it fits in the strip: adjust the horizontal text position in the strip by specifying ha in element_text()(specify va in element_text() to adjust the vertical text position).\nYou can also change the colour of the strip by specifying color in element_text() .\n\n(\n    ggplot(mpg, aes(x=\"drv\", y=\"model\"))\n    + geom_point()\n    + facet_grid(\"manufacturer\", scales=\"free\")\n    + theme(\n        strip_text_y=element_text(angle=0),   # change facet text angle\n        strip_background_y=element_rect(fill=\"#969dff\"),   # change background colour of facet background\n        figure_size=(6, 15),  # adjust width & height of figure to fit y-axis\n    )\n    + labs(x=\"displacement\", y=\"\")\n)"
  },
  {
    "objectID": "reference/examples/after_scale.html",
    "href": "reference/examples/after_scale.html",
    "title": "after_scale",
    "section": "",
    "text": "import pandas as pd\n\nfrom plotnine import ggplot, aes, after_scale, geom_bar, theme_classic\n\nThe bars in geom_bar have two aesthetics that control the coloring; fill for the interior and color for the boundary/edge. Using after_scale we can create a matching combination of these two.\nStart off with a mapping to the color.\n\ndf = pd.DataFrame({\"var1\": [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]})\n\n(\n    ggplot(df, aes(\"var1\", color=\"factor(var1)\"))\n    + geom_bar(size=1)\n)\n\n\n\n\n\n\n\n\nWe can match the color with the fill.\n\n(\n    ggplot(df, aes(\"var1\", color=\"factor(var1)\"))\n    + geom_bar(aes(fill=after_scale(\"color\")), size=1)\n)\n\n\n\n\n\n\n\n\nAs after_scale takes an expression, for the fill aesthetic we can modify the color by adding to it an alpha channel i.e. '#AABBCC' to '#AABBCC66'.\n\n(\n    ggplot(df, aes(\"var1\", color=\"factor(var1)\"))\n    + geom_bar(aes(fill=after_scale('color + \"66\"')), size=1)\n)\n\n\n\n\n\n\n\n\nWe rely on the fact that you can append a string to all elements of a pandas series\npd.Series(['#AABBCC', '#112233']) + '66' == pd.Series(['#AABBCC66', '#11223366'])\nWith a fitting theme.\n\n(\n    ggplot(df, aes(\"var1\", color=\"factor(var1)\"))\n    + geom_bar(aes(fill=after_scale('color + \"66\"')), size=1)\n    + theme_classic()\n)"
  },
  {
    "objectID": "reference/examples/PlotnineAnimation.html",
    "href": "reference/examples/PlotnineAnimation.html",
    "title": "Spiral Animation ###",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nfrom plotnine import ggplot, aes, geom_path, theme, theme_void, lims\nfrom plotnine.animation import PlotnineAnimation\n\n# for animation in the notebook\nfrom matplotlib import rc\n\nrc(\"animation\", html=\"html5\")\n\nHow to create Animations\nThe PlotnineAnimation methods takes a sequence of plots and animates them. The best way to create the sequence is to use a function that generates plots.\nNOTE: When creating the plots make sure all the plots have scales with the same limits for each aesthetic, including the x and y aesthetics.\n\n# Parameters used to control the spiral\nn = 100\ntightness = 1.3\nkmin = 1\nkmax = 25\nnum_frames = 25\ntheta = np.linspace(-np.pi, np.pi, n)\n\n\ndef plot(k):\n    # For every plot we change the theta\n    _theta = theta * k\n\n    # Polar Equation of each spiral\n    r = tightness * _theta\n\n    df = pd.DataFrame({\n        \"theta\": _theta,\n        \"r\": r,\n        \"x\": r * np.sin(_theta),\n        \"y\": r * np.cos(_theta)\n    })\n\n    p = (\n        ggplot(df)\n        + geom_path(aes(\"x\", \"y\", color=\"theta\"), size=1)\n        + lims(\n            # All the plots have scales with the same limits\n            x=(-130, 130),\n            y=(-130, 130),\n            color=(-kmax * np.pi, kmax * np.pi),\n        )\n        + theme_void()\n        + theme(aspect_ratio=1)\n    )\n    return p\n\n\n# It is better to use a generator instead of a list\nplots = (plot(k) for k in np.linspace(kmin, kmax, num_frames))\nani = PlotnineAnimation(plots, interval=100, repeat_delay=500)\n# ani.save('/tmp/animation.mp4')\nani\n\n\n  \n  Your browser does not support the video tag.\n\n\n\nThe final image of the spiral\n\n# Gallery Plot\n\nplot(kmax)"
  },
  {
    "objectID": "gallery/dev/theme_bw.html",
    "href": "gallery/dev/theme_bw.html",
    "title": "Black & White",
    "section": "",
    "text": "from plotnine import ggplot, geom_point, aes, labs, theme_bw\nfrom plotnine.data import mtcars\n\n\n# Gallery, themes\n(\n    ggplot(mtcars, aes(x=\"wt\", y=\"mpg\", colour=\"factor(gear)\"))\n    + geom_point()\n    + labs(\n        title= \"Fuel economy declines as weight increases\",\n        subtitle=\"(1973-74)\",\n        caption=\"Data from the 1974 Motor Trend US magazine.\",\n        x=\"Weight (1000 lbs)\",\n        y=\"Fuel economy (mpg)\",\n        colour=\"Gears\"\n    )\n    + theme_bw()\n)"
  },
  {
    "objectID": "gallery/dev/stage.html",
    "href": "gallery/dev/stage.html",
    "title": "stage",
    "section": "",
    "text": "%load_ext autoreload\n%autoreload 2\n%aimport plotnine\n\nimport pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    after_stat,\n    stage,\n    geom_bar,\n    geom_text,\n    geom_bin_2d,\n    stat_bin_2d,\n)\ndf = pd.DataFrame({\n    \"var1\": list(\"abbcccddddeeeee\"),\n    \"cat\": list(\"RSRSRSRRRSRSSRS\")\n})\n\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar()\n)\nAdd the corresponding count on top of each bar.\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar()\n    + geom_text(aes(label=after_stat(\"count\")), stat=\"count\")\n)\nAdjust the y position so that the counts do not overlap the bars.\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"count\"), y=stage(after_stat=\"count\", after_scale=\"y+.1\")),\n        stat=\"count\",\n    )\n)\nNote that this will work even nicely for stacked bars where adjustig the position with nudge_y=0.1 would not.\n(\n    ggplot(df, aes(\"var1\", fill=\"cat\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"count\"), y=stage(after_stat=\"count\", after_scale=\"y+.1\")),\n        stat=\"count\",\n        position=\"stack\",\n    )\n)"
  },
  {
    "objectID": "gallery/dev/stage.html#create-a-binned-2d-plot-with-counts",
    "href": "gallery/dev/stage.html#create-a-binned-2d-plot-with-counts",
    "title": "stage",
    "section": "Create a binned 2d plot with counts",
    "text": "Create a binned 2d plot with counts\n\nnp.random.seed(123)\ndf = pd.DataFrame({\n    \"col_1\": np.random.rand(1000),\n    \"col_2\": np.random.rand(1000)\n})\n\n\n(\n    ggplot(df, aes(x=\"col_1\", y=\"col_2\"))\n    + geom_bin_2d(position=\"identity\", binwidth=0.1)\n)\n\n\n\n\n\n\n\n\nAdd counts to the bins. stat_bin_2d bins are specified using retangular minimum and maximum end-points for dimension; we use these values to compute the mid-points at which to place the counts.\nFirst x and y aesthetics are mapped to col_1 and col_2 variables, then after the statistic consumes them and creates xmin, xmax, ymin & ymax values for each bin along with associated count. After the statistic computation the x and y aesthetics do not exist, but we create meaningful values using the minimum and maximum end-points.\nNote that the binning parameters for the geom and stat combination must be the same. In this case it is the binwidth.\n\n(\n    ggplot(df, aes(x=\"col_1\", y=\"col_2\"))\n    + geom_bin_2d(position=\"identity\", binwidth=0.1)\n    + stat_bin_2d(\n        aes(\n            x=stage(start=\"col_1\", after_stat=\"(xmin+xmax)/2\"),\n            y=stage(start=\"col_2\", after_stat=\"(ymin+ymax)/2\"),\n            label=after_stat(\"count\"),\n        ),\n        binwidth=0.1,\n        geom=\"text\",\n        format_string=\"{:.0f}\",\n        size=10,\n    )\n)"
  },
  {
    "objectID": "gallery/dev/scale_shape_identity.html",
    "href": "gallery/dev/scale_shape_identity.html",
    "title": "Scatter Plot Shapes",
    "section": "",
    "text": "from plotnine import (\n    aes,\n    annotate,\n    coord_equal,\n    element_rect,\n    element_text,\n    facet_wrap,\n    geom_point,\n    geom_segment,\n    geom_text,\n    geom_tile,\n    ggplot,\n    lims,\n    scale_shape_identity,\n    theme,\n    theme_void,\n)\n\nimport polars as pl\nimport numpy as np\n\nList the shapes and prepare dataframe with what is required to display them.\n\nfilled_shapes = (\n    \"o\",  # circle\n    \"^\",  # triangle up\n    \"s\",  # square\n    \"D\",  # Diamond\n    \"v\",  # triangle down\n    \"*\",  # star\n    \"p\",  # pentagon\n    \"8\",  # octagon\n    \"&lt;\",  # triangle left\n    \"h\",  # hexagon1\n    \"&gt;\",  # triangle right\n    \"H\",  # hexagon1\n    \"d\",  # thin diamond\n)\n\nunfilled_shapes = (\n    \"+\",  # plus\n    \"x\",  # x\n    \".\",  # point\n    \"1\",  # tri_down\n    \"2\",  # tri_up\n    \"3\",  # tri_left\n    \"4\",  # tri_right\n    \",\",  # pixel\n    \"_\",  # hline\n    \"|\",  # vline\n    0,  # tickleft\n    1,  # tickright\n    2,  # tickup\n    3,  # tickdown\n    4,  # caretleft\n    5,  # caretright\n    6,  # caretup\n    7,  # caretdown\n)\n\nn1 = len(filled_shapes)\nn2 = len(unfilled_shapes)\nncols = 10\nshapes = filled_shapes + unfilled_shapes\n\ndf = pl.DataFrame({\n    \"x\": np.hstack([np.arange(n1) % ncols, np.arange(n2) % ncols]),\n    \"y\": 4 - 1.5 * np.hstack([np.arange(n1) // ncols, np.arange(n2) // ncols]),\n    \"shape\": pl.Series(shapes, dtype=object),\n    \"shape_kind\": np.repeat([\"Filled Shapes\", \"Unfilled Shapes\"], (n1, n2))\n})\n\ndf\n\n\nshape: (31, 4)\n\n\n\nx\ny\nshape\nshape_kind\n\n\ni64\nf64\nobject\nstr\n\n\n\n\n0\n4.0\no\n\"Filled Shapes\"\n\n\n1\n4.0\n^\n\"Filled Shapes\"\n\n\n2\n4.0\ns\n\"Filled Shapes\"\n\n\n3\n4.0\nD\n\"Filled Shapes\"\n\n\n4\n4.0\nv\n\"Filled Shapes\"\n\n\n…\n…\n…\n…\n\n\n3\n2.5\n3\n\"Unfilled Shapes\"\n\n\n4\n2.5\n4\n\"Unfilled Shapes\"\n\n\n5\n2.5\n5\n\"Unfilled Shapes\"\n\n\n6\n2.5\n6\n\"Unfilled Shapes\"\n\n\n7\n2.5\n7\n\"Unfilled Shapes\"\n\n\n\n\n\n\n\n# Gallery, points\n\ndef double_quote_strings(series):\n    return [\n        '\"{}\"'.format(s) if isinstance(s, str) else \"{}\".format(s)\n        for s in series\n    ]\n\n(\n    ggplot(df, aes(\"x\", \"y\"))\n    \n    # Background\n    + geom_tile(aes(width=0.9, height=0.9), fill=\"#F8F8F8\")\n    \n    # Cross-grid to help see the centering of the shapes\n    + geom_segment(aes(x=\"x-0.45\", xend=\"x+0.45\", yend=\"y\"), color=\"Crimson\", alpha=0.05)\n    + geom_segment(aes(xend=\"x\", y=\"y-0.45\", yend=\"y+0.45\"), color=\"Crimson\", alpha=0.05)\n    \n    # The shape\n    + geom_point(aes(shape=\"shape\"), fill=\"#E5C8D6\", size=8)\n\n    # Specification value for the shape\n    + geom_text(\n        aes(y=\"y+.5\", label=\"double_quote_strings(shape)\"),\n        color=\"darkblue\",\n        va=\"bottom\",\n    )\n\n    # Separate the shapes by their kind\n    + facet_wrap(\"shape_kind\", ncol=1)\n\n    # Make things pretty\n    + lims(y=(2, 5))\n    + scale_shape_identity()\n    + coord_equal()\n    + theme_void()\n    + theme(\n        plot_background=element_rect(fill=\"white\"),\n        strip_text=element_text(size=12)\n    )\n)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nFile ~/.uvenv/plotnine/lib/python3.13/site-packages/IPython/core/formatters.py:984, in IPythonDisplayFormatter.__call__(self, obj)\n    982 method = get_real_method(obj, self.print_method)\n    983 if method is not None:\n--&gt; 984     method()\n    985     return True\n\nFile ~/scm/python/plotnine/plotnine/ggplot.py:149, in ggplot._ipython_display_(self)\n    142 def _ipython_display_(self):\n    143     \"\"\"\n    144     Display plot in the output of the cell\n    145 \n    146     This method will always be called when a ggplot object is the\n    147     last in the cell.\n    148     \"\"\"\n--&gt; 149     self._display()\n\nFile ~/scm/python/plotnine/plotnine/ggplot.py:190, in ggplot._display(self)\n    187     self.theme = self.theme.to_retina()\n    189 buf = BytesIO()\n--&gt; 190 self.save(buf, \"png\" if format == \"retina\" else format, verbose=False)\n    191 figure_size_px = self.theme._figure_size_px\n    192 display_func = get_display_function(format, figure_size_px)\n\nFile ~/scm/python/plotnine/plotnine/ggplot.py:702, in ggplot.save(self, filename, format, path, width, height, units, dpi, limitsize, verbose, **kwargs)\n    653 def save(\n    654     self,\n    655     filename: Optional[str | Path | BytesIO] = None,\n   (...)    664     **kwargs: Any,\n    665 ):\n    666     \"\"\"\n    667     Save a ggplot object as an image file\n    668 \n   (...)    700         Additional arguments to pass to matplotlib `savefig()`.\n    701     \"\"\"\n--&gt; 702     sv = self.save_helper(\n    703         filename=filename,\n    704         format=format,\n    705         path=path,\n    706         width=width,\n    707         height=height,\n    708         units=units,\n    709         dpi=dpi,\n    710         limitsize=limitsize,\n    711         verbose=verbose,\n    712         **kwargs,\n    713     )\n    715     with plot_context(self).rc_context:\n    716         sv.figure.savefig(**sv.kwargs)\n\nFile ~/scm/python/plotnine/plotnine/ggplot.py:650, in ggplot.save_helper(self, filename, format, path, width, height, units, dpi, limitsize, verbose, **kwargs)\n    647 if dpi is not None:\n    648     self.theme = self.theme + theme(dpi=dpi)\n--&gt; 650 figure = self.draw(show=False)\n    651 return mpl_save_view(figure, fig_kwargs)\n\nFile ~/scm/python/plotnine/plotnine/ggplot.py:322, in ggplot.draw(self, show)\n    319     self._create_figure()\n    320 figure = self.figure\n--&gt; 322 self._build()\n    324 # setup\n    325 self.axs = self.facet.setup(self)\n\nFile ~/scm/python/plotnine/plotnine/ggplot.py:419, in ggplot._build(self)\n    417 npscales = scales.non_position_scales()\n    418 if len(npscales):\n--&gt; 419     layers.train(npscales)\n    420     layers.map(npscales)\n    422 # Train coordinate system\n\nFile ~/scm/python/plotnine/plotnine/layer.py:492, in Layers.train(self, scales)\n    490 def train(self, scales: Scales):\n    491     for l in self:\n--&gt; 492         scales.train_df(l.data)\n\nFile ~/scm/python/plotnine/plotnine/scales/scales.py:203, in Scales.train_df(self, data, drop)\n    201 # Each scale trains the columns it understands\n    202 for sc in self:\n--&gt; 203     sc.train_df(data)\n\nFile ~/scm/python/plotnine/plotnine/scales/scale.py:284, in scale.train_df(self, df)\n    282 aesthetics = sorted(set(self.aesthetics) & set(df.columns))\n    283 for ae in aesthetics:\n--&gt; 284     self.train(df[ae])\n\nFile ~/scm/python/plotnine/plotnine/scales/scale_identity.py:36, in MapTrainMixin.train(self, x, drop)\n     33 if self.guide is None:  # pyright: ignore\n     34     return\n---&gt; 36 return super().train(x)\n\nFile ~/scm/python/plotnine/plotnine/scales/scale_discrete.py:107, in scale_discrete.train(self, x, drop)\n    104     return\n    106 na_rm = not self.na_translate\n--&gt; 107 self._range.train(x, drop, na_rm=na_rm)\n\nFile ~/scm/python/plotnine/plotnine/scales/range.py:67, in RangeDiscrete.train(self, x, drop, na_rm)\n     63 \"\"\"\n     64 Train discrete range\n     65 \"\"\"\n     66 rng = None if self.is_empty() else self.range\n---&gt; 67 self.range = scale_discrete.train(x, rng, drop, na_rm=na_rm)\n\nFile ~/.uvenv/plotnine/lib/python3.13/site-packages/mizani/scale.py:269, in scale_discrete.train(cls, new_data, old, drop, na_rm)\n    267     limits = [c for c in ordered_cats if c in all_set]\n    268 else:\n--&gt; 269     new = np.unique(new_data)\n    270     new.sort()\n    272     limits = old + [i for i in new if (i not in old_set)]\n\nFile ~/.uvenv/plotnine/lib/python3.13/site-packages/numpy/lib/_arraysetops_impl.py:286, in unique(ar, return_index, return_inverse, return_counts, axis, equal_nan)\n    284 ar = np.asanyarray(ar)\n    285 if axis is None:\n--&gt; 286     ret = _unique1d(ar, return_index, return_inverse, return_counts,\n    287                     equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)\n    288     return _unpack_tuple(ret)\n    290 # axis was specified and not None\n\nFile ~/.uvenv/plotnine/lib/python3.13/site-packages/numpy/lib/_arraysetops_impl.py:353, in _unique1d(ar, return_index, return_inverse, return_counts, equal_nan, inverse_shape, axis)\n    351     aux = ar[perm]\n    352 else:\n--&gt; 353     ar.sort()\n    354     aux = ar\n    355 mask = np.empty(aux.shape, dtype=np.bool)\n\nTypeError: '&lt;' not supported between instances of 'int' and 'str'\n\n\n\n&lt;plotnine.ggplot.ggplot at 0x10acd1220&gt;"
  },
  {
    "objectID": "gallery/dev/reorder.html",
    "href": "gallery/dev/reorder.html",
    "title": "plotnine {{< var version >}}",
    "section": "",
    "text": "import pandas as pd\nfrom plotnine import ggplot, aes, geom_col\n\ndf = pd.DataFrame({\n    \"x\": [\"b\", \"d\", \"c\", \"a\"],\n    \"y\": [1, 2, 3, 4]\n})\n\nggplot(df, aes(\"reorder(x, y)\", \"y\")) + geom_col()"
  },
  {
    "objectID": "gallery/dev/geom_vline.html",
    "href": "gallery/dev/geom_vline.html",
    "title": "Vertical line",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    geom_vline,\n    facet_grid,\n    labs,\n    element_rect,\n    theme,\n    theme_matplotlib,\n    theme_set,\n)\nfrom plotnine.data import mpg\n\n# Set default theme\n# matplotlib + the background of 538\ntheme_set(\n    theme_matplotlib()\n    + theme(\n        plot_background=element_rect(fill=\"#F0F0F0\"),\n        panel_background=element_rect(fill=\"#F0F0F0\"),\n        panel_spacing=0.015,\n        \n    )\n)\n\ngeom_vline() draws a vertical line, and is useful as a guide.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nIt’s useful to use geom_vline() with some data, so we start with a basic scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nAdd a vertical line to the scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_vline(xintercept=5)  # add one vertical line\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can add many vertical lines:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_vline(xintercept=[4, 5, 7])  # add many vertical lines using a list\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_vline(\n        xintercept=[4, 5, 7],\n        colour=[\"red\", \"orange\", \"green\"],  # add colour\n        size=[1, 2, 3],  # set line thickness\n        linetype=\"dotted\",  # set line type\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nAdd vertical lines to a facet plot:\n\nFacets with a Vertical Line\n\n# Gallery, lines\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_vline(xintercept=5, color=\"brown\", size=1)  # add a vertical line...\n    + facet_grid(\"drv\")  # ... to a facet plot\n    + labs(x=\"displacement\", y=\"horsepower\")\n)"
  },
  {
    "objectID": "gallery/dev/geom_tile.html",
    "href": "gallery/dev/geom_tile.html",
    "title": "Periodic Table",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_tile,\n    geom_text,\n    scale_y_reverse,\n    scale_y_discrete,\n    scale_fill_brewer,\n    scale_color_manual,\n    coord_equal,\n    theme,\n    theme_void,\n    element_blank,\n    element_rect,\n    element_text,\n)\n\nGraphing of highly organised tabular information\nRead the data.\n\nelements = pd.read_csv(\"data/elements.csv\")\nelements.head()\n\n\n\n\n\n\n\n\natomic number\nsymbol\nname\natomic mass\nCPK\nelectronic configuration\nelectronegativity\natomic radius\nion radius\nvan der Waals radius\n...\nEA\nstandard state\nbonding type\nmelting point\nboiling point\ndensity\nmetal\nyear discovered\ngroup\nperiod\n\n\n\n\n0\n1\nH\nHydrogen\n1.00794\n#FFFFFF\n1s1\n2.20\n37.0\nNaN\n120.0\n...\n-73.0\ngas\ndiatomic\n14.0\n20.0\n0.00009\nnonmetal\n1766\n1\n1\n\n\n1\n2\nHe\nHelium\n4.002602\n#D9FFFF\n1s2\nNaN\n32.0\nNaN\n140.0\n...\n0.0\ngas\natomic\nNaN\n4.0\n0.00000\nnoble gas\n1868\n18\n1\n\n\n2\n3\nLi\nLithium\n6.941\n#CC80FF\n[He] 2s1\n0.98\n134.0\n76 (+1)\n182.0\n...\n-60.0\nsolid\nmetallic\n454.0\n1615.0\n0.54000\nalkali metal\n1817\n1\n2\n\n\n3\n4\nBe\nBeryllium\n9.012182\n#C2FF00\n[He] 2s2\n1.57\n90.0\n45 (+2)\nNaN\n...\n0.0\nsolid\nmetallic\n1560.0\n2743.0\n1.85000\nalkaline earth metal\n1798\n2\n2\n\n\n4\n5\nB\nBoron\n10.811\n#FFB5B5\n[He] 2s2 2p1\n2.04\n82.0\n27 (+3)\nNaN\n...\n-27.0\nsolid\ncovalent network\n2348.0\n4273.0\n2.46000\nmetalloid\n1807\n13\n2\n\n\n\n\n5 rows × 21 columns\n\n\n\nAlter the data types of the information that will be plotted. This makes it convenient to work with.\n\nelements[\"group\"] = [-1 if g == \"-\" else int(g) for g in elements.group]\nelements[\"bonding type\"] = elements[\"bonding type\"].astype(\"category\")\nelements[\"metal\"] = elements[\"metal\"].astype(\"category\")\nelements[\"atomic_number\"] = elements[\"atomic number\"].astype(str)\n\nThe periodic table has two tables, a top and bottom. The elements in the top have groups, and those in the bottom have no groups. We make separate dataframes for both – they have different alignments.\n\ntop = elements.query(\"group != -1\").copy()\nbottom = elements.query(\"group == -1\").copy()\n\nThe top table is nice and well behaving. The x location of the elements indicate the group and the y locations the period.\n\ntop[\"x\"] = top.group\ntop[\"y\"] = top.period\n\nThe bottom table has 2 rows, with the atomic number increasing to the right. We create an x based on the atomic number and add a horizontal shift. As the dataframe is ordered by atomic number, the operation is easier. The bottom elements are labelled with a “period”. We add a vertical shift to give us a good y location that gives the appearance of two tables.\n\nnrows = 2\nhshift = 3.5\nvshift = 3\nbottom[\"x\"] = np.tile(np.arange(len(bottom) // nrows), nrows) + hshift\nbottom[\"y\"] = bottom.period + vshift\n\nWe will be plotting using tiles and we want to have some space between the tiles. We have set the x and y locations above to take up a unit of space. To get a good effect, the tile dimensions should be less than 1.\n\ntile_width = 0.95\ntile_height = 0.95\n\nFirst peak\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n)\n\n\n\n\n\n\n\n\nThe table upside down. We could have been more careful when creating the y locations since the periods are drawn in descending order. But, we can fix that with a reverse scale.\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + scale_y_reverse()  # new\n)\n\n\n\n\n\n\n\n\nLet us apply some color to it.\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")  # new\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + scale_y_reverse()\n)\n\n\n\n\n\n\n\n\n\nNow for some trick\nGoal: To add text to the tiles\nThere are four pieces of text that we shall add to the tiles, that is 4 geom_text additions. As we have two tables, that comes to 8 geom_text additions. When any geom is added to a ggplot object, behind the scenes a layer is created and added. We can create a group of layers that can be added to a ggplot object in one go using a list.\nWe use a function that accepts a dataframe, and returns a list of geoms.\n\ndef inner_text(data):\n    layers = [\n        geom_text(\n            data,\n            aes(label=\"atomic_number\"),\n            nudge_x=-0.40,\n            nudge_y=0.40,\n            ha=\"left\",\n            va=\"top\",\n            fontweight=\"normal\",\n            size=6,\n        ),\n        geom_text(data, aes(label=\"symbol\"), nudge_y=0.1, size=9),\n        geom_text(\n            data, aes(label=\"name\"), nudge_y=-0.125, fontweight=\"normal\", size=4.5\n        ),\n        geom_text(\n            data, aes(label=\"atomic mass\"), nudge_y=-0.3, fontweight=\"normal\", size=4.5\n        ),\n    ]\n    return layers\n\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)  # new\n    + inner_text(bottom)  # new\n    + scale_y_reverse()\n)\n\n\n\n\n\n\n\n\nIt is crowded in there and the tiles do not have equal dimentions. Use the theme create a larger figure. coord_equal give us equal units along the axes, this makes the tiles square.\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)\n    + inner_text(bottom)\n    + scale_y_reverse()\n    + coord_equal(expand=False)  # new\n    + theme(figure_size=(12, 6))  # new\n)\n\n\n\n\n\n\n\n\nIt is has all the information we want, except one for complication. Elements Lu and Lr also belong in the bottom table. One way to show this duality is to have tiles with two colors split horizontally.\nThe colors are determined by the metal field, and we know the x and y locations. We create a dataframe with this information to create a half-tile. A half-tile is centered at the quarter mark.\n\nsplit_df = pd.DataFrame(\n    {\n        \"x\": 3 - tile_width / 4,\n        \"y\": [6, 7],\n        \"metal\": pd.Categorical([\"lanthanoid\", \"actinoid\"]),\n    }\n)\n\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(split_df, aes(width=tile_width / 2, height=tile_height))  # new\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)\n    + inner_text(bottom)\n    + scale_y_reverse()\n    + coord_equal(expand=False)\n    + theme(figure_size=(12, 6))\n)\n\n\n\n\n\n\n\n\nChange the fill color for a different look and use a theme that clears out all the clutter.\n\nfrom plotnine import guides\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(split_df, aes(width=tile_width / 2, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)\n    + inner_text(bottom)\n    + scale_y_reverse()\n    + scale_fill_brewer(type=\"qual\", palette=3)  # new\n    + coord_equal(expand=False)\n    + theme_void()  # new\n    + theme(\n        figure_size=(12, 6),\n        plot_margin_left=0.01,\n        plot_margin_right=0.01,\n        plot_background=element_rect(fill=\"white\"),\n    )  # new\n)\n\n\n\n\n\n\n\n\nAdd the group number along the top most row of each column, and period number along the left side of the top table.\nFor the period number, we set the breaks on the y scale.\n\n# The location of the group number is the top most (and therefore smallest period)\n# element with the group\ngroupdf = top.groupby(\"group\").agg(y=(\"period\", \"min\")).reset_index()\n\nFinally,\n\n# Gallery, tiles\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(split_df, aes(width=tile_width / 2, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)\n    + inner_text(bottom)\n    + geom_text(\n        groupdf,\n        aes(\"group\", \"y\", label=\"group\"),\n        color=\"gray\",\n        nudge_y=0.525,\n        va=\"bottom\",\n        fontweight=\"normal\",\n        size=9,\n        inherit_aes=False,\n    )  # new\n    + scale_y_reverse(breaks=range(1, 8), limits=(0, 10.5))  # modified\n    + scale_fill_brewer(type=\"qual\", palette=3)\n    + coord_equal(expand=False)\n    + theme_void()\n    + theme(\n        figure_size=(12, 6),\n        plot_margin_left=0.01,\n        plot_margin_right=0.01,\n        plot_background=element_rect(fill=\"white\"),\n        axis_text_y=element_text(margin={\"r\": 5}, color=\"gray\", size=9),  # new\n    )\n)\n\n\n\n\n\n\n\n\nWhat we could have done different:\n\nAfter we set the x and y positions in th the top and bottom dataframes, we could have concatenated them back together. Then, that Layers trick would not save us much.\n\nPro tip: Save the plot as a pdf.\n\n\nAnnotated Heatmap\nConditinous data recorded at discrete time intervals over many cycles\nRead data\n\nflights = pd.read_csv(\"data/flights.csv\")\nmonths = flights[\"month\"].unique()  # Months ordered January, ..., December\nflights[\"month\"] = pd.Categorical(flights[\"month\"], categories=months)\nflights.head()\n\n\n\n\n\n\n\n\nyear\nmonth\npassengers\n\n\n\n\n0\n1949\nJanuary\n112\n\n\n1\n1949\nFebruary\n118\n\n\n2\n1949\nMarch\n132\n\n\n3\n1949\nApril\n129\n\n\n4\n1949\nMay\n121\n\n\n\n\n\n\n\n\n# We use 'factor(year)' -- a discrete -- instead of 'year' so that all the years\n# are displayed along the x-axis.\n# The .95s create spacing between the tiles.\n\n(\n    ggplot(flights, aes(\"factor(year)\", \"month\", fill=\"passengers\"))\n    + geom_tile(aes(width=0.95, height=0.95))\n    + geom_text(aes(label=\"passengers\"), size=9)\n)\n\n\n\n\n\n\n\n\nThat looks like what we want, but it could do with a few tweaks. First the contrast between the tiles and the text is not good for the lower passenger numbers. We use pd.cut to partition the number of passengers into two discrete groups.\n\nflights[\"p_group\"] = pd.cut(\n    flights[\"passengers\"], (0, 300, 1000), labels=(\"low\", \"high\")\n)\nflights.head()\n\n\n\n\n\n\n\n\nyear\nmonth\npassengers\np_group\n\n\n\n\n0\n1949\nJanuary\n112\nlow\n\n\n1\n1949\nFebruary\n118\nlow\n\n\n2\n1949\nMarch\n132\nlow\n\n\n3\n1949\nApril\n129\nlow\n\n\n4\n1949\nMay\n121\nlow\n\n\n\n\n\n\n\n\n(\n    ggplot(flights, aes(\"factor(year)\", \"month\", fill=\"passengers\"))\n    + geom_tile(aes(width=0.95, height=0.95))\n    + geom_text(aes(label=\"passengers\", color=\"p_group\"), size=9, show_legend=False)  # modified\n    + scale_color_manual([\"white\", \"black\"])  # new\n)\n\n\n\n\n\n\n\n\nLast tweaks, put January at the top and remove the axis ticks and plot background.\n\n# Gallery, tiles\n\n(\n    ggplot(flights, aes(\"factor(year)\", \"month\", fill=\"passengers\"))\n    + geom_tile(aes(width=0.95, height=0.95))\n    + geom_text(aes(label=\"passengers\", color=\"p_group\"), size=9, show_legend=False)\n    + scale_color_manual([\"white\", \"black\"])  # new\n    + scale_y_discrete(limits=months[::-1])  # new\n    + theme(  # new\n        axis_ticks=element_blank(),\n        panel_background=element_rect(fill=\"white\"),\n    )\n)\n\n\n\n\n\n\n\n\nYou can get similar results if you replace\n + geom_tile(aes(width=.95, height=.95))\n + geom_text(aes(label='passengers', color='p_group'), size=9, show_legend=False)\nwith\n+ geom_label(aes(label='passengers', color='p_group'), size=9, show_legend=False)\nCredit: This example is a recreation of this seaborn example."
  },
  {
    "objectID": "gallery/dev/geom_smooth.html",
    "href": "gallery/dev/geom_smooth.html",
    "title": "Smoothed conditional means",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_point, geom_smooth, labs, theme_matplotlib, theme_set\nfrom plotnine.data import mpg\n\ntheme_set(theme_matplotlib())\n\nAids the eye in seeing patterns in the presence of overplotting.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_smooth()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nUse span to control the “wiggliness” of the default loess smoother. The span is the fraction of points used to fit each local regression: small numbers make a wigglier curve, larger numbers make a smoother curve.\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_smooth(span=0.3)\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can remove confidence interval around smooth with se=False:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_smooth(span=0.3, se=False)\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nInstead of a loess smooth, you can use any other modelling function:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_smooth(method=\"lm\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\n\nPoints & Linear Models\n\n# Gallery, points\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\", color=\"factor(drv)\"))\n    + geom_point()\n    + geom_smooth(method=\"lm\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)"
  },
  {
    "objectID": "gallery/dev/geom_point.html",
    "href": "gallery/dev/geom_point.html",
    "title": "Basic Scatter Plot",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    theme_matplotlib,\n    theme_set,\n)\n\n# Set default theme for all the plots\ntheme_set(theme_matplotlib())\n\n\nnp.random.seed(123)\nn = 150\n\ndf = pd.DataFrame({\n    \"x\": np.random.randint(0, 101, n),\n    \"y\": np.random.randint(0, 101, n),\n    \"var1\": np.random.randint(1, 6, n),\n    \"var2\": np.random.randint(0, 11, n)\n})\n\n\n# Gallery, points\n(\n    ggplot(df, aes(\"x\", \"y\"))\n    + geom_point()\n)\n\n\n\n\n\n\n\n\n\nColoured Point Bubbles\n\n(\n    ggplot(df, aes(\"x\", \"y\", size=\"var1\"))\n    + geom_point(aes(color=\"var2\"))\n)\n\n\n\n\n\n\n\n\n\n# Gallery, points\n(\n    ggplot(df, aes(\"x\", \"y\", size=\"var1\"))\n    + geom_point(aes(fill=\"var2\"), stroke=0, alpha=0.5)\n    + geom_point(aes(color=\"var2\"), fill=\"none\")\n)"
  },
  {
    "objectID": "gallery/dev/geom_map.html",
    "href": "gallery/dev/geom_map.html",
    "title": "plotnine {{< var version >}}",
    "section": "",
    "text": "import geopandas as gp\nimport geodatasets\nfrom plotnine import (\n    ggplot,\n    aes,\n    coord_fixed,\n    facet_wrap,\n    geom_map,\n    geom_text,\n    labs,\n    scale_fill_brewer,\n    scale_fill_continuous,\n    scale_x_continuous,\n    scale_y_continuous,\n    scale_size_continuous,\n    stage,\n    coord_cartesian,\n    element_line,\n    element_rect,\n    element_text,\n    theme_void,\n    theme,\n)\n\nDefine some useful functions\n\ndef good_centroid(geometry):\n    \"\"\"\n    Calculate \"good\" centroids for polygons in the geometry\n\n    The polygon is projected onto the Equal Area Cylindrical projection,\n    the centroids are computed, then mapped back onto the original\n    coordinate system.\n    \"\"\"\n    return geometry.to_crs(\"+proj=cea\").centroid.to_crs(geometry.crs)\n\n\ndef overlay_color(rgb_hex_colors, light=\"white\", dark=\"black\", threshold=0.5):\n    \"\"\"\n    Decide which color is suitable to write onto the given colors\n    \"\"\"\n    def luminance(rgb_hex):\n        \"\"\"\n        Calculate the Luminance ([0, 1]) of a hex color\n        \"\"\"\n        r = int(rgb_hex[1:3], 16)\n        g = int(rgb_hex[3:5], 16)\n        b = int(rgb_hex[5:], 16)\n        luma = (r*0.299 + g*0.587 + b*0.0722) / 256\n        return luma\n    return [light if luminance(x) &lt; threshold  else dark for x in rgb_hex_colors]\n\n\nA Map from geodatasets\nWe are going to use a dataset from the geodatasets package. We can explore the dataset providers at geodatasets.data, each of which has one or more datasets:\nWe choose the dataset of Sudden Infant Death (SIDS) counts from counties in North Carolina. We can see some meta information about that dataset. You can view the details with geodatasets.data.geoda.sids.\nDownload the dataset we want (it is automatically cached).\n\ngeodatasets.fetch(\"geoda sids\")\n\nRead data\n\nsids = gp.read_file(geodatasets.get_path(\"geoda.sids\"))\nsids.head()\n\n\n\n\n\n\n\n\nAREA\nPERIMETER\nCNTY_\nCNTY_ID\nNAME\nFIPS\nFIPSNO\nCRESS_ID\nBIR74\nSID74\nNWBIR74\nBIR79\nSID79\nNWBIR79\ngeometry\n\n\n\n\n0\n0.114\n1.442\n1825\n1825\nAshe\n37009\n37009\n5\n1091.0\n1.0\n10.0\n1364.0\n0.0\n19.0\nPOLYGON ((-81.47276 36.23436, -81.54084 36.272...\n\n\n1\n0.061\n1.231\n1827\n1827\nAlleghany\n37005\n37005\n3\n487.0\n0.0\n10.0\n542.0\n3.0\n12.0\nPOLYGON ((-81.23989 36.36536, -81.24069 36.379...\n\n\n2\n0.143\n1.630\n1828\n1828\nSurry\n37171\n37171\n86\n3188.0\n5.0\n208.0\n3616.0\n6.0\n260.0\nPOLYGON ((-80.45634 36.24256, -80.47639 36.254...\n\n\n3\n0.070\n2.968\n1831\n1831\nCurrituck\n37053\n37053\n27\n508.0\n1.0\n123.0\n830.0\n2.0\n145.0\nMULTIPOLYGON (((-76.00897 36.3196, -76.01735 3...\n\n\n4\n0.153\n2.206\n1832\n1832\nNorthampton\n37131\n37131\n66\n1421.0\n9.0\n1066.0\n1606.0\n3.0\n1197.0\nPOLYGON ((-77.21767 36.24098, -77.23461 36.214...\n\n\n\n\n\n\n\nThe sids data has two periods 1974 - 1978 and 1979 - 1985. For each period there is a number of births and a number of deaths. We want to visually compare the deaths per 1000 in each county for the two periods.\n\ndata = sids.copy()\n\n# Calculate the death per 1000\ndata[\"1974 - 1978\"] = (data[\"SID74\"] / data[\"BIR74\"]) * 1000\ndata[\"1979 - 1984\"] = (data[\"SID79\"] / data[\"BIR79\"]) * 1000\n\n# Calculate center coordinates for the counties\ndata[\"center_lon\"] = good_centroid(data.geometry).x\ndata[\"center_lat\"] = good_centroid(data.geometry).y\n\n# Make the data\ndata = data.melt(\n    id_vars=[\"NAME\", \"geometry\", \"center_lon\", \"center_lat\"],\n    value_vars=[\"1974 - 1978\", \"1979 - 1984\"],\n    var_name=\"period\",\n    value_name=\"deaths_per_1k\",\n).rename(\n    {\"NAME\": \"county\"},\n    axis=1\n)\n\ndata.head()\n\n\n\n\n\n\n\n\ncounty\ngeometry\ncenter_lon\ncenter_lat\nperiod\ndeaths_per_1k\n\n\n\n\n0\nAshe\nPOLYGON ((-81.47276 36.23436, -81.54084 36.272...\n-81.498245\n36.431263\n1974 - 1978\n0.916590\n\n\n1\nAlleghany\nPOLYGON ((-81.23989 36.36536, -81.24069 36.379...\n-81.125138\n36.490963\n1974 - 1978\n0.000000\n\n\n2\nSurry\nPOLYGON ((-80.45634 36.24256, -80.47639 36.254...\n-80.685736\n36.412381\n1974 - 1978\n1.568381\n\n\n3\nCurrituck\nMULTIPOLYGON (((-76.00897 36.3196, -76.01735 3...\n-76.027392\n36.407026\n1974 - 1978\n1.968504\n\n\n4\nNorthampton\nPOLYGON ((-77.21767 36.24098, -77.23461 36.214...\n-77.410484\n36.422110\n1974 - 1978\n6.333568\n\n\n\n\n\n\n\nPlot the data\n\n# Gallery, maps\n\n(\n    ggplot(data)\n    + geom_map(aes(fill=\"deaths_per_1k\"))\n    + geom_text(\n        aes(\n            \"center_lon\",\n            \"center_lat\",\n            label=\"county\",\n            color=stage(\"deaths_per_1k\", after_scale=\"overlay_color(color)\")\n        ),\n        size=6,\n        show_legend=False\n    )\n    + scale_fill_continuous(\n        name=\"Deaths Per 1000\",\n        cmap_name=\"plasma\",\n        breaks=[0, 2.5, 5, 7.5, 10],\n        labels=[\"0\", \"2.5\", \"5\", \"7.5\", \"10\"],\n        limits=[0, 10],\n    )\n    + facet_wrap(\n        \"period\",\n        ncol=1,\n        labeller=lambda s: f\"Sudden Infant Deaths in the Period {s}\"\n    )\n    + coord_fixed(expand=False)\n    + theme_void()\n    + theme(\n        figure_size=(12, 8),\n        legend_position=(0, 0),\n        legend_direction=\"horizontal\",\n        legend_title_position=\"top\",\n        plot_margin=0.01,\n        plot_background=element_rect(fill=\"white\"),\n        panel_spacing=0.025,\n        legend_frame=element_rect(color=\"black\"),\n        legend_ticks=element_line(color=\"black\"),\n        strip_text=element_text(size=12),\n    )\n)\n\n\n\n\n\n\n\n\n\n\nThe Territories of Westeros\nLayering different features on a Map\nRead data and select features in Westeros only.\n\ncontinents = gp.read_file(\"data/lands-of-ice-and-fire/continents.shp\")\nislands = gp.read_file(\"data/lands-of-ice-and-fire/islands.shp\")\nlakes = gp.read_file(\"data/lands-of-ice-and-fire/lakes.shp\")\nrivers = gp.read_file(\"data/lands-of-ice-and-fire/rivers.shp\")\npolitical = gp.read_file(\"data/lands-of-ice-and-fire/political.shp\")\nwall = gp.read_file(\"data/lands-of-ice-and-fire/wall.shp\")\nroads = gp.read_file(\"data/lands-of-ice-and-fire/roads.shp\")\nlocations = gp.read_file(\"data/lands-of-ice-and-fire/locations.shp\")\n\nwesteros = continents.query('name==\"Westeros\"')\nislands = islands.query('continent==\"Westeros\" and name!=\"Summer Islands\"')\nlakes = lakes.query('continent==\"Westeros\"')\nrivers = rivers.query('continent==\"Westeros\"')\nroads = roads.query('continent==\"Westeros\"')\n\nwg = westeros.geometry[0]\nbool_idx = [wg.contains(g) for g in locations.geometry]\nwesteros_locations = locations[bool_idx]\ncities = westeros_locations[westeros_locations[\"type\"] == \"City\"].copy()\n\nCreate map by placing the features in layers in an order that limits obstraction.\nThe GeoDataFrame.geometry.centroid property has the center coordinates of polygons, we use these to place the labels of the political regions.\n\n# Gallery, maps\n\n# colors\nwater_color = \"#a3ccff\"\nwall_color = \"white\"\nroad_color = \"brown\"\n\n\n# Create label text by merging the territory name and\n# the claimant to the territory\ndef fmt_labels(names, claimants):\n    labels = []\n    for name, claimant in zip(names, claimants):\n        if name:\n            labels.append(\"{} ({})\".format(name, claimant))\n        else:\n            labels.append(\"({})\".format(claimant))\n    return labels\n\n\ndef calculate_center(df):\n    \"\"\"\n    Calculate the centre of a geometry\n\n    This method first converts to a planar crs, gets the centroid\n    then converts back to the original crs. This gives a more\n    accurate\n    \"\"\"\n    original_crs = df.crs\n    planar_crs = \"EPSG:3857\"\n    return df[\"geometry\"].to_crs(planar_crs).centroid.to_crs(original_crs)\n\n\npolitical[\"center\"] = calculate_center(political)\ncities[\"center\"] = calculate_center(cities)\n\n(\n    ggplot()\n    + geom_map(westeros, fill=None)\n    + geom_map(islands, fill=None)\n    + geom_map(political, aes(fill=\"ClaimedBy\"), color=None, show_legend=False)\n    + geom_map(wall, color=wall_color, size=2)\n    + geom_map(lakes, fill=water_color, color=None)\n    + geom_map(rivers, aes(size=\"size\"), color=water_color, show_legend=False)\n    + geom_map(roads, aes(size=\"size\"), color=road_color, alpha=0.5, show_legend=False)\n    + geom_map(cities, size=1)\n    + geom_text(\n        political,\n        aes(\"center.x\", \"center.y\", label=\"fmt_labels(name, ClaimedBy)\"),\n        size=8,\n        fontweight=\"bold\",\n    )\n    + geom_text(\n        cities,\n        aes(\"center.x\", \"center.y\", label=\"name\"),\n        size=8,\n        ha=\"left\",\n        nudge_x=0.20,\n    )\n    + labs(title=\"The Political Territories of Westeros\")\n    + scale_fill_brewer(type=\"qual\", palette=8)\n    + scale_x_continuous(expand=(0, 0, 0, 1))\n    + scale_y_continuous(expand=(0, 1, 0, 0))\n    + scale_size_continuous(range=(0.4, 1))\n    + coord_cartesian()\n    + theme_void()\n    + theme(figure_size=(8, 12), panel_background=element_rect(fill=water_color))\n)\n\n\n\n\n\n\n\n\nCredit: cadaei of the cartographersguild website forum."
  },
  {
    "objectID": "gallery/dev/geom_line.html",
    "href": "gallery/dev/geom_line.html",
    "title": "Line plots",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    geom_line,\n    facet_wrap,\n    labs,\n    scale_x_datetime,\n    element_text,\n    theme_538\n)\nfrom plotnine.data import meat\n\ngeom_line() connects the dots, and is useful for time series data.\n\nmeat.head()\n\n\n\n\n\n\n\n\ndate\nbeef\nveal\npork\nlamb_and_mutton\nbroilers\nother_chicken\nturkey\n\n\n\n\n0\n1944-01-01\n751.0\n85.0\n1280.0\n89.0\nNaN\nNaN\nNaN\n\n\n1\n1944-02-01\n713.0\n77.0\n1169.0\n72.0\nNaN\nNaN\nNaN\n\n\n2\n1944-03-01\n741.0\n90.0\n1128.0\n75.0\nNaN\nNaN\nNaN\n\n\n3\n1944-04-01\n650.0\n89.0\n978.0\n66.0\nNaN\nNaN\nNaN\n\n\n4\n1944-05-01\n681.0\n106.0\n1029.0\n78.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\nMake it tidy.\n\nmeat_long = meat.melt(\n    id_vars=\"date\",\n    value_vars=[\"beef\", \"veal\", \"pork\", \"lamb_and_mutton\", \"broilers\", \"turkey\"],\n    var_name=\"animal\",\n    value_name=\"weight\"\n).dropna()\n\nmeat_long.head()\n\n\n\n\n\n\n\n\ndate\nanimal\nweight\n\n\n\n\n0\n1944-01-01\nbeef\n751.0\n\n\n1\n1944-02-01\nbeef\n713.0\n\n\n2\n1944-03-01\nbeef\n741.0\n\n\n3\n1944-04-01\nbeef\n650.0\n\n\n4\n1944-05-01\nbeef\n681.0\n\n\n\n\n\n\n\nFirst try\n\np = (\n    ggplot(meat_long, aes(x=\"date\", y=\"weight\"))\n    + geom_line()\n)\np\n\n\n\n\n\n\n\n\nIt looks crowded because each there is more than one monthly entry at each x-point. We can get a single trend line by getting a monthly aggregate of the weights.\n\nmeat_long_monthly_agg = meat_long.groupby(\"date\").agg({\"weight\": \"sum\"}).reset_index()\nmeat_long_monthly_agg\n\n\n\n\n\n\n\n\ndate\nweight\n\n\n\n\n0\n1944-01-01\n2205.0\n\n\n1\n1944-02-01\n2031.0\n\n\n2\n1944-03-01\n2034.0\n\n\n3\n1944-04-01\n1783.0\n\n\n4\n1944-05-01\n1894.0\n\n\n...\n...\n...\n\n\n955\n2023-08-01\n9319.1\n\n\n956\n2023-09-01\n8586.1\n\n\n957\n2023-10-01\n9452.5\n\n\n958\n2023-11-01\n8951.1\n\n\n959\n2023-12-01\n8555.1\n\n\n\n\n960 rows × 2 columns\n\n\n\n\nA Single Trend Line\n\n(\n    ggplot(meat_long_monthly_agg, aes(x=\"date\", y=\"weight\"))\n    + geom_line()\n)\n\n\n\n\n\n\n\n\nAdd some style\n\n# Gallery, lines\n(\n    ggplot(meat_long_monthly_agg, aes(x=\"date\", y=\"weight\"))\n    + geom_line()\n    # Styling\n    + scale_x_datetime(date_breaks=\"10 years\", date_labels=\"%Y\")\n    + theme_538()\n)\n\n\n\n\n\n\n\n\nOr we can group by the animals to get a trend line for each animal\n\n\nMultiple Trend Lines\n\n(\n    ggplot(meat_long, aes(x=\"date\", y=\"weight\", group=\"animal\"))\n    + geom_line()\n    # Styling\n    + scale_x_datetime(date_breaks=\"10 years\", date_labels=\"%Y\")\n    + theme_538()\n)\n\n\n\n\n\n\n\n\nMake each group be a different color.\n\n# Gallery, lines\n(\n    ggplot(meat_long, aes(x=\"date\", y=\"weight\", color=\"animal\"))\n    + geom_line()\n    # Styling\n    + scale_x_datetime(date_breaks=\"10 years\", date_labels=\"%Y\")\n    + theme_538()\n)\n\n\n\n\n\n\n\n\n\n\nA Trend Line Per Facet\nPlot each group on a separate panel. The legend is no longer required and we adjust to the smaller panels by reducing the size of the line, size of the text and the number of grid lines.\n\n# Gallery, lines\ndef titled(strip_title):\n    return \" \".join(s.title() if s != \"and\" else s for s in strip_title.split(\"_\"))\n\n(\n    ggplot(meat_long, aes(\"date\", \"weight\", color=\"animal\"))\n    + geom_line(size=.5, show_legend=False)\n    + facet_wrap(\"animal\", labeller=titled)\n    + scale_x_datetime(date_breaks=\"20 years\", date_labels=\"%Y\")\n    + labs(\n        x=\"Date\",\n        y=\"Weight (million pounds)\",\n        title=\"Meat Production\"\n    )\n    + theme_538(base_size=9)\n)"
  },
  {
    "objectID": "gallery/dev/geom_histogram.html",
    "href": "gallery/dev/geom_histogram.html",
    "title": "Histograms",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    after_stat,\n    geom_histogram,\n    facet_wrap,\n    facet_grid,\n    coord_flip,\n    scale_y_continuous,\n    scale_y_sqrt,\n    scale_y_log10,\n    scale_fill_manual,\n    theme_bw,\n    theme_xkcd,\n)\nfrom plotnine.data import diamonds\nfrom mizani.formatters import percent_format\n\nVisualise the distribution of a variable by dividing the x-axis into bins and counting the number of observations in each bin. Histograms display the counts with bars.\nYou can define the number of bins (e.g. divide the data five bins) or define the binwidth (e.g. each bin is size 10).\nDistributions can be visualised as: * count, * normalised count, * density, * normalised density, * scaled density as a percentage.\n\ndiamonds.head(5)\n\n\n\n\n\n\n\n\ncarat\ncut\ncolor\nclarity\ndepth\ntable\nprice\nx\ny\nz\n\n\n\n\n0\n0.23\nIdeal\nE\nSI2\n61.5\n55.0\n326\n3.95\n3.98\n2.43\n\n\n1\n0.21\nPremium\nE\nSI1\n59.8\n61.0\n326\n3.89\n3.84\n2.31\n\n\n2\n0.23\nGood\nE\nVS1\n56.9\n65.0\n327\n4.05\n4.07\n2.31\n\n\n3\n0.29\nPremium\nI\nVS2\n62.4\n58.0\n334\n4.20\n4.23\n2.63\n\n\n4\n0.31\nGood\nJ\nSI2\n63.3\n58.0\n335\n4.34\n4.35\n2.75\n\n\n\n\n\n\n\n\nBasic Histogram\nIf you create a basic histogram, you will be prompted to define the binwidth or number of bins.\n\n# Gallery, distributions\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram()\n)\n\n\n\n\n\n\n\n\nYou can define the width of the bins, by specifying the binwidth inside geom_histogram().\n\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram(binwidth=0.5)  # specify the binwidth\n)\n\n\n\n\n\n\n\n\nOr you can define the number of bins by specifying bins inside geom_histogram(). Note, the example below uses 10 bins, however you can’t see them all because some of the bins are too small to be noticeable.\n\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram(bins=10)  # specify the number of bins\n)\n\n\n\n\n\n\n\n\nThere are different ways to visualise the distribution, you can specify this using the y argument within aes(). In the example below I’m using the default setting: raw count with after_stat('count').\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"count\"),  # specify each bin is a count\n        ),\n    )\n    + geom_histogram(binwidth=0.50)\n)\n\n\n\n\n\n\n\n\nYou can normalise the raw count to 1 by using after_stat('ncount'):\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"ncount\"),  # normalise the count to 1\n        ),\n    )\n    + geom_histogram(binwidth=0.50)\n)\n\n\n\n\n\n\n\n\nYou can display the density of points in a bin, (this is scaled to integrate to 1) by using after_stat('density'):\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"density\"),  # density\n        ),\n    )\n    + geom_histogram(binwidth=0.50)\n)\n\n\n\n\n\n\n\n\nThe proportion of bins can be shown, in the example below the bin=0.5 accounts for about ~55% of the data:\n\n(\n    ggplot(\n        diamonds,\n        aes(x=\"carat\", y=after_stat(\"width*density\")),  # show proportion\n    )\n    + geom_histogram(binwidth=0.5)\n)\n\n\n\n\n\n\n\n\nWe can also display counts as percentages by using the percent_format() which requires the mizani.formatters library:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"width*density\")))\n    + geom_histogram(binwidth=0.5)\n    + scale_y_continuous(labels=percent_format())  # display labels as a percentage\n)\n\n\n\n\n\n\n\n\nInstead of using stat you can use stat_bin defined within geom_histogram(), this is useful if you want to layer a few different plots in the one figure.\n\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram(binwidth=0.5, alpha=0.5)\n    + geom_histogram(binwidth=0.2, alpha=0.5, fill=\"green\")\n)\n\n\n\n\n\n\n\n\nYou can also flip the x-y coordinates:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"density\")))\n    + geom_histogram(binwidth=0.5)\n    + coord_flip()\n)\n\n\n\n\n\n\n\n\nYou can visualise counts by other variables using fill within aes():\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"count\"), fill=\"cut\"))\n    + geom_histogram(binwidth=0.5)\n)\n\n\n\n\n\n\n\n\nYou can visualise too-small-to-see bars by transforming the y-axis scaling by using scale_y_sqrt() square-root scale or scale_y_log10() for a log-scale (similarly use scale_x_sqrt() and scale_x_log10() to transform the x-axis).\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"count\")))\n    + geom_histogram(binwidth=0.5)\n    + scale_y_sqrt()  # square root scale\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"count\")))\n    + geom_histogram(binwidth=0.5)\n    + scale_y_log10()  # log scale\n)\n\n\n\n\n\n\n\n\nChange the look of your plot:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"density\")))\n    + geom_histogram(\n        binwidth=0.5,\n        fill=\"green\",  # change the fill colour (one colour)\n        colour=\"pink\",  # change the outline\n        size=2,  # change the thickness of the outline\n        alpha=0.7,  # change the transparency\n    )\n    + theme_xkcd()  # play with themes (look/arrangement)\n)\n\n\n\n\n\n\n\n\nAnother change, this time changing the fill colours manually:\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"density\"),\n            fill=\"cut\",  # change the fill colour using another variable\n        ),\n    )\n    + scale_fill_manual(\n        values=[\"#000000\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\"]\n    )  # change the fill colour\n    + geom_histogram(\n        binwidth=0.5,\n        colour=\"#D55E00\",  # change the outline\n        size=1,  # change the thickness of the outline\n        alpha=0.7,  # change the transparency\n    )\n    + theme_bw()  # play with themes (look/arrangement)\n)\n\n\n\n\n\n\n\n\nWhen faceting histograms with scaled counts/densities, they are normalised by each facet, and not overall. Here’s an example of a facet wrap:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"ncount\")))\n    + geom_histogram(binwidth=0.5)\n    + facet_wrap(\"color\")  # facet wrap\n)\n\n\n\n\n\n\n\n\nHere’s an example of a facet grid with the count normalised in each grid:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"ncount\")))\n    + geom_histogram(binwidth=0.5)\n    + facet_grid(\"cut\", \"color\")\n)"
  },
  {
    "objectID": "gallery/dev/geom_count.html",
    "href": "gallery/dev/geom_count.html",
    "title": "Categorized Data Plot",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_count, scale_size_continuous\nfrom plotnine.data import diamonds\n\ngeom_count() makes the point size proportional to the number of points at a location\n\ndiamonds.head()\n\n\n\n\n\n\n\n\ncarat\ncut\ncolor\nclarity\ndepth\ntable\nprice\nx\ny\nz\n\n\n\n\n0\n0.23\nIdeal\nE\nSI2\n61.5\n55.0\n326\n3.95\n3.98\n2.43\n\n\n1\n0.21\nPremium\nE\nSI1\n59.8\n61.0\n326\n3.89\n3.84\n2.31\n\n\n2\n0.23\nGood\nE\nVS1\n56.9\n65.0\n327\n4.05\n4.07\n2.31\n\n\n3\n0.29\nPremium\nI\nVS2\n62.4\n58.0\n334\n4.20\n4.23\n2.63\n\n\n4\n0.31\nGood\nJ\nSI2\n63.3\n58.0\n335\n4.34\n4.35\n2.75\n\n\n\n\n\n\n\n\n(\n    ggplot(diamonds)\n    + geom_count(aes(x=\"cut\", y=\"color\"))\n)\n\n\n\n\n\n\n\n\nWe can adjust the size range of the points with scale_size_continuous\n\n(\n    ggplot(diamonds)\n    + geom_count(aes(x=\"cut\", y=\"color\"))\n    + scale_size_continuous(range=[1, 20])\n)"
  },
  {
    "objectID": "gallery/dev/geom_boxplot.html",
    "href": "gallery/dev/geom_boxplot.html",
    "title": "A box and whiskers plot",
    "section": "",
    "text": "import pandas as pd\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_boxplot,\n    geom_jitter,\n    scale_x_discrete,\n    coord_flip,\n)\n\nThe boxplot compactly displays the distribution of a continuous variable.\nRead more: + wikipedia + ggplot2 docs\n\nflights = pd.read_csv(\"data/flights.csv\")\nflights.head()\n\n\n\n\n\n\n\n\nyear\nmonth\npassengers\n\n\n\n\n0\n1949\nJanuary\n112\n\n\n1\n1949\nFebruary\n118\n\n\n2\n1949\nMarch\n132\n\n\n3\n1949\nApril\n129\n\n\n4\n1949\nMay\n121\n\n\n\n\n\n\n\nBasic boxplot\n\nmonths = [month[:3] for month in flights.month[:12]]\nprint(months)\n\n['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n\n\n\nA Basic Boxplot\n\n# Gallery, distributions\n(\n    ggplot(flights)\n    + geom_boxplot(aes(x=\"factor(month)\", y=\"passengers\"))\n    + scale_x_discrete(labels=months, name=\"month\")  # change ticks labels on OX\n)\n\n\n\n\n\n\n\n\nHorizontal boxplot\n\n(\n    ggplot(flights)\n    + geom_boxplot(aes(x=\"factor(month)\", y=\"passengers\"))\n    + coord_flip()\n    + scale_x_discrete(\n        labels=months[::-1],\n        limits=flights.month[11::-1],\n        name=\"month\",\n    )\n)\n\n\n\n\n\n\n\n\nBoxplot with jittered points:\n\n(\n    ggplot(flights, aes(x=\"factor(month)\", y=\"passengers\"))\n    + geom_boxplot()\n    + geom_jitter()\n    + scale_x_discrete(labels=months, name=\"month\")  # change ticks labels on OX\n)"
  },
  {
    "objectID": "gallery/dev/geom_area.html",
    "href": "gallery/dev/geom_area.html",
    "title": "Area Under Line",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    geom_area,\n    geom_line,\n    scale_x_date,\n    scale_y_continuous,\n    theme_linedraw,\n    theme_set,\n)\nfrom plotnine.data import economics\n\n# Set default theme\ntheme_set(theme_linedraw())\n\n\n# Gallery, areas\n(\n    ggplot(economics, aes(x=\"date\", y=\"unemploy\"))\n    + geom_line()\n    + geom_area(fill=\"#e5c8d6\", color=\"#9e2f68\")\n    + scale_x_date(expand=(0, 0), date_labels=\"%Y\")\n    + scale_y_continuous(expand=(0, 0, 0.1, 0))\n    + theme_linedraw()\n)"
  },
  {
    "objectID": "gallery/dev/factor.html",
    "href": "gallery/dev/factor.html",
    "title": "plotnine {{< var version >}}",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_bar\nfrom plotnine.data import mtcars\n\nggplot(mtcars, aes(x=\"factor(cyl)\")) + geom_bar()"
  },
  {
    "objectID": "gallery/dev/facet_grid.html",
    "href": "gallery/dev/facet_grid.html",
    "title": "Facet grid",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_point, labs, facet_grid, theme, element_text, element_rect\nfrom plotnine.data import mpg\n\nfacet_grid() is used to form a grid of plots, where the rows and columns of the grid are set by the faceting variables. It is useful for visualising two discrete variables.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nBasic scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nFacet a discrete variable into rows:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid(\"drv\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nFacet a discrete variable into columns:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid(cols=\"cyl\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nFacet two discrete variables into rows and columns:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid(\"drv\", \"cyl\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nTo change the plot order of the rows or columns in the facet grid, reorder the levels of the faceting variable in the data.\n\n# re-order categories\nmpg[\"drv\"] = mpg[\"drv\"].cat.reorder_categories([\"f\", \"r\", \"4\"])\n\n\n# facet plot with reorded drv category\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid(\"drv\", \"cyl\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can choose if the scale of x- and y-axes are fixed or variable by using the scales argument within the facet_grid() command:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid(\"drv\", scales=\"free\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can add additional information to your facet labels, by using the labeller argument within the facet_grid() command. Below we use labeller = 'label_both' to include the column name in the facet label.\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid(\"drv\", labeller=\"label_both\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can add two discrete variables to a facet:\n\n# add additional column for plotting exercise\nmpg[\"transmission\"] = mpg[\"trans\"].map(\n    lambda x: \"auto\" if \"auto\" in x else \"man\" if \"man\" in x else \"\"\n)\n\n\n# inspect new column transmission which identifies cars as having an automatic or manual transmission\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\ntransmission\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\nauto\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\nman\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\nman\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\nauto\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\nauto\n\n\n\n\n\n\n\n\n# facet plot with two variables on one facet\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid([\"drv\", \"transmission\"])  # use a list to add additional faceting variables\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nFacet labels can be rotated to make them easier to read using strip_text_y = element_text(angle = 0) for row labels within the theme() command (use strip_text_x = element_text(angle = 0) for column labels).\nIf the labels do not fit in the strip, adjust the width of the strip using strip_background_y for rows (use strip_background_x for columns). You may also need to adjust the text position so it fits in the strip: adjust the horizontal text position in the strip by specifying ha in element_text()(specify va in element_text() to adjust the vertical text position).\nYou can also change the colour of the strip by specifying color in element_text() .\n\n(\n    ggplot(mpg, aes(x=\"drv\", y=\"model\"))\n    + geom_point()\n    + facet_grid(\"manufacturer\", scales=\"free\")\n    + theme(\n        strip_text_y=element_text(angle=0),   # change facet text angle\n        strip_background_y=element_rect(fill=\"#969dff\"),   # change background colour of facet background\n        figure_size=(6, 15),  # adjust width & height of figure to fit y-axis\n    )\n    + labs(x=\"displacement\", y=\"\")\n)"
  },
  {
    "objectID": "gallery/dev/after_scale.html",
    "href": "gallery/dev/after_scale.html",
    "title": "after_scale",
    "section": "",
    "text": "import pandas as pd\n\nfrom plotnine import ggplot, aes, after_scale, geom_bar, theme_classic\n\nThe bars in geom_bar have two aesthetics that control the coloring; fill for the interior and color for the boundary/edge. Using after_scale we can create a matching combination of these two.\nStart off with a mapping to the color.\n\ndf = pd.DataFrame({\"var1\": [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]})\n\n(\n    ggplot(df, aes(\"var1\", color=\"factor(var1)\"))\n    + geom_bar(size=1)\n)\n\n\n\n\n\n\n\n\nWe can match the color with the fill.\n\n(\n    ggplot(df, aes(\"var1\", color=\"factor(var1)\"))\n    + geom_bar(aes(fill=after_scale(\"color\")), size=1)\n)\n\n\n\n\n\n\n\n\nAs after_scale takes an expression, for the fill aesthetic we can modify the color by adding to it an alpha channel i.e. '#AABBCC' to '#AABBCC66'.\n\n(\n    ggplot(df, aes(\"var1\", color=\"factor(var1)\"))\n    + geom_bar(aes(fill=after_scale('color + \"66\"')), size=1)\n)\n\n\n\n\n\n\n\n\nWe rely on the fact that you can append a string to all elements of a pandas series\npd.Series(['#AABBCC', '#112233']) + '66' == pd.Series(['#AABBCC66', '#11223366'])\nWith a fitting theme.\n\n(\n    ggplot(df, aes(\"var1\", color=\"factor(var1)\"))\n    + geom_bar(aes(fill=after_scale('color + \"66\"')), size=1)\n    + theme_classic()\n)"
  },
  {
    "objectID": "gallery/dev/PlotnineAnimation.html",
    "href": "gallery/dev/PlotnineAnimation.html",
    "title": "Spiral Animation ###",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nfrom plotnine import ggplot, aes, geom_path, theme, theme_void, lims\nfrom plotnine.animation import PlotnineAnimation\n\n# for animation in the notebook\nfrom matplotlib import rc\n\nrc(\"animation\", html=\"html5\")\n\nHow to create Animations\nThe PlotnineAnimation methods takes a sequence of plots and animates them. The best way to create the sequence is to use a function that generates plots.\nNOTE: When creating the plots make sure all the plots have scales with the same limits for each aesthetic, including the x and y aesthetics.\n\n# Parameters used to control the spiral\nn = 100\ntightness = 1.3\nkmin = 1\nkmax = 25\nnum_frames = 25\ntheta = np.linspace(-np.pi, np.pi, n)\n\n\ndef plot(k):\n    # For every plot we change the theta\n    _theta = theta * k\n\n    # Polar Equation of each spiral\n    r = tightness * _theta\n\n    df = pd.DataFrame({\n        \"theta\": _theta,\n        \"r\": r,\n        \"x\": r * np.sin(_theta),\n        \"y\": r * np.cos(_theta)\n    })\n\n    p = (\n        ggplot(df)\n        + geom_path(aes(\"x\", \"y\", color=\"theta\"), size=1)\n        + lims(\n            # All the plots have scales with the same limits\n            x=(-130, 130),\n            y=(-130, 130),\n            color=(-kmax * np.pi, kmax * np.pi),\n        )\n        + theme_void()\n        + theme(\n            aspect_ratio=1,\n            # Make room on the right for the legend\n            subplots_adjust={\"right\": 0.85},\n        )\n    )\n    return p\n\n\n# It is better to use a generator instead of a list\nplots = (plot(k) for k in np.linspace(kmin, kmax, num_frames))\nani = PlotnineAnimation(plots, interval=100, repeat_delay=500)\n# ani.save('/tmp/animation.mp4')\nani\n\n\n  \n  Your browser does not support the video tag.\n\n\n\nThe final image of the spiral\n\n# Gallery Plot\n\nplot(kmax)"
  },
  {
    "objectID": "reference/ylim.html",
    "href": "reference/ylim.html",
    "title": " plotnine.ylim",
    "section": "",
    "text": "ylim(limits=())"
  },
  {
    "objectID": "reference/ylim.html#parameters",
    "href": "reference/ylim.html#parameters",
    "title": " plotnine.ylim",
    "section": "Parameters",
    "text": "Parameters\n\n\n*limits = ()\n\nMin and max limits. Must be of size 2. You can also pass two values e.g ylim(40, 100)"
  },
  {
    "objectID": "reference/ylim.html#notes",
    "href": "reference/ylim.html#notes",
    "title": " plotnine.ylim",
    "section": "Notes",
    "text": "Notes\nIf the 2nd value of limits is less than the first, a reversed scale will be created."
  },
  {
    "objectID": "reference/xlim.html",
    "href": "reference/xlim.html",
    "title": " plotnine.xlim",
    "section": "",
    "text": "xlim(limits=())"
  },
  {
    "objectID": "reference/xlim.html#parameters",
    "href": "reference/xlim.html#parameters",
    "title": " plotnine.xlim",
    "section": "Parameters",
    "text": "Parameters\n\n\n*limits = ()\n\nMin and max limits. Must be of size 2. You can also pass two values e.g xlim(40, 100)"
  },
  {
    "objectID": "reference/watermark.html",
    "href": "reference/watermark.html",
    "title": " plotnine.watermark",
    "section": "",
    "text": "watermark(filename, xo=0, yo=0, alpha=None, kwargs={})"
  },
  {
    "objectID": "reference/watermark.html#parameters",
    "href": "reference/watermark.html#parameters",
    "title": " plotnine.watermark",
    "section": "Parameters",
    "text": "Parameters\n\n\nfilename : str | pathlib.Path\n\nImage file\n\nxo : int = 0\n\nx position offset in pixels.\n\nyo : int = 0\n\ny position offset in pixels.\n\nalpha : Optional[float] = None\n\nAlpha blending value.\n\nkwargs : Any = {}\n\nAdditional parameters passed to figimage"
  },
  {
    "objectID": "reference/watermark.html#notes",
    "href": "reference/watermark.html#notes",
    "title": " plotnine.watermark",
    "section": "Notes",
    "text": "Notes\nYou can add more than one watermark to a plot."
  },
  {
    "objectID": "reference/watermark.html#methods",
    "href": "reference/watermark.html#methods",
    "title": " plotnine.watermark",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndraw\nDraw watermark\n\n\n\n\n draw\n\ndraw(figure)\n\n\nDraw watermark\n\n\nParameters\n\n\nfigure : matplotlib.figure.Figure\n\nMatplolib figure on which to draw"
  },
  {
    "objectID": "reference/txhousing.html",
    "href": "reference/txhousing.html",
    "title": " plotnine.data.txhousing",
    "section": "",
    "text": "txhousing = pd.read_csv(DATA_DIR / \"txhousing.csv\")"
  },
  {
    "objectID": "reference/txhousing.html#description",
    "href": "reference/txhousing.html#description",
    "title": " plotnine.data.txhousing",
    "section": "Description",
    "text": "Description\nInformation about the housing market in Texas provided by the TAMU real estate center, http://recenter.tamu.edu/."
  },
  {
    "objectID": "reference/txhousing.html#format",
    "href": "reference/txhousing.html#format",
    "title": " plotnine.data.txhousing",
    "section": "Format",
    "text": "Format\nA data frame with 8602 observations and 9 variables:\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\ncity\nName of MLS area\n\n\nyear\nYear\n\n\nmonth\nMonth\n\n\nsales\nNumber of sales\n\n\nvolume\nTotal value of sales\n\n\nmedian\nMedian sale price\n\n\nlistings\nTotal active listings\n\n\ninventory\n“Months inventory”: amount of time it would take to sell all current listings at current pace of sales.\n\n\ndate\nDate"
  },
  {
    "objectID": "reference/themeable.html",
    "href": "reference/themeable.html",
    "title": " plotnine.themes.themeable.themeable",
    "section": "",
    "text": "themeable(theme_element)"
  },
  {
    "objectID": "reference/themeable.html#notes",
    "href": "reference/themeable.html#notes",
    "title": " plotnine.themes.themeable.themeable",
    "section": "Notes",
    "text": "Notes\nA user should never create instances of class Themeable or subclasses of it."
  },
  {
    "objectID": "reference/themeable.html#attributes",
    "href": "reference/themeable.html#attributes",
    "title": " plotnine.themes.themeable.themeable",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nproperties\nReturn only the properties that can be applied\n\n\nrcParams\nReturn themeables rcparams to an rcparam dict before plotting.\n\n\n\n\n properties \n\nproperties\n\n\nReturn only the properties that can be applied\n\n\n\n rcParams \n\nrcParams : dict[str, Any]\n\n\nReturn themeables rcparams to an rcparam dict before plotting.\n\n\nReturns\n\n\ndict\n\nDictionary of legal matplotlib parameters.\n\nThis method should always call super(…).rcParams and\n\n\n\nupdate the dictionary that it returns with its own value, and\n\n\n\nreturn that dictionary.\n\n\n\nThis method is called before plotting. It tends to be more\n\n\n\nuseful for general themeables. Very specific themeables\n\n\n\noften cannot be be themed until they are created as a\n\n\n\nresult of the plotting process."
  },
  {
    "objectID": "reference/themeable.html#methods",
    "href": "reference/themeable.html#methods",
    "title": " plotnine.themes.themeable.themeable",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\napply\nCalled by the theme to apply the themeable\n\n\napply_ax\nCalled after a chart has been plotted.\n\n\napply_figure\nApply theme to the figure\n\n\nblank_ax\nBlank out theme elements\n\n\nblank_figure\nBlank out elements on the figure\n\n\nfrom_class_name\nCreate a themeable by name\n\n\nis_blank\nReturn True if theme_element is made of element_blank\n\n\nmerge\nMerge properties of other into self\n\n\n\n\n apply\n\napply(theme)\n\n\nCalled by the theme to apply the themeable\nSubclasses should not have to override this method\n\n\n\n apply_ax\n\napply_ax(ax)\n\n\nCalled after a chart has been plotted.\nSubclasses can override this method to customize the plot according to the theme.\nThis method should be implemented as super().apply_ax() followed by extracting the portion of the axes specific to this themeable then applying the properties.\n\n\nParameters\n\n\nax : matplotlib.axes.Axes\n\n\n\n\n\n\n\n\n apply_figure\n\napply_figure(figure, targets)\n\n\nApply theme to the figure\n\n\n\n blank_ax\n\nblank_ax(ax)\n\n\nBlank out theme elements\n\n\n\n blank_figure\n\nblank_figure(figure, targets)\n\n\nBlank out elements on the figure\n\n\n\n from_class_name \n\nfrom_class_name(name, theme_element)\n\n\nCreate a themeable by name\n\n\nParameters\n\n\nname : str\n\nClass name\n\ntheme_element : element object\n\nAn element of the type required by the theme. For lines, text and rects it should be one of: element_line, element_rect, element_text or element_blank\n\n\n\n\n\nReturns\n\n\nout : plotnine.themes.themeable.themeable\n\n\n\n\n\n\n\n\n is_blank\n\nis_blank()\n\n\nReturn True if theme_element is made of element_blank\n\n\n\n merge\n\nmerge(other)\n\n\nMerge properties of other into self\n\n\nRaises\n\n\nValueError\n\nIf any of the properties are blank"
  },
  {
    "objectID": "reference/theme_void.html",
    "href": "reference/theme_void.html",
    "title": " plotnine.theme_void",
    "section": "",
    "text": "theme_void(base_size=11, base_family=None)"
  },
  {
    "objectID": "reference/theme_void.html#parameters",
    "href": "reference/theme_void.html#parameters",
    "title": " plotnine.theme_void",
    "section": "Parameters",
    "text": "Parameters\n\n\nbase_size : int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family : str = None\n\nBase font family."
  },
  {
    "objectID": "reference/theme_tufte.html",
    "href": "reference/theme_tufte.html",
    "title": " plotnine.theme_tufte",
    "section": "",
    "text": "theme_tufte(base_size=11, base_family=None, ticks=True)"
  },
  {
    "objectID": "reference/theme_tufte.html#parameters",
    "href": "reference/theme_tufte.html#parameters",
    "title": " plotnine.theme_tufte",
    "section": "Parameters",
    "text": "Parameters\n\n\nbase_size : int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family : str = None\n\nBase font family. If None, use plotnine.options.base_family.\n\nticks = True\n\nWhether to show axis ticks."
  },
  {
    "objectID": "reference/theme_tufte.html#references",
    "href": "reference/theme_tufte.html#references",
    "title": " plotnine.theme_tufte",
    "section": "References",
    "text": "References\nTufte, Edward R. (2001) The Visual Display of Quantitative Information, Chapter 6.\nTranslated from the R ggthemes package by hyiltiz hyiltiz@gmail.com. Released under GNU GPL v2 license or later."
  },
  {
    "objectID": "reference/theme_seaborn.html",
    "href": "reference/theme_seaborn.html",
    "title": " plotnine.theme_seaborn",
    "section": "",
    "text": "theme_seaborn(\n    style=\"darkgrid\", context=\"notebook\", font=\"sans-serif\", font_scale=1\n)"
  },
  {
    "objectID": "reference/theme_seaborn.html#parameters",
    "href": "reference/theme_seaborn.html#parameters",
    "title": " plotnine.theme_seaborn",
    "section": "Parameters",
    "text": "Parameters\n\n\nstyle = \"darkgrid\"\n\nStyle of axis background.\n\ncontext = \"notebook\"\n\nIntended context for resulting figures.\n\nfont : str = \"sans-serif\"\n\nFont family, see matplotlib font manager.\n\nfont_scale : float = 1\n\nSeparate scaling factor to independently scale the size of the font elements."
  },
  {
    "objectID": "reference/theme_matplotlib.html",
    "href": "reference/theme_matplotlib.html",
    "title": " plotnine.theme_matplotlib",
    "section": "",
    "text": "theme_matplotlib(rc=None, fname=None, use_defaults=True)"
  },
  {
    "objectID": "reference/theme_matplotlib.html#parameters",
    "href": "reference/theme_matplotlib.html#parameters",
    "title": " plotnine.theme_matplotlib",
    "section": "Parameters",
    "text": "Parameters\n\n\nrc : dict = None\n\nrcParams which should be applied on top of mathplotlib default.\n\nfname : str = None\n\nFilename to a matplotlibrc file\n\nuse_defaults : bool = True\n\nIf True (the default) resets the plot setting to the (current) matplotlib.rcParams values"
  },
  {
    "objectID": "reference/theme_light.html",
    "href": "reference/theme_light.html",
    "title": " plotnine.theme_light",
    "section": "",
    "text": "theme_light(base_size=11, base_family=None)"
  },
  {
    "objectID": "reference/theme_light.html#parameters",
    "href": "reference/theme_light.html#parameters",
    "title": " plotnine.theme_light",
    "section": "Parameters",
    "text": "Parameters\n\n\nbase_size : int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family : str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_gray.html",
    "href": "reference/theme_gray.html",
    "title": " plotnine.theme_gray",
    "section": "",
    "text": "theme_gray(base_size=11, base_family=None)"
  },
  {
    "objectID": "reference/theme_gray.html#parameters",
    "href": "reference/theme_gray.html#parameters",
    "title": " plotnine.theme_gray",
    "section": "Parameters",
    "text": "Parameters\n\n\nbase_size : int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family : str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_dark.html",
    "href": "reference/theme_dark.html",
    "title": " plotnine.theme_dark",
    "section": "",
    "text": "theme_dark(base_size=11, base_family=None)"
  },
  {
    "objectID": "reference/theme_dark.html#parameters",
    "href": "reference/theme_dark.html#parameters",
    "title": " plotnine.theme_dark",
    "section": "Parameters",
    "text": "Parameters\n\n\nbase_size : int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family : str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_bw.html",
    "href": "reference/theme_bw.html",
    "title": " plotnine.theme_bw",
    "section": "",
    "text": "theme_bw(base_size=11, base_family=None)"
  },
  {
    "objectID": "reference/theme_bw.html#parameters",
    "href": "reference/theme_bw.html#parameters",
    "title": " plotnine.theme_bw",
    "section": "Parameters",
    "text": "Parameters\n\n\nbase_size : int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family : str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_bw.html#examples",
    "href": "reference/theme_bw.html#examples",
    "title": " plotnine.theme_bw",
    "section": "Examples",
    "text": "Examples\n\n\nfrom plotnine import ggplot, geom_point, aes, labs, theme_bw\nfrom plotnine.data import mtcars\n\n\nBlack & White\n\n# Gallery, themes\n(\n    ggplot(mtcars, aes(x=\"wt\", y=\"mpg\", colour=\"factor(gear)\"))\n    + geom_point()\n    + labs(\n        title= \"Fuel economy declines as weight increases\",\n        subtitle=\"(1973-74)\",\n        caption=\"Data from the 1974 Motor Trend US magazine.\",\n        x=\"Weight (1000 lbs)\",\n        y=\"Fuel economy (mpg)\",\n        colour=\"Gears\"\n    )\n    + theme_bw()\n)\n\n\n\n\n\n\n\n\n\nSource: Black & White"
  },
  {
    "objectID": "reference/theme.html",
    "href": "reference/theme.html",
    "title": " plotnine.theme",
    "section": "",
    "text": "theme(\n    complete=False,\n    axis_title_x=None,\n    axis_title_y=None,\n    axis_title=None,\n    legend_title=None,\n    legend_text_legend=None,\n    legend_text_colorbar=None,\n    legend_text=None,\n    plot_title=None,\n    plot_subtitle=None,\n    plot_caption=None,\n    plot_tag=None,\n    plot_title_position=None,\n    plot_caption_position=None,\n    plot_tag_location=None,\n    plot_tag_position=None,\n    strip_text_x=None,\n    strip_text_y=None,\n    strip_text=None,\n    title=None,\n    axis_text_x=None,\n    axis_text_y=None,\n    axis_text=None,\n    text=None,\n    axis_line_x=None,\n    axis_line_y=None,\n    axis_line=None,\n    axis_ticks_minor_x=None,\n    axis_ticks_minor_y=None,\n    axis_ticks_major_x=None,\n    axis_ticks_major_y=None,\n    axis_ticks_major=None,\n    axis_ticks_minor=None,\n    axis_ticks_x=None,\n    axis_ticks_y=None,\n    axis_ticks=None,\n    legend_ticks=None,\n    panel_grid_major_x=None,\n    panel_grid_major_y=None,\n    panel_grid_minor_x=None,\n    panel_grid_minor_y=None,\n    panel_grid_major=None,\n    panel_grid_minor=None,\n    panel_grid=None,\n    line=None,\n    legend_key=None,\n    legend_frame=None,\n    legend_background=None,\n    legend_box_background=None,\n    panel_background=None,\n    panel_border=None,\n    plot_background=None,\n    strip_background_x=None,\n    strip_background_y=None,\n    strip_background=None,\n    rect=None,\n    axis_ticks_length_major_x=None,\n    axis_ticks_length_major_y=None,\n    axis_ticks_length_major=None,\n    axis_ticks_length_minor_x=None,\n    axis_ticks_length_minor_y=None,\n    axis_ticks_length_minor=None,\n    axis_ticks_length=None,\n    panel_spacing_x=None,\n    panel_spacing_y=None,\n    panel_spacing=None,\n    plot_margin_left=None,\n    plot_margin_right=None,\n    plot_margin_top=None,\n    plot_margin_bottom=None,\n    plot_margin=None,\n    panel_ontop=None,\n    aspect_ratio=None,\n    dpi=None,\n    figure_size=None,\n    legend_box=None,\n    legend_box_margin=None,\n    legend_box_just=None,\n    legend_justification_right=None,\n    legend_justification_left=None,\n    legend_justification_top=None,\n    legend_justification_bottom=None,\n    legend_justification_inside=None,\n    legend_justification=None,\n    legend_direction=None,\n    legend_key_width=None,\n    legend_key_height=None,\n    legend_key_size=None,\n    legend_ticks_length=None,\n    legend_margin=None,\n    legend_box_spacing=None,\n    legend_spacing=None,\n    legend_position_inside=None,\n    legend_position=None,\n    legend_title_position=None,\n    legend_text_position=None,\n    legend_key_spacing_x=None,\n    legend_key_spacing_y=None,\n    legend_key_spacing=None,\n    strip_align_x=None,\n    strip_align_y=None,\n    strip_align=None,\n    svg_usefonts=None,\n    kwargs={}\n)"
  },
  {
    "objectID": "reference/theme.html#parameters",
    "href": "reference/theme.html#parameters",
    "title": " plotnine.theme",
    "section": "Parameters",
    "text": "Parameters\n\n\ncomplete : bool = False\n\nThemes that are complete will override any existing themes. themes that are not complete (ie. partial) will add to or override specific elements of the current theme. e.g:\ntheme_gray() + theme_xkcd()\nwill be completely determined by theme_xkcd, but:\ntheme_gray() + theme(axis_text_x=element_text(angle=45))\nwill only modify the x-axis text.\n\nkwargs = {}\n\nkwargs are themeables. The themeables are elements that are subclasses of themeable. Many themeables are defined using theme elements i.e\n\nelement_line\nelement_rect\nelement_text\n\nThese simply bind together all the aspects of a themeable that can be themed. See themeable."
  },
  {
    "objectID": "reference/theme.html#notes",
    "href": "reference/theme.html#notes",
    "title": " plotnine.theme",
    "section": "Notes",
    "text": "Notes\nWhen subclassing, make sure to call theme.__init__. After which you can customise self._rcParams within the __init__ method of the new theme. The rcParams should not be modified after that."
  },
  {
    "objectID": "reference/theme.html#examples",
    "href": "reference/theme.html#examples",
    "title": " plotnine.theme",
    "section": "Examples",
    "text": "Examples\n\n\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    facet_grid,\n    labs,\n    guide_legend,\n    guides,\n    theme,\n    element_text,\n    element_line,\n    element_rect,\n    theme_set,\n    theme_void,\n)\nfrom plotnine.data import mtcars\n\n# We use theme_void as the base theme so that the modifications\n# we make in the code are transparent in the output\ntheme_set(theme_void())\n\n\nmtcars.head()\n\n\n\n\n\n\n\n\nname\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\n0\nMazda RX4\n21.0\n6\n160.0\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\n1\nMazda RX4 Wag\n21.0\n6\n160.0\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\n2\nDatsun 710\n22.8\n4\n108.0\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\n3\nHornet 4 Drive\n21.4\n6\n258.0\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\n4\nHornet Sportabout\n18.7\n8\n360.0\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\n\n\n\n\n\nThe base plots we will use for the demonstation and some colors.\n\np1 = (\n    ggplot(mtcars, aes(\"wt\", \"mpg\", color=\"factor(cyl)\"))\n    + geom_point()\n    + labs(title=\"mpg vs wt\")\n)\n\np2 = p1 + facet_grid(\"gear\", \"am\")\n\nblack = \"#222222\"\ngray = \"#666666\"\nred = \"#FF3333\"\ngreen = \"#66CC00\"\nblue = \"#3333FF\"\npurple = \"#9933FF\"\norange = \"#FF8000\"\nyellow = \"#FFFF33\"\n\nWhat the plots look like unmodified (unthemed).\n\np1\n\n\n\n\n\n\n\n\n\np2\n\n\n\n\n\n\n\n\nThere are 3 main top level theming elements:\n\ntext - controls all the text elements in the figure.\nrect - controls all the rectangles in the figure.\nline - controls all the lines in the figure.\n\nNote that none of the themeables control/modify the plotted data. e.g You cannot use text to change the appearance of objects plotted with geom_text.\ntext\n\np1 + theme(text=element_text(color=purple))\n\n\n\n\n\n\n\n\nrect\n\np1 + theme(rect=element_rect(color=black, size=3, fill=\"#EEBB0050\"))\n\n\n\n\n\n\n\n\nline\n\np1 + theme(line=element_line(color=black))\n\n\n\n\n\n\n\n\n\nTheming specific items\n\naxis_line and axis_text\n\np1 + theme(\n    axis_line=element_line(size=2),\n    axis_line_x=element_line(color=red),\n    axis_line_y=element_line(color=blue),\n    axis_text=element_text(margin={\"t\": 5, \"r\": 5}),\n    axis_text_x=element_text(color=black),\n    axis_text_y=element_text(color=purple),\n)\n\n\n\n\n\n\n\n\n\np1 + theme(\n    axis_line=element_line(size=0.7, color=gray),\n    # We are focusing on the ticks, make them long\n    axis_ticks_length=20,\n    axis_ticks_length_minor=10,\n    axis_ticks_length_major=20,\n    axis_ticks=element_line(size=2),\n    axis_ticks_major=element_line(color=purple),\n    axis_ticks_major_x=element_line(size=4),  # override size=2\n    axis_ticks_major_y=element_line(color=yellow),  # override color=purple\n    axis_ticks_minor=element_line(color=red),\n    axis_ticks_minor_x=element_line(),  # do not override anything\n    axis_ticks_minor_y=element_line(color=gray),  # override color=red\n)\n\n\n\n\n\n\n\n\n\n\naxis_title and axis_ticks_pad\n\np1 + theme(\n    axis_line=element_line(size=0.7, color=gray),\n    axis_ticks=element_line(),\n    axis_title=element_text(),\n    axis_title_x=element_text(color=blue),\n    axis_title_y=element_text(color=red),\n    # The gap between the title and the ticks\n    axis_ticks_pad=20,\n    axis_ticks_pad_major=20,\n    axis_ticks_pad_minor=20,\n)\n\n\n\n\n\n\n\n\n\n\naxis_ticks_direction\n\np1 + theme(\n    axis_line=element_line(size=0.7, color=gray),\n    axis_ticks=element_line(),\n    axis_ticks_direction=\"in\",\n    axis_ticks_direction_x=\"in\",\n    axis_ticks_direction_y=\"out\",\n)\n\n\n\n\n\n\n\n\n\n\nLegend_box\nNot all themeables that affect the legend box are demonstrated\n\n(\n    p1\n    + aes(fill=\"drat\")\n    + theme(\n        legend_position=\"left\",\n        legend_direction=\"horizontal\",  # affected by the ncol=2\n        legend_box_margin=5,\n        legend_background=element_rect(color=purple, size=2, fill=\"white\"),\n        legend_box=\"vertical\",\n        legend_key=element_rect(fill=gray, alpha=0.3),\n        legend_title=element_text(color=orange, va=\"top\"),\n        legend_text=element_text(weight=\"bold\"),\n        legend_key_spacing=10,  # overridden\n        legend_key_spacing_x=15,\n        legend_key_spacing_y=5,\n    )\n    # so we can see legend_entry_spacing in action\n    + guides(color=guide_legend(ncol=2))\n)\n\n\n\n\n\n\n\n\n\n\nplot_background, panel_background and panel_border\n\np2 + theme(\n    plot_background=element_rect(fill=\"gray\", alpha=0.3),\n    panel_background=element_rect(fill=purple, alpha=0.2),\n    panel_border=element_rect(color=red, size=1),\n    panel_spacing=0.025,\n)\n\n\n\n\n\n\n\n\n\n\npanel_grid\n\np1 + theme(\n    panel_grid=element_line(color=purple),\n    panel_grid_major=element_line(size=1.4, alpha=1),\n    panel_grid_major_x=element_line(linetype=\"dashed\"),\n    panel_grid_major_y=element_line(linetype=\"dashdot\"),\n    panel_grid_minor=element_line(alpha=0.25),\n    panel_grid_minor_x=element_line(color=red),\n    panel_grid_minor_y=element_line(color=green),\n    panel_ontop=False,  # puts the points behind the grid\n)\n\n\n\n\n\n\n\n\n\n\nstrip_background, strip_align and strip_text\n\np2 + theme(\n    panel_spacing=0.025,\n    panel_background=element_rect(fill=gray, alpha=0.2),\n    strip_background=element_rect(color=purple, fill=orange, size=1.4, alpha=0.95),\n    strip_background_x=element_rect(x=1 / 6, width=2 / 3),  # you can get really crazy\n    strip_background_y=element_rect(),\n    strip_align=0,\n    strip_align_x=0.2,\n    strip_align_y=0.2,\n    strip_text=element_text(weight=\"bold\"),\n    strip_text_x=element_text(color=red),\n    strip_text_y=element_text(color=blue),\n)\n\n\n\n\n\n\n\n\n\n\naspect_ratio and figure_size\nThe aspect_ratio takes precedence over the figure_size, and it modifies the height. The effective width and height are:\nwidth = figure_size[0]\nheight = figure_size[0] * aspect_ratio\n\np1 + theme(\n    panel_background=element_rect(fill=gray, alpha=0.2),\n    figure_size=(8, 6),  # inches\n    aspect_ratio=1 / 3,  # height:width\n)\n\n\n\n\n\n\n\n\n\n\nSource: We use theme_void as the base theme so that the modifications"
  },
  {
    "objectID": "reference/theme.html#theming-specific-items",
    "href": "reference/theme.html#theming-specific-items",
    "title": " plotnine.theme",
    "section": "Theming specific items",
    "text": "Theming specific items\n\naxis_line and axis_text\n\np1 + theme(\n    axis_line=element_line(size=2),\n    axis_line_x=element_line(color=red),\n    axis_line_y=element_line(color=blue),\n    axis_text=element_text(margin={\"t\": 5, \"r\": 5}),\n    axis_text_x=element_text(color=black),\n    axis_text_y=element_text(color=purple),\n)\n\n\n\n\n\n\n\n\n\np1 + theme(\n    axis_line=element_line(size=0.7, color=gray),\n    # We are focusing on the ticks, make them long\n    axis_ticks_length=20,\n    axis_ticks_length_minor=10,\n    axis_ticks_length_major=20,\n    axis_ticks=element_line(size=2),\n    axis_ticks_major=element_line(color=purple),\n    axis_ticks_major_x=element_line(size=4),  # override size=2\n    axis_ticks_major_y=element_line(color=yellow),  # override color=purple\n    axis_ticks_minor=element_line(color=red),\n    axis_ticks_minor_x=element_line(),  # do not override anything\n    axis_ticks_minor_y=element_line(color=gray),  # override color=red\n)\n\n\n\n\n\n\n\n\n\n\naxis_title and axis_ticks_pad\n\np1 + theme(\n    axis_line=element_line(size=0.7, color=gray),\n    axis_ticks=element_line(),\n    axis_title=element_text(),\n    axis_title_x=element_text(color=blue),\n    axis_title_y=element_text(color=red),\n    # The gap between the title and the ticks\n    axis_ticks_pad=20,\n    axis_ticks_pad_major=20,\n    axis_ticks_pad_minor=20,\n)\n\n\n\n\n\n\n\n\n\n\naxis_ticks_direction\n\np1 + theme(\n    axis_line=element_line(size=0.7, color=gray),\n    axis_ticks=element_line(),\n    axis_ticks_direction=\"in\",\n    axis_ticks_direction_x=\"in\",\n    axis_ticks_direction_y=\"out\",\n)\n\n\n\n\n\n\n\n\n\n\nLegend_box\nNot all themeables that affect the legend box are demonstrated\n\n(\n    p1\n    + aes(fill=\"drat\")\n    + theme(\n        legend_position=\"left\",\n        legend_direction=\"horizontal\",  # affected by the ncol=2\n        legend_box_margin=5,\n        legend_background=element_rect(color=purple, size=2, fill=\"white\"),\n        legend_box=\"vertical\",\n        legend_key=element_rect(fill=gray, alpha=0.3),\n        legend_title=element_text(color=orange, va=\"top\"),\n        legend_text=element_text(weight=\"bold\"),\n        legend_key_spacing=10,  # overridden\n        legend_key_spacing_x=15,\n        legend_key_spacing_y=5,\n    )\n    # so we can see legend_entry_spacing in action\n    + guides(color=guide_legend(ncol=2))\n)\n\n\n\n\n\n\n\n\n\n\nplot_background, panel_background and panel_border\n\np2 + theme(\n    plot_background=element_rect(fill=\"gray\", alpha=0.3),\n    panel_background=element_rect(fill=purple, alpha=0.2),\n    panel_border=element_rect(color=red, size=1),\n    panel_spacing=0.025,\n)\n\n\n\n\n\n\n\n\n\n\npanel_grid\n\np1 + theme(\n    panel_grid=element_line(color=purple),\n    panel_grid_major=element_line(size=1.4, alpha=1),\n    panel_grid_major_x=element_line(linetype=\"dashed\"),\n    panel_grid_major_y=element_line(linetype=\"dashdot\"),\n    panel_grid_minor=element_line(alpha=0.25),\n    panel_grid_minor_x=element_line(color=red),\n    panel_grid_minor_y=element_line(color=green),\n    panel_ontop=False,  # puts the points behind the grid\n)\n\n\n\n\n\n\n\n\n\n\nstrip_background, strip_align and strip_text\n\np2 + theme(\n    panel_spacing=0.025,\n    panel_background=element_rect(fill=gray, alpha=0.2),\n    strip_background=element_rect(color=purple, fill=orange, size=1.4, alpha=0.95),\n    strip_background_x=element_rect(x=1 / 6, width=2 / 3),  # you can get really crazy\n    strip_background_y=element_rect(),\n    strip_align=0,\n    strip_align_x=0.2,\n    strip_align_y=0.2,\n    strip_text=element_text(weight=\"bold\"),\n    strip_text_x=element_text(color=red),\n    strip_text_y=element_text(color=blue),\n)\n\n\n\n\n\n\n\n\n\n\naspect_ratio and figure_size\nThe aspect_ratio takes precedence over the figure_size, and it modifies the height. The effective width and height are:\nwidth = figure_size[0]\nheight = figure_size[0] * aspect_ratio\n\np1 + theme(\n    panel_background=element_rect(fill=gray, alpha=0.2),\n    figure_size=(8, 6),  # inches\n    aspect_ratio=1 / 3,  # height:width\n)"
  },
  {
    "objectID": "reference/theme.html#methods",
    "href": "reference/theme.html#methods",
    "title": " plotnine.theme",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nadd_theme\nAdd themes together\n\n\napply\nApply this theme, then apply additional modifications in order.\n\n\nget_margin\nReturn the margin propery of a element_text themeables\n\n\nsetup\nSetup theme for applying\n\n\nto_retina\nReturn a retina-sized version of this theme\n\n\n\n\n add_theme\n\nadd_theme(other)\n\n\nAdd themes together\nSubclasses should not override this method.\nThis will be called when adding two instances of class ‘theme’ together. A complete theme will annihilate any previous themes. Partial themes can be added together and can be added to a complete theme.\n\n\n\n apply\n\napply()\n\n\nApply this theme, then apply additional modifications in order.\nThis method will be called once after plot has completed. Subclasses that override this method should make sure that the base class method is called.\n\n\n\n get_margin\n\nget_margin(name)\n\n\nReturn the margin propery of a element_text themeables\n\n\n\n setup\n\nsetup(plot)\n\n\nSetup theme for applying\nThis method will be called when the figure and axes have been created but before any plotting or other artists have been added to the figure. This method gives the theme and the elements references to the figure and/or axes.\nIt also initialises where the artists to be themed will be stored.\n\n\n\n to_retina\n\nto_retina()\n\n\nReturn a retina-sized version of this theme\nThe result is a theme that has double the dpi."
  },
  {
    "objectID": "reference/svg_usefonts.html",
    "href": "reference/svg_usefonts.html",
    "title": " plotnine.themes.themeable.svg_usefonts",
    "section": "",
    "text": "svg_usefonts(theme_element)"
  },
  {
    "objectID": "reference/svg_usefonts.html#parameters",
    "href": "reference/svg_usefonts.html#parameters",
    "title": " plotnine.themes.themeable.svg_usefonts",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : bool\n\nIf True, assume fonts are installed on the machine where the SVG will be viewed.\nIf False, embed characters as paths; this is supported by most SVG renderers.\nYou should probably set this to True if you intend to edit the svg file."
  },
  {
    "objectID": "reference/strip_text_y.html",
    "href": "reference/strip_text_y.html",
    "title": " plotnine.themes.themeable.strip_text_y",
    "section": "",
    "text": "strip_text_y(theme_element)"
  },
  {
    "objectID": "reference/strip_text_y.html#parameters",
    "href": "reference/strip_text_y.html#parameters",
    "title": " plotnine.themes.themeable.strip_text_y",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/strip_text.html",
    "href": "reference/strip_text.html",
    "title": " plotnine.themes.themeable.strip_text",
    "section": "",
    "text": "strip_text(theme_element)"
  },
  {
    "objectID": "reference/strip_text.html#parameters",
    "href": "reference/strip_text.html#parameters",
    "title": " plotnine.themes.themeable.strip_text",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/strip_background_x.html",
    "href": "reference/strip_background_x.html",
    "title": " plotnine.themes.themeable.strip_background_x",
    "section": "",
    "text": "strip_background_x(theme_element)"
  },
  {
    "objectID": "reference/strip_background_x.html#parameters",
    "href": "reference/strip_background_x.html#parameters",
    "title": " plotnine.themes.themeable.strip_background_x",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_rect"
  },
  {
    "objectID": "reference/strip_align_y.html",
    "href": "reference/strip_align_y.html",
    "title": " plotnine.themes.themeable.strip_align_y",
    "section": "",
    "text": "strip_align_y(theme_element)"
  },
  {
    "objectID": "reference/strip_align_y.html#parameters",
    "href": "reference/strip_align_y.html#parameters",
    "title": " plotnine.themes.themeable.strip_align_y",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nValue as a proportion of the strip size. A good value should be the range [-1, 0.5]. A negative value puts the strip inside the axes. A positive value creates a margin between the strip and the axes. 0 puts the strip exactly beside the panels."
  },
  {
    "objectID": "reference/strip_align.html",
    "href": "reference/strip_align.html",
    "title": " plotnine.themes.themeable.strip_align",
    "section": "",
    "text": "strip_align(theme_element)"
  },
  {
    "objectID": "reference/strip_align.html#parameters",
    "href": "reference/strip_align.html#parameters",
    "title": " plotnine.themes.themeable.strip_align",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nValue as a proportion of the strip text size. A good value should be the range [-1, 0.5]. A negative value puts the strip inside the axes and a positive value creates a space between the strip and the axes."
  },
  {
    "objectID": "reference/stat_unique.html",
    "href": "reference/stat_unique.html",
    "title": " plotnine.stat_unique",
    "section": "",
    "text": "stat_unique(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"point\",\n    position=\"identity\",\n    na_rm=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_unique.html#parameters",
    "href": "reference/stat_unique.html#parameters",
    "title": " plotnine.stat_unique",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\n\n\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"point\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_summary.html",
    "href": "reference/stat_summary.html",
    "title": " plotnine.stat_summary",
    "section": "",
    "text": "stat_summary(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"pointrange\",\n    position=\"identity\",\n    na_rm=False,\n    fun_data=\"mean_cl_boot\",\n    fun_y=None,\n    fun_ymin=None,\n    fun_ymax=None,\n    fun_args=None,\n    random_state=None,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_summary.html#parameters",
    "href": "reference/stat_summary.html#parameters",
    "title": " plotnine.stat_summary",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"ymin\"  # ymin computed by the summary function\n\"ymax\"  # ymax computed by the summary function\n\"n\"     # Number of observations at a position\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('ymin').\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"pointrange\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nfun_data : str | callable = \"mean_cl_boot\"\n\nIf string, it should be one of:\n# Bootstrapped mean, confidence interval\n# Arguments:\n#     n_samples - No. of samples to draw\n#     confidence_interval\n#     random_state\n\"mean_cl_boot\"\n\n# Mean, C.I. assuming normal distribution\n# Arguments:\n#     confidence_interval\n\"mean_cl_normal\"\n\n# Mean, standard deviation * constant\n# Arguments:\n#     mult - multiplication factor\n\"mean_sdl\"\n\n# Median, outlier quantiles with equal tail areas\n# Arguments:\n#     confidence_interval\n\"median_hilow\"\n\n# Mean, Standard Errors * constant\n# Arguments:\n#     mult - multiplication factor\n\"mean_se\"\nor any function that takes a array and returns a dataframe with three columns named y, ymin and ymax.\n\nfun_y : callable = None\n\nAny function that takes a array_like and returns a value\n\nfun_ymin : callable = None\n\nAny function that takes an array_like and returns a value\n\nfun_ymax : callable = None\n\nAny function that takes an array_like and returns a value\n\nfun_args : dict = None\n\nArguments to any of the functions. Provided the names of the arguments of the different functions are in not conflict, the arguments will be assigned to the right functions. If there is a conflict, create a wrapper function that resolves the ambiguity in the argument names.\n\nrandom_state : int | RandomState = None\n\nSeed or Random number generator to use. If None, then numpy global generator numpy.random is used.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_summary.html#notes",
    "href": "reference/stat_summary.html#notes",
    "title": " plotnine.stat_summary",
    "section": "Notes",
    "text": "Notes\nIf any of fun_y, fun_ymin or fun_ymax are provided, the value of fun_data will be ignored."
  },
  {
    "objectID": "reference/stat_summary.html#see-also",
    "href": "reference/stat_summary.html#see-also",
    "title": " plotnine.stat_summary",
    "section": "See Also",
    "text": "See Also\n\ngeom_pointrange"
  },
  {
    "objectID": "reference/stat_smooth.html",
    "href": "reference/stat_smooth.html",
    "title": " plotnine.stat_smooth",
    "section": "",
    "text": "stat_smooth(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"smooth\",\n    position=\"identity\",\n    na_rm=False,\n    method=\"auto\",\n    se=True,\n    n=80,\n    formula=None,\n    fullrange=False,\n    level=0.95,\n    span=0.75,\n    method_args={},\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_smooth.html#parameters",
    "href": "reference/stat_smooth.html#parameters",
    "title": " plotnine.stat_smooth",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"se\"    # Standard error of points in bin\n\"ymin\"  # Lower confidence limit\n\"ymax\"  # Upper confidence limit\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('se').\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"smooth\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nmethod : str | callable = \"auto\"\n\nThe available methods are:\n\"auto\"       # Use loess if (n&lt;1000), glm otherwise\n\"lm\", \"ols\"  # Linear Model\n\"wls\"        # Weighted Linear Model\n\"rlm\"        # Robust Linear Model\n\"glm\"        # Generalized linear Model\n\"gls\"        # Generalized Least Squares\n\"lowess\"     # Locally Weighted Regression (simple)\n\"loess\"      # Locally Weighted Regression\n\"mavg\"       # Moving Average\n\"gpr\"        # Gaussian Process Regressor\nIf a callable is passed, it must have the signature:\ndef my_smoother(data, xseq, **params):\n    # * data - has the x and y values for the model\n    # * xseq - x values to be predicted\n    # * params - stat parameters\n    #\n    # It must return a new dataframe. Below is the\n    # template used internally by Plotnine\n\n    # Input data into the model\n    x, y = data[\"x\"], data[\"y\"]\n\n    # Create and fit a model\n    model = Model(x, y)\n    results = Model.fit()\n\n    # Create output data by getting predictions on\n    # the xseq values\n    data = pd.DataFrame({\n        \"x\": xseq,\n        \"y\": results.predict(xseq)})\n\n    # Compute confidence intervals, this depends on\n    # the model. However, given standard errors and the\n    # degrees of freedom we can compute the confidence\n    # intervals using the t-distribution.\n    #\n    # For an alternative, implement confidence intervals by\n    # the bootstrap method\n    if params[\"se\"]:\n        from plotnine.utils.smoothers import tdist_ci\n        y = data[\"y\"]            # The predicted value\n        df = 123                 # Degrees of freedom\n        stderr = results.stderr  # Standard error\n        level = params[\"level\"]  # The parameter value\n        low, high = tdist_ci(y, df, stderr, level)\n        data[\"se\"] = stderr\n        data[\"ymin\"] = low\n        data[\"ymax\"] = high\n\n    return data\nFor loess smoothing you must install the scikit-misc package. You can install it using with pip install scikit-misc or pip install plotnine[all].\n\nformula : formula_like = None\n\nAn object that can be used to construct a patsy design matrix. This is usually a string. You can only use a formula if method is one of lm, ols, wls, glm, rlm or gls, and in the formula you may refer to the x and y aesthetic variables.\n\nse : bool = True\n\nIf True draw confidence interval around the smooth line.\n\nn : int = 80\n\nNumber of points to evaluate the smoother at. Some smoothers like mavg do not support this.\n\nfullrange : bool = False\n\nIf True the fit will span the full range of the plot.\n\nlevel : float = 0.95\n\nLevel of confidence to use if se=True.\n\nspan : float = 2/3.\n\nControls the amount of smoothing for the loess smoother. Larger number means more smoothing. It should be in the (0, 1) range.\n\nmethod_args : dict = {}\n\nAdditional arguments passed on to the modelling method.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_smooth.html#see-also",
    "href": "reference/stat_smooth.html#see-also",
    "title": " plotnine.stat_smooth",
    "section": "See Also",
    "text": "See Also\n\nOLS\n\n\n\nWLS\n\n\n\nRLM\n\n\n\nGLM\n\n\n\nGLS\n\n\n\nlowess\n\n\n\nloess\n\n\n\nrolling\n\n\n\nGaussianProcessRegressor"
  },
  {
    "objectID": "reference/stat_smooth.html#notes",
    "href": "reference/stat_smooth.html#notes",
    "title": " plotnine.stat_smooth",
    "section": "Notes",
    "text": "Notes\ngeom_smooth and stat_smooth are effectively aliases, they both use the same arguments. Use geom_smooth unless you want to display the results with a non-standard geom."
  },
  {
    "objectID": "reference/stat_quantile.html",
    "href": "reference/stat_quantile.html",
    "title": " plotnine.stat_quantile",
    "section": "",
    "text": "stat_quantile(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"quantile\",\n    position=\"identity\",\n    na_rm=False,\n    quantiles=(0.25, 0.5, 0.75),\n    formula=\"y ~ x\",\n    method_args={},\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_quantile.html#parameters",
    "href": "reference/stat_quantile.html#parameters",
    "title": " plotnine.stat_quantile",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"quantile\"  # quantile\n\"group\"     # group identifier\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('quantile').\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"quantile\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nquantiles : tuple = (0.25, 0.5, 0.75)\n\nQuantiles of y to compute\n\nformula : str = \"y ~ x\"\n\nFormula relating y variables to x variables\n\nmethod_args : dict = None\n\nExtra arguments passed on to the model fitting method, fit.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_quantile.html#see-also",
    "href": "reference/stat_quantile.html#see-also",
    "title": " plotnine.stat_quantile",
    "section": "See Also",
    "text": "See Also\n\nQuantReg\n\n\n\ngeom_quantile"
  },
  {
    "objectID": "reference/stat_qq.html",
    "href": "reference/stat_qq.html",
    "title": " plotnine.stat_qq",
    "section": "",
    "text": "stat_qq(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"qq\",\n    position=\"identity\",\n    na_rm=False,\n    distribution=\"norm\",\n    dparams={},\n    quantiles=None,\n    alpha_beta=(0.375, 0.375),\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_qq.html#parameters",
    "href": "reference/stat_qq.html#parameters",
    "title": " plotnine.stat_qq",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nsample\n\n\n\nx\nafter_stat('theoretical')\n\n\ny\nafter_stat('sample')\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n'theoretical'  # theoretical quantiles\n'sample'       # sample quantiles\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"qq\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ndistribution : str = \"norm\"\n\nDistribution or distribution function name. The default is norm for a normal probability plot. Objects that look enough like a stats.distributions instance (i.e. they have a ppf method) are also accepted. See scipy stats for available distributions.\n\ndparams : dict = None\n\nDistribution-specific shape parameters (shape parameters plus location and scale).\n\nquantiles : array_like = None\n\nProbability points at which to calculate the theoretical quantile values. If provided, must be the same number as as the sample data points. The default is to use calculated theoretical points, use to alpha_beta control how these points are generated.\n\nalpha_beta : tuple = (3/8, 3/8)\n\nParameter values to use when calculating the quantiles.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_qq.html#see-also",
    "href": "reference/stat_qq.html#see-also",
    "title": " plotnine.stat_qq",
    "section": "See Also",
    "text": "See Also\n\nplotting_positions\n\nUses alpha_beta to calculate the quantiles."
  },
  {
    "objectID": "reference/stat_hull.html",
    "href": "reference/stat_hull.html",
    "title": " plotnine.stat_hull",
    "section": "",
    "text": "stat_hull(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"path\",\n    position=\"identity\",\n    na_rm=False,\n    qhull_options=None,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_hull.html#parameters",
    "href": "reference/stat_hull.html#parameters",
    "title": " plotnine.stat_hull",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"area\"  # Area of the convex hull\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"path\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nqhull_options\n\nAdditional options to pass to Qhull. See Qhull &lt;http://www.qhull.org/&gt;__ documentation for details.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_hull.html#raises",
    "href": "reference/stat_hull.html#raises",
    "title": " plotnine.stat_hull",
    "section": "Raises",
    "text": "Raises\n\n\nscipy.spatial.QhullError\n\nRaised when Qhull encounters an error condition, such as geometrical degeneracy when options to resolve are not enabled."
  },
  {
    "objectID": "reference/stat_ellipse.html",
    "href": "reference/stat_ellipse.html",
    "title": " plotnine.stat_ellipse",
    "section": "",
    "text": "stat_ellipse(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"path\",\n    position=\"identity\",\n    na_rm=False,\n    type=\"t\",\n    level=0.95,\n    segments=51,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_ellipse.html#parameters",
    "href": "reference/stat_ellipse.html#parameters",
    "title": " plotnine.stat_ellipse",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"path\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ntype : Literal[\"t\", \"norm\", \"euclid\"] = \"t\"\n\nThe type of ellipse. t assumes a multivariate t-distribution. norm assumes a multivariate normal distribution. euclid draws a circle with the radius equal to level, representing the euclidean distance from the center.\n\nlevel : float = 0.95\n\nThe confidence level at which to draw the ellipse.\n\nsegments : int = 51\n\nNumber of segments to be used in drawing the ellipse.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_density_2d.html",
    "href": "reference/stat_density_2d.html",
    "title": " plotnine.stat_density_2d",
    "section": "",
    "text": "stat_density_2d(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"density_2d\",\n    position=\"identity\",\n    na_rm=False,\n    contour=True,\n    package=\"statsmodels\",\n    kde_params=None,\n    n=64,\n    levels=5,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_density_2d.html#parameters",
    "href": "reference/stat_density_2d.html#parameters",
    "title": " plotnine.stat_density_2d",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"level\"     # density level of a contour\n\"density\"   # Computed density at a point\n\"piece\"     # Numeric id of a contour in a given group\nlevel is only relevant when contours are computed. density is available only when no contours are computed. piece is largely irrelevant.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"density_2d\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ncontour : bool = True\n\nWhether to create contours of the 2d density estimate.\n\nn : int = 64\n\nNumber of equally spaced points at which the density is to be estimated. For efficient computation, it should be a power of two.\n\nlevels : int | array_like = 5\n\nContour levels. If an integer, it specifies the maximum number of levels, if array_like it is the levels themselves.\n\npackage : Literal[statsmodels, scipy, sklearn] = \"statsmodels\"\n\nPackage whose kernel density estimation to use.\n\nkde_params : dict\n\nKeyword arguments to pass on to the kde class.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_density_2d.html#see-also",
    "href": "reference/stat_density_2d.html#see-also",
    "title": " plotnine.stat_density_2d",
    "section": "See Also",
    "text": "See Also\n\nKDEMultivariate\n\n\n\ngaussian_kde\n\n\n\nKernelDensity"
  },
  {
    "objectID": "reference/stat_count.html",
    "href": "reference/stat_count.html",
    "title": " plotnine.stat_count",
    "section": "",
    "text": "stat_count(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"histogram\",\n    position=\"stack\",\n    na_rm=False,\n    width=None,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_count.html#parameters",
    "href": "reference/stat_count.html#parameters",
    "title": " plotnine.stat_count",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\nafter_stat('count')\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"count\"  # Number of observations at a position\n\"prop\"   # Ratio of points in the panel at a position\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"histogram\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"stack\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nwidth : float = None\n\nBar width. If None, set to 90% of the resolution of the data.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_count.html#see-also",
    "href": "reference/stat_count.html#see-also",
    "title": " plotnine.stat_count",
    "section": "See Also",
    "text": "See Also\n\nstat_bin"
  },
  {
    "objectID": "reference/stat_bindot.html",
    "href": "reference/stat_bindot.html",
    "title": " plotnine.stat_bindot",
    "section": "",
    "text": "stat_bindot(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"dotplot\",\n    position=\"identity\",\n    na_rm=False,\n    bins=None,\n    binwidth=None,\n    origin=None,\n    width=0.9,\n    binaxis=\"x\",\n    method=\"dotdensity\",\n    binpositions=\"bygroup\",\n    drop=False,\n    right=True,\n    breaks=None,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_bindot.html#parameters",
    "href": "reference/stat_bindot.html#parameters",
    "title": " plotnine.stat_bindot",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\nafter_stat('count')\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"count\"    # number of points in bin\n\"density\"  # density of points in bin, scaled to integrate to 1\n\"ncount\"   # count, scaled to maximum of 1\n\"ndensity\" # density, scaled to maximum of 1\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"dotplot\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nbins : int = None\n\nNumber of bins. Overridden by binwidth. If None, a number is computed using the freedman-diaconis method.\n\nbinwidth : float = None\n\nWhen method=\"dotdensity\", this specifies the maximum binwidth. When method=\"histodot\", this specifies the binwidth. This supersedes the bins.\n\norigin : float = None\n\nWhen method=\"histodot\", origin of the first bin.\n\nwidth : float = 0.9\n\nWhen binaxis=\"y\", the spacing of the dotstacks for dodging.\n\nbinaxis : Literal[\"x\", \"y\"] = \"x\"\n\nAxis to bin along.\n\nmethod : Literal[\"dotdensity\", \"histodot\"] = \"dotdensity\"\n\nWhether to do dot-density binning or fixed widths binning.\n\nbinpositions : Literal[\"all\", \"bygroup\"] = \"bygroup\"\n\nPosition of the bins when method=\"dotdensity\". The value - bygroup - positions of the bins for each group are determined separately. - all - positions of the bins are determined with all data taken together. This aligns the dots stacks across multiple groups.\n\ndrop : bool = False\n\nIf True, remove all bins with zero counts.\n\nright : bool = True\n\nWhen method=\"histodot\", True means include right edge of the bins and if False the left edge is included.\n\nbreaks : FloatArray = None\n\nBin boundaries for method=\"histodot\". This supersedes the binwidth and bins.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_bindot.html#see-also",
    "href": "reference/stat_bindot.html#see-also",
    "title": " plotnine.stat_bindot",
    "section": "See Also",
    "text": "See Also\n\nstat_bin"
  },
  {
    "objectID": "reference/stat_bin.html",
    "href": "reference/stat_bin.html",
    "title": " plotnine.stat_bin",
    "section": "",
    "text": "stat_bin(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"histogram\",\n    position=\"stack\",\n    na_rm=False,\n    binwidth=None,\n    bins=None,\n    breaks=None,\n    center=None,\n    boundary=None,\n    closed=\"right\",\n    pad=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_bin.html#parameters",
    "href": "reference/stat_bin.html#parameters",
    "title": " plotnine.stat_bin",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\nweight\nNone\n\n\ny\nafter_stat('count')\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"count\"    # number of points in bin\n\"density\"  # density of points in bin, scaled to integrate to 1\n\"ncount\"   # count, scaled to maximum of 1\n\"ndensity\" # density, scaled to maximum of 1\n\"ngroup\"   # number of points in group\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"histogram\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"stack\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nbinwidth : float = None\n\nThe width of the bins. The default is to use bins bins that cover the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data.\n\nbins : int = None\n\nNumber of bins. Overridden by binwidth. If None, a number is computed using the freedman-diaconis method.\n\nbreaks : array_like = None\n\nBin boundaries. This supersedes the binwidth, bins, center and boundary.\n\ncenter : float = None\n\nThe center of one of the bins. Note that if center is above or below the range of the data, things will be shifted by an appropriate number of widths. To center on integers, for example, use width=1 and center=0, even if 0 i s outside the range of the data. At most one of center and boundary may be specified.\n\nboundary : float = None\n\nA boundary between two bins. As with center, things are shifted when boundary is outside the range of the data. For example, to center on integers, use width=1 and boundary=0.5, even if 1 is outside the range of the data. At most one of center and boundary may be specified.\n\nclosed : Literal[left, right] = \"right\"\n\nWhich edge of the bins is included.\n\npad : bool = False\n\nIf True, adds empty bins at either side of x. This ensures that frequency polygons touch 0.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stage.html",
    "href": "reference/stage.html",
    "title": " plotnine.stage",
    "section": "",
    "text": "stage(start=None, after_stat=None, after_scale=None)"
  },
  {
    "objectID": "reference/stage.html#parameters",
    "href": "reference/stage.html#parameters",
    "title": " plotnine.stage",
    "section": "Parameters",
    "text": "Parameters\n\n\nstart : str | array_like | scalar = None\n\nAesthetic expression using primary variables from the layer data.\n\nafter_stat : str = None\n\nAesthetic expression using variables calculated by the stat.\n\nafter_scale : str = None\n\nAesthetic expression using aesthetics of the layer."
  },
  {
    "objectID": "reference/stage.html#examples",
    "href": "reference/stage.html#examples",
    "title": " plotnine.stage",
    "section": "Examples",
    "text": "Examples\n\n\n%load_ext autoreload\n%autoreload 2\n%aimport plotnine\n\nimport pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    after_stat,\n    stage,\n    geom_bar,\n    geom_text,\n    geom_bin_2d,\n    stat_bin_2d,\n)\n\n\nstage\n\ndf = pd.DataFrame({\n    \"var1\": list(\"abbcccddddeeeee\"),\n    \"cat\": list(\"RSRSRSRRRSRSSRS\")\n})\n\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar()\n)\n\n\n\n\n\n\n\n\nAdd the corresponding count on top of each bar.\n\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar()\n    + geom_text(aes(label=after_stat(\"count\")), stat=\"count\")\n)\n\n\n\n\n\n\n\n\nAdjust the y position so that the counts do not overlap the bars.\n\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"count\"), y=stage(after_stat=\"count\", after_scale=\"y+.1\")),\n        stat=\"count\",\n    )\n)\n\n\n\n\n\n\n\n\nNote that this will work even nicely for stacked bars where adjustig the position with nudge_y=0.1 would not.\n\n(\n    ggplot(df, aes(\"var1\", fill=\"cat\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"count\"), y=stage(after_stat=\"count\", after_scale=\"y+.1\")),\n        stat=\"count\",\n        position=\"stack\",\n    )\n)\n\n\n\n\n\n\n\n\n\n\nCreate a binned 2d plot with counts\n\nnp.random.seed(123)\ndf = pd.DataFrame({\n    \"col_1\": np.random.rand(1000),\n    \"col_2\": np.random.rand(1000)\n})\n\n\n(\n    ggplot(df, aes(x=\"col_1\", y=\"col_2\"))\n    + geom_bin_2d(position=\"identity\", binwidth=0.1)\n)\n\n\n\n\n\n\n\n\nAdd counts to the bins. stat_bin_2d bins are specified using retangular minimum and maximum end-points for dimension; we use these values to compute the mid-points at which to place the counts.\nFirst x and y aesthetics are mapped to col_1 and col_2 variables, then after the statistic consumes them and creates xmin, xmax, ymin & ymax values for each bin along with associated count. After the statistic computation the x and y aesthetics do not exist, but we create meaningful values using the minimum and maximum end-points.\nNote that the binning parameters for the geom and stat combination must be the same. In this case it is the binwidth.\n\n(\n    ggplot(df, aes(x=\"col_1\", y=\"col_2\"))\n    + geom_bin_2d(position=\"identity\", binwidth=0.1)\n    + stat_bin_2d(\n        aes(\n            x=stage(start=\"col_1\", after_stat=\"(xmin+xmax)/2\"),\n            y=stage(start=\"col_2\", after_stat=\"(ymin+ymax)/2\"),\n            label=after_stat(\"count\"),\n        ),\n        binwidth=0.1,\n        geom=\"text\",\n        format_string=\"{:.0f}\",\n        size=10,\n    )\n)\n\n\n\n\n\n\n\n\n\nSource: stage"
  },
  {
    "objectID": "reference/stage.html#create-a-binned-2d-plot-with-counts",
    "href": "reference/stage.html#create-a-binned-2d-plot-with-counts",
    "title": " plotnine.stage",
    "section": "Create a binned 2d plot with counts",
    "text": "Create a binned 2d plot with counts\n\nnp.random.seed(123)\ndf = pd.DataFrame({\n    \"col_1\": np.random.rand(1000),\n    \"col_2\": np.random.rand(1000)\n})\n\n\n(\n    ggplot(df, aes(x=\"col_1\", y=\"col_2\"))\n    + geom_bin_2d(position=\"identity\", binwidth=0.1)\n)\n\n\n\n\n\n\n\n\nAdd counts to the bins. stat_bin_2d bins are specified using retangular minimum and maximum end-points for dimension; we use these values to compute the mid-points at which to place the counts.\nFirst x and y aesthetics are mapped to col_1 and col_2 variables, then after the statistic consumes them and creates xmin, xmax, ymin & ymax values for each bin along with associated count. After the statistic computation the x and y aesthetics do not exist, but we create meaningful values using the minimum and maximum end-points.\nNote that the binning parameters for the geom and stat combination must be the same. In this case it is the binwidth.\n\n(\n    ggplot(df, aes(x=\"col_1\", y=\"col_2\"))\n    + geom_bin_2d(position=\"identity\", binwidth=0.1)\n    + stat_bin_2d(\n        aes(\n            x=stage(start=\"col_1\", after_stat=\"(xmin+xmax)/2\"),\n            y=stage(start=\"col_2\", after_stat=\"(ymin+ymax)/2\"),\n            label=after_stat(\"count\"),\n        ),\n        binwidth=0.1,\n        geom=\"text\",\n        format_string=\"{:.0f}\",\n        size=10,\n    )\n)"
  },
  {
    "objectID": "reference/seals.html",
    "href": "reference/seals.html",
    "title": " plotnine.data.seals",
    "section": "",
    "text": "seals = pd.read_csv(DATA_DIR / \"seals.csv\")"
  },
  {
    "objectID": "reference/seals.html#description",
    "href": "reference/seals.html#description",
    "title": " plotnine.data.seals",
    "section": "Description",
    "text": "Description\nThis vector field was produced from the data described in Brillinger, D.R., Preisler, H.K., Ager, A.A. and Kie, J.G. “An exploratory data analysis (EDA) of the paths of moving animals”. J. Statistical Planning and Inference 122 (2004), 43-63, using the methods of Brillinger, D.R., “Learning a potential function from a trajectory”, Signal Processing Letters. December (2007)."
  },
  {
    "objectID": "reference/seals.html#format",
    "href": "reference/seals.html#format",
    "title": " plotnine.data.seals",
    "section": "Format",
    "text": "Format\nA data frame with 1155 rows and 4 variables\n\n\n\nColumn\nDescription\n\n\n\n\nlat\nLatitude\n\n\nlong\nLongitude\n\n\ndelta_long\nChange in Longitude\n\n\ndelta_lat\nChange in Latitude"
  },
  {
    "objectID": "reference/seals.html#references",
    "href": "reference/seals.html#references",
    "title": " plotnine.data.seals",
    "section": "References",
    "text": "References\nhttp://www.stat.berkeley.edu/~brill/Papers/jspifinal.pdf"
  },
  {
    "objectID": "reference/scale_y_timedelta.html",
    "href": "reference/scale_y_timedelta.html",
    "title": " plotnine.scale_y_timedelta",
    "section": "",
    "text": "scale_y_timedelta(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"pd_timedelta\"\n)"
  },
  {
    "objectID": "reference/scale_y_timedelta.html#parameter-attributes",
    "href": "reference/scale_y_timedelta.html#parameter-attributes",
    "title": " plotnine.scale_y_timedelta",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: None = None\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"pd_timedelta\""
  },
  {
    "objectID": "reference/scale_y_sqrt.html",
    "href": "reference/scale_y_sqrt.html",
    "title": " plotnine.scale_y_sqrt",
    "section": "",
    "text": "scale_y_sqrt(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"sqrt\"\n)"
  },
  {
    "objectID": "reference/scale_y_sqrt.html#parameter-attributes",
    "href": "reference/scale_y_sqrt.html#parameter-attributes",
    "title": " plotnine.scale_y_sqrt",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: None = None\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"sqrt\""
  },
  {
    "objectID": "reference/scale_y_log10.html",
    "href": "reference/scale_y_log10.html",
    "title": " plotnine.scale_y_log10",
    "section": "",
    "text": "scale_y_log10(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"log10\"\n)"
  },
  {
    "objectID": "reference/scale_y_log10.html#parameter-attributes",
    "href": "reference/scale_y_log10.html#parameter-attributes",
    "title": " plotnine.scale_y_log10",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: None = None\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"log10\""
  },
  {
    "objectID": "reference/scale_y_datetime.html",
    "href": "reference/scale_y_datetime.html",
    "title": " plotnine.scale_y_datetime",
    "section": "",
    "text": "scale_y_datetime(\n    date_breaks=None,\n    date_labels=None,\n    date_minor_breaks=None,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"datetime\"\n)"
  },
  {
    "objectID": "reference/scale_y_datetime.html#init-parameters",
    "href": "reference/scale_y_datetime.html#init-parameters",
    "title": " plotnine.scale_y_datetime",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ndate_breaks: str | None = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str | None = None\n\nFormat string for the labels. See strftime. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str | None = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks."
  },
  {
    "objectID": "reference/scale_y_datetime.html#parameter-attributes",
    "href": "reference/scale_y_datetime.html#parameter-attributes",
    "title": " plotnine.scale_y_datetime",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: ( # pyright: ignore[reportIncompatibleVariableOverride]    tuple[float, timedelta]    | tuple[float, timedelta, float, timedelta]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, timedelta(0)) - Do not expand.\n(0, timedelta(days=1)) - Expand lower and upper limits by 1 day.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, timedelta(hours=6)) - Expand upper limit by 6 hours.\n(0, timedelta(minutes=5), 0.1, timdelta(0)) - Expand lower limit by 5 minutes and upper limit by 10%.\n(0, 0, 0.1, timedelta(weeks=2)) - Expand upper limit by 10% plus 2 weeks.\n\nIf not specified, suitable defaults are chosen.\n\nguide: None = None\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"datetime\""
  },
  {
    "objectID": "reference/scale_y_continuous.html",
    "href": "reference/scale_y_continuous.html",
    "title": " plotnine.scale_y_continuous",
    "section": "",
    "text": "scale_y_continuous(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_y_continuous.html#parameter-attributes",
    "href": "reference/scale_y_continuous.html#parameter-attributes",
    "title": " plotnine.scale_y_continuous",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: None = None\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_x_symlog.html",
    "href": "reference/scale_x_symlog.html",
    "title": " plotnine.scale_x_symlog",
    "section": "",
    "text": "scale_x_symlog(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"symlog\"\n)"
  },
  {
    "objectID": "reference/scale_x_symlog.html#parameter-attributes",
    "href": "reference/scale_x_symlog.html#parameter-attributes",
    "title": " plotnine.scale_x_symlog",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: None = None\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"symlog\""
  },
  {
    "objectID": "reference/scale_x_reverse.html",
    "href": "reference/scale_x_reverse.html",
    "title": " plotnine.scale_x_reverse",
    "section": "",
    "text": "scale_x_reverse(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"reverse\"\n)"
  },
  {
    "objectID": "reference/scale_x_reverse.html#parameter-attributes",
    "href": "reference/scale_x_reverse.html#parameter-attributes",
    "title": " plotnine.scale_x_reverse",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: None = None\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"reverse\""
  },
  {
    "objectID": "reference/scale_x_discrete.html",
    "href": "reference/scale_x_discrete.html",
    "title": " plotnine.scale_x_discrete",
    "section": "",
    "text": "scale_x_discrete(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_x_discrete.html#parameter-attributes",
    "href": "reference/scale_x_discrete.html#parameter-attributes",
    "title": " plotnine.scale_x_discrete",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_x_date.html",
    "href": "reference/scale_x_date.html",
    "title": " plotnine.scale_x_date",
    "section": "",
    "text": "scale_x_date(\n    date_breaks=None,\n    date_labels=None,\n    date_minor_breaks=None,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"datetime\"\n)"
  },
  {
    "objectID": "reference/scale_x_date.html#init-parameters",
    "href": "reference/scale_x_date.html#init-parameters",
    "title": " plotnine.scale_x_date",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ndate_breaks: str | None = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str | None = None\n\nFormat string for the labels. See strftime. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str | None = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks."
  },
  {
    "objectID": "reference/scale_x_date.html#parameter-attributes",
    "href": "reference/scale_x_date.html#parameter-attributes",
    "title": " plotnine.scale_x_date",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: ( # pyright: ignore[reportIncompatibleVariableOverride]    tuple[float, timedelta]    | tuple[float, timedelta, float, timedelta]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, timedelta(0)) - Do not expand.\n(0, timedelta(days=1)) - Expand lower and upper limits by 1 day.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, timedelta(hours=6)) - Expand upper limit by 6 hours.\n(0, timedelta(minutes=5), 0.1, timdelta(0)) - Expand lower limit by 5 minutes and upper limit by 10%.\n(0, 0, 0.1, timedelta(weeks=2)) - Expand upper limit by 10% plus 2 weeks.\n\nIf not specified, suitable defaults are chosen.\n\nguide: None = None\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"datetime\""
  },
  {
    "objectID": "reference/scale_stroke_continuous.html",
    "href": "reference/scale_stroke_continuous.html",
    "title": " plotnine.scale_stroke_continuous",
    "section": "",
    "text": "scale_stroke_continuous(\n    range=(1, 6),\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_stroke_continuous.html#init-parameters",
    "href": "reference/scale_stroke_continuous.html#init-parameters",
    "title": " plotnine.scale_stroke_continuous",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nrange: tuple[float, float] = (1, 6)\n\nRange ([Minimum, Maximum]) of output stroke values. Should be between 0 and 1."
  },
  {
    "objectID": "reference/scale_stroke_continuous.html#parameter-attributes",
    "href": "reference/scale_stroke_continuous.html#parameter-attributes",
    "title": " plotnine.scale_stroke_continuous",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_size_radius.html",
    "href": "reference/scale_size_radius.html",
    "title": " plotnine.scale_size_radius",
    "section": "",
    "text": "scale_size_radius(\n    range=(1, 6),\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_size_radius.html#init-parameters",
    "href": "reference/scale_size_radius.html#init-parameters",
    "title": " plotnine.scale_size_radius",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nrange: tuple[float, float] = (1, 6)\n\nRange ([Minimum, Maximum]) of the size."
  },
  {
    "objectID": "reference/scale_size_radius.html#parameter-attributes",
    "href": "reference/scale_size_radius.html#parameter-attributes",
    "title": " plotnine.scale_size_radius",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_size_manual.html",
    "href": "reference/scale_size_manual.html",
    "title": " plotnine.scale_size_manual",
    "section": "",
    "text": "scale_size_manual(\n    values,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_size_manual.html#init-parameters",
    "href": "reference/scale_size_manual.html#init-parameters",
    "title": " plotnine.scale_size_manual",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nvalues: Sequence[Any] | dict[Any, Any] \n\nSizes that make up the palette. The values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to sizes."
  },
  {
    "objectID": "reference/scale_size_manual.html#parameter-attributes",
    "href": "reference/scale_size_manual.html#parameter-attributes",
    "title": " plotnine.scale_size_manual",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_size_discrete.html",
    "href": "reference/scale_size_discrete.html",
    "title": " plotnine.scale_size_discrete",
    "section": "",
    "text": "scale_size_discrete(\n    range=(2, 6),\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_size_discrete.html#init-parameters",
    "href": "reference/scale_size_discrete.html#init-parameters",
    "title": " plotnine.scale_size_discrete",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nrange: tuple[float, float] = (2, 6)\n\nRange ([Minimum, Maximum]) of the size."
  },
  {
    "objectID": "reference/scale_size_discrete.html#parameter-attributes",
    "href": "reference/scale_size_discrete.html#parameter-attributes",
    "title": " plotnine.scale_size_discrete",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_size_continuous.html",
    "href": "reference/scale_size_continuous.html",
    "title": " plotnine.scale_size_continuous",
    "section": "",
    "text": "scale_size_continuous(\n    range=(1, 6),\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_size_continuous.html#init-parameters",
    "href": "reference/scale_size_continuous.html#init-parameters",
    "title": " plotnine.scale_size_continuous",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nrange: tuple[float, float] = (1, 6)\n\nRange ([Minimum, Maximum]) of the size."
  },
  {
    "objectID": "reference/scale_size_continuous.html#parameter-attributes",
    "href": "reference/scale_size_continuous.html#parameter-attributes",
    "title": " plotnine.scale_size_continuous",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_size.html",
    "href": "reference/scale_size.html",
    "title": " plotnine.scale_size",
    "section": "",
    "text": "scale_size(\n    range=(1, 6),\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_size.html#init-parameters",
    "href": "reference/scale_size.html#init-parameters",
    "title": " plotnine.scale_size",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nrange: tuple[float, float] = (1, 6)\n\nRange ([Minimum, Maximum]) of the size."
  },
  {
    "objectID": "reference/scale_size.html#parameter-attributes",
    "href": "reference/scale_size.html#parameter-attributes",
    "title": " plotnine.scale_size",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_shape_identity.html",
    "href": "reference/scale_shape_identity.html",
    "title": " plotnine.scale_shape_identity",
    "section": "",
    "text": "scale_shape_identity(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_shape_identity.html#parameter-attributes",
    "href": "reference/scale_shape_identity.html#parameter-attributes",
    "title": " plotnine.scale_shape_identity",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = None\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_shape_identity.html#examples",
    "href": "reference/scale_shape_identity.html#examples",
    "title": " plotnine.scale_shape_identity",
    "section": "Examples",
    "text": "Examples\n\n\nfrom plotnine import (\n    aes,\n    annotate,\n    coord_equal,\n    element_rect,\n    element_text,\n    facet_wrap,\n    geom_point,\n    geom_segment,\n    geom_text,\n    geom_tile,\n    ggplot,\n    lims,\n    scale_shape_identity,\n    theme,\n    theme_void,\n)\n\nimport polars as pl\nimport numpy as np\n\n\nScatter Plot Shapes\nList the shapes and prepare dataframe with what is required to display them.\n\nfilled_shapes = (\n    \"o\",  # circle\n    \"^\",  # triangle up\n    \"s\",  # square\n    \"D\",  # Diamond\n    \"v\",  # triangle down\n    \"*\",  # star\n    \"p\",  # pentagon\n    \"8\",  # octagon\n    \"&lt;\",  # triangle left\n    \"h\",  # hexagon1\n    \"&gt;\",  # triangle right\n    \"H\",  # hexagon1\n    \"d\",  # thin diamond\n)\n\nunfilled_shapes = (\n    \"+\",  # plus\n    \"x\",  # x\n    \".\",  # point\n    \"1\",  # tri_down\n    \"2\",  # tri_up\n    \"3\",  # tri_left\n    \"4\",  # tri_right\n    \",\",  # pixel\n    \"_\",  # hline\n    \"|\",  # vline\n    0,  # tickleft\n    1,  # tickright\n    2,  # tickup\n    3,  # tickdown\n    4,  # caretleft\n    5,  # caretright\n    6,  # caretup\n    7,  # caretdown\n)\n\nn1 = len(filled_shapes)\nn2 = len(unfilled_shapes)\nncols = 10\nshapes = filled_shapes + unfilled_shapes\n\ndf = pl.DataFrame({\n    \"x\": np.hstack([np.arange(n1) % ncols, np.arange(n2) % ncols]),\n    \"y\": 4 - 1.5 * np.hstack([np.arange(n1) // ncols, np.arange(n2) // ncols]),\n    \"shape\": pl.Series(shapes, dtype=object),\n    \"shape_kind\": np.repeat([\"Filled Shapes\", \"Unfilled Shapes\"], (n1, n2))\n})\n\ndf\n\n\nshape: (31, 4)\n\n\n\nx\ny\nshape\nshape_kind\n\n\ni64\nf64\nobject\nstr\n\n\n\n\n0\n4.0\no\n\"Filled Shapes\"\n\n\n1\n4.0\n^\n\"Filled Shapes\"\n\n\n2\n4.0\ns\n\"Filled Shapes\"\n\n\n3\n4.0\nD\n\"Filled Shapes\"\n\n\n4\n4.0\nv\n\"Filled Shapes\"\n\n\n…\n…\n…\n…\n\n\n3\n2.5\n3\n\"Unfilled Shapes\"\n\n\n4\n2.5\n4\n\"Unfilled Shapes\"\n\n\n5\n2.5\n5\n\"Unfilled Shapes\"\n\n\n6\n2.5\n6\n\"Unfilled Shapes\"\n\n\n7\n2.5\n7\n\"Unfilled Shapes\"\n\n\n\n\n\n\n\n# Gallery, points\n\ndef double_quote_strings(series):\n    return [\n        '\"{}\"'.format(s) if isinstance(s, str) else \"{}\".format(s)\n        for s in series\n    ]\n\n(\n    ggplot(df, aes(\"x\", \"y\"))\n    \n    # Background\n    + geom_tile(aes(width=0.9, height=0.9), fill=\"#F8F8F8\")\n    \n    # Cross-grid to help see the centering of the shapes\n    + geom_segment(aes(x=\"x-0.45\", xend=\"x+0.45\", yend=\"y\"), color=\"Crimson\", alpha=0.05)\n    + geom_segment(aes(xend=\"x\", y=\"y-0.45\", yend=\"y+0.45\"), color=\"Crimson\", alpha=0.05)\n    \n    # The shape\n    + geom_point(aes(shape=\"shape\"), fill=\"#E5C8D6\", size=8)\n\n    # Specification value for the shape\n    + geom_text(\n        aes(y=\"y+.5\", label=\"double_quote_strings(shape)\"),\n        color=\"darkblue\",\n        va=\"bottom\",\n    )\n\n    # Separate the shapes by their kind\n    + facet_wrap(\"shape_kind\", ncol=1)\n\n    # Make things pretty\n    + lims(y=(2, 5))\n    + scale_shape_identity()\n    + coord_equal()\n    + theme_void()\n    + theme(\n        plot_background=element_rect(fill=\"white\"),\n        strip_text=element_text(size=12)\n    )\n)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nFile ~/.uvenv/plotnine/lib/python3.13/site-packages/IPython/core/formatters.py:984, in IPythonDisplayFormatter.__call__(self, obj)\n    982 method = get_real_method(obj, self.print_method)\n    983 if method is not None:\n--&gt; 984     method()\n    985     return True\n\nFile ~/scm/python/plotnine/plotnine/ggplot.py:149, in ggplot._ipython_display_(self)\n    142 def _ipython_display_(self):\n    143     \"\"\"\n    144     Display plot in the output of the cell\n    145 \n    146     This method will always be called when a ggplot object is the\n    147     last in the cell.\n    148     \"\"\"\n--&gt; 149     self._display()\n\nFile ~/scm/python/plotnine/plotnine/ggplot.py:190, in ggplot._display(self)\n    187     self.theme = self.theme.to_retina()\n    189 buf = BytesIO()\n--&gt; 190 self.save(buf, \"png\" if format == \"retina\" else format, verbose=False)\n    191 figure_size_px = self.theme._figure_size_px\n    192 display_func = get_display_function(format, figure_size_px)\n\nFile ~/scm/python/plotnine/plotnine/ggplot.py:702, in ggplot.save(self, filename, format, path, width, height, units, dpi, limitsize, verbose, **kwargs)\n    653 def save(\n    654     self,\n    655     filename: Optional[str | Path | BytesIO] = None,\n   (...)    664     **kwargs: Any,\n    665 ):\n    666     \"\"\"\n    667     Save a ggplot object as an image file\n    668 \n   (...)    700         Additional arguments to pass to matplotlib `savefig()`.\n    701     \"\"\"\n--&gt; 702     sv = self.save_helper(\n    703         filename=filename,\n    704         format=format,\n    705         path=path,\n    706         width=width,\n    707         height=height,\n    708         units=units,\n    709         dpi=dpi,\n    710         limitsize=limitsize,\n    711         verbose=verbose,\n    712         **kwargs,\n    713     )\n    715     with plot_context(self).rc_context:\n    716         sv.figure.savefig(**sv.kwargs)\n\nFile ~/scm/python/plotnine/plotnine/ggplot.py:650, in ggplot.save_helper(self, filename, format, path, width, height, units, dpi, limitsize, verbose, **kwargs)\n    647 if dpi is not None:\n    648     self.theme = self.theme + theme(dpi=dpi)\n--&gt; 650 figure = self.draw(show=False)\n    651 return mpl_save_view(figure, fig_kwargs)\n\nFile ~/scm/python/plotnine/plotnine/ggplot.py:322, in ggplot.draw(self, show)\n    319     self._create_figure()\n    320 figure = self.figure\n--&gt; 322 self._build()\n    324 # setup\n    325 self.axs = self.facet.setup(self)\n\nFile ~/scm/python/plotnine/plotnine/ggplot.py:419, in ggplot._build(self)\n    417 npscales = scales.non_position_scales()\n    418 if len(npscales):\n--&gt; 419     layers.train(npscales)\n    420     layers.map(npscales)\n    422 # Train coordinate system\n\nFile ~/scm/python/plotnine/plotnine/layer.py:492, in Layers.train(self, scales)\n    490 def train(self, scales: Scales):\n    491     for l in self:\n--&gt; 492         scales.train_df(l.data)\n\nFile ~/scm/python/plotnine/plotnine/scales/scales.py:203, in Scales.train_df(self, data, drop)\n    201 # Each scale trains the columns it understands\n    202 for sc in self:\n--&gt; 203     sc.train_df(data)\n\nFile ~/scm/python/plotnine/plotnine/scales/scale.py:284, in scale.train_df(self, df)\n    282 aesthetics = sorted(set(self.aesthetics) & set(df.columns))\n    283 for ae in aesthetics:\n--&gt; 284     self.train(df[ae])\n\nFile ~/scm/python/plotnine/plotnine/scales/scale_identity.py:36, in MapTrainMixin.train(self, x, drop)\n     33 if self.guide is None:  # pyright: ignore\n     34     return\n---&gt; 36 return super().train(x)\n\nFile ~/scm/python/plotnine/plotnine/scales/scale_discrete.py:107, in scale_discrete.train(self, x, drop)\n    104     return\n    106 na_rm = not self.na_translate\n--&gt; 107 self._range.train(x, drop, na_rm=na_rm)\n\nFile ~/scm/python/plotnine/plotnine/scales/range.py:67, in RangeDiscrete.train(self, x, drop, na_rm)\n     63 \"\"\"\n     64 Train discrete range\n     65 \"\"\"\n     66 rng = None if self.is_empty() else self.range\n---&gt; 67 self.range = scale_discrete.train(x, rng, drop, na_rm=na_rm)\n\nFile ~/.uvenv/plotnine/lib/python3.13/site-packages/mizani/scale.py:269, in scale_discrete.train(cls, new_data, old, drop, na_rm)\n    267     limits = [c for c in ordered_cats if c in all_set]\n    268 else:\n--&gt; 269     new = np.unique(new_data)\n    270     new.sort()\n    272     limits = old + [i for i in new if (i not in old_set)]\n\nFile ~/.uvenv/plotnine/lib/python3.13/site-packages/numpy/lib/_arraysetops_impl.py:286, in unique(ar, return_index, return_inverse, return_counts, axis, equal_nan)\n    284 ar = np.asanyarray(ar)\n    285 if axis is None:\n--&gt; 286     ret = _unique1d(ar, return_index, return_inverse, return_counts,\n    287                     equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)\n    288     return _unpack_tuple(ret)\n    290 # axis was specified and not None\n\nFile ~/.uvenv/plotnine/lib/python3.13/site-packages/numpy/lib/_arraysetops_impl.py:353, in _unique1d(ar, return_index, return_inverse, return_counts, equal_nan, inverse_shape, axis)\n    351     aux = ar[perm]\n    352 else:\n--&gt; 353     ar.sort()\n    354     aux = ar\n    355 mask = np.empty(aux.shape, dtype=np.bool)\n\nTypeError: '&lt;' not supported between instances of 'int' and 'str'\n\n\n\n&lt;plotnine.ggplot.ggplot at 0x10acd1220&gt;\n\n\n\nSource: Scatter Plot Shapes"
  },
  {
    "objectID": "reference/scale_shape.html",
    "href": "reference/scale_shape.html",
    "title": " plotnine.scale_shape",
    "section": "",
    "text": "scale_shape(\n    unfilled=False,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_shape.html#init-parameters",
    "href": "reference/scale_shape.html#init-parameters",
    "title": " plotnine.scale_shape",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nunfilled: bool = False\n\nIf True, then all shapes will have no interiors that can be a filled."
  },
  {
    "objectID": "reference/scale_shape.html#parameter-attributes",
    "href": "reference/scale_shape.html#parameter-attributes",
    "title": " plotnine.scale_shape",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_linetype_identity.html",
    "href": "reference/scale_linetype_identity.html",
    "title": " plotnine.scale_linetype_identity",
    "section": "",
    "text": "scale_linetype_identity(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_linetype_identity.html#parameter-attributes",
    "href": "reference/scale_linetype_identity.html#parameter-attributes",
    "title": " plotnine.scale_linetype_identity",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = None\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_linetype.html",
    "href": "reference/scale_linetype.html",
    "title": " plotnine.scale_linetype",
    "section": "",
    "text": "scale_linetype(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_linetype.html#parameter-attributes",
    "href": "reference/scale_linetype.html#parameter-attributes",
    "title": " plotnine.scale_linetype",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_linetype.html#notes",
    "href": "reference/scale_linetype.html#notes",
    "title": " plotnine.scale_linetype",
    "section": "Notes",
    "text": "Notes\nThe available linetypes are 'solid', 'dashed', 'dashdot', 'dotted' If you need more custom linetypes, use scale_linetype_manual"
  },
  {
    "objectID": "reference/scale_fill_manual.html",
    "href": "reference/scale_fill_manual.html",
    "title": " plotnine.scale_fill_manual",
    "section": "",
    "text": "scale_fill_manual(\n    values,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_fill_manual.html#init-parameters",
    "href": "reference/scale_fill_manual.html#init-parameters",
    "title": " plotnine.scale_fill_manual",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nvalues: Sequence[Any] | dict[Any, Any] \n\nColors that make up the palette. The values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to colors."
  },
  {
    "objectID": "reference/scale_fill_manual.html#parameter-attributes",
    "href": "reference/scale_fill_manual.html#parameter-attributes",
    "title": " plotnine.scale_fill_manual",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\n\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_fill_hue.html",
    "href": "reference/scale_fill_hue.html",
    "title": " plotnine.scale_fill_hue",
    "section": "",
    "text": "scale_fill_hue(\n    h=0.01,\n    l=0.6,\n    s=0.65,\n    color_space=\"hls\",\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_fill_hue.html#init-parameters",
    "href": "reference/scale_fill_hue.html#init-parameters",
    "title": " plotnine.scale_fill_hue",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nh: float = 0.01\n\nHue. Must be in the range [0, 1]\n\nl: float = 0.6\n\nLightness. Must be in the range [0, 1]\n\ns: float = 0.65\n\nSaturation. Must be in the range [0, 1]\n\ncolor_space: Literal['hls', 'hsluv'] = 'hls'\n\nColor space to use. Should be one of hls or hsluv. https://www.hsluv.org/"
  },
  {
    "objectID": "reference/scale_fill_hue.html#parameter-attributes",
    "href": "reference/scale_fill_hue.html#parameter-attributes",
    "title": " plotnine.scale_fill_hue",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_fill_gray.html",
    "href": "reference/scale_fill_gray.html",
    "title": " plotnine.scale_fill_gray",
    "section": "",
    "text": "scale_fill_gray(\n    start=0.2,\n    end=0.8,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_fill_gray.html#init-parameters",
    "href": "reference/scale_fill_gray.html#init-parameters",
    "title": " plotnine.scale_fill_gray",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nstart: float = 0.2\n\nGrey value at low end of palette.\n\nend: float = 0.8\n\nGrey value at high end of palette"
  },
  {
    "objectID": "reference/scale_fill_gray.html#parameter-attributes",
    "href": "reference/scale_fill_gray.html#parameter-attributes",
    "title": " plotnine.scale_fill_gray",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_fill_gradient2.html",
    "href": "reference/scale_fill_gradient2.html",
    "title": " plotnine.scale_fill_gradient2",
    "section": "",
    "text": "scale_fill_gradient2(\n    low=\"#832424\",\n    mid=\"#FFFFFF\",\n    high=\"#3A3A98\",\n    midpoint=0,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"colorbar\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_fill_gradient2.html#init-parameters",
    "href": "reference/scale_fill_gradient2.html#init-parameters",
    "title": " plotnine.scale_fill_gradient2",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nlow: str = '#832424'\n\nLow color.\n\nmid: str = '#FFFFFF'\n\nMid-point color.\n\nhigh: str = '#3A3A98'\n\nHigh color.\n\nmidpoint: float = 0\n\nMid point of the input data range."
  },
  {
    "objectID": "reference/scale_fill_gradient2.html#parameter-attributes",
    "href": "reference/scale_fill_gradient2.html#parameter-attributes",
    "title": " plotnine.scale_fill_gradient2",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\", \"colorbar\"] | None = \"colorbar\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_fill_distiller.html",
    "href": "reference/scale_fill_distiller.html",
    "title": " plotnine.scale_fill_distiller",
    "section": "",
    "text": "scale_fill_distiller(\n    type=\"seq\",\n    palette=1,\n    values=None,\n    direction=1,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"colorbar\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_fill_distiller.html#init-parameters",
    "href": "reference/scale_fill_distiller.html#init-parameters",
    "title": " plotnine.scale_fill_distiller",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ntype: Literal['diverging', 'qualitative', 'sequential', 'div', 'qual', 'seq'] = 'seq'\n\nType of data\n\npalette: int | str = 1\n\nIf a string, will use that named palette. If a number, will index into the list of palettes of appropriate type.\n\nvalues: Sequence[float] | None = None\n\nList of points in the range [0, 1] at which to place each color. Must be the same size as colors. Default to evenly space the colors\n\ndirection: Literal[1, -1] = 1\n\nSets the order of colors in the scale. If 1, colors are as output brewer_pal. If -1, the order of colors is reversed."
  },
  {
    "objectID": "reference/scale_fill_distiller.html#parameter-attributes",
    "href": "reference/scale_fill_distiller.html#parameter-attributes",
    "title": " plotnine.scale_fill_distiller",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\", \"colorbar\"] | None = \"colorbar\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_fill_desaturate.html",
    "href": "reference/scale_fill_desaturate.html",
    "title": " plotnine.scale_fill_desaturate",
    "section": "",
    "text": "scale_fill_desaturate(\n    color=\"red\",\n    prop=0,\n    reverse=False,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"colorbar\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_fill_desaturate.html#init-parameters",
    "href": "reference/scale_fill_desaturate.html#init-parameters",
    "title": " plotnine.scale_fill_desaturate",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ncolor: str = 'red'\n\nColor to desaturate\n\nprop: float = 0\n\nSaturation channel of color will be multiplied by this value.\n\nreverse: bool = False\n\nWhether to go from color to desaturated color or desaturated color to color."
  },
  {
    "objectID": "reference/scale_fill_desaturate.html#parameter-attributes",
    "href": "reference/scale_fill_desaturate.html#parameter-attributes",
    "title": " plotnine.scale_fill_desaturate",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\", \"colorbar\"] | None = \"colorbar\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_fill_continuous.html",
    "href": "reference/scale_fill_continuous.html",
    "title": " plotnine.scale_fill_continuous",
    "section": "",
    "text": "scale_fill_continuous(\n    cmap_name=\"viridis\",\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"colorbar\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_fill_continuous.html#init-parameters",
    "href": "reference/scale_fill_continuous.html#init-parameters",
    "title": " plotnine.scale_fill_continuous",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ncmap_name: str = 'viridis'\n\nA standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see colormaps."
  },
  {
    "objectID": "reference/scale_fill_continuous.html#parameter-attributes",
    "href": "reference/scale_fill_continuous.html#parameter-attributes",
    "title": " plotnine.scale_fill_continuous",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\", \"colorbar\"] | None = \"colorbar\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_fill_continuous.html#examples",
    "href": "reference/scale_fill_continuous.html#examples",
    "title": " plotnine.scale_fill_continuous",
    "section": "Examples",
    "text": "Examples\n\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    theme_matplotlib,\n    theme_set,\n    geom_tile,\n    scale_fill_continuous,\n    coord_cartesian\n)\n\nfrom plotnine.data import faithfuld\n\n# Set default theme for all the plots\ntheme_set(theme_matplotlib())\n\n\nSimple heatmap\nMap data to color gradient\nWithout specifically calling scale_fill_continuous(), a default scale is applied to geom_tile().\n\nfaithfuld.head()\n\n\n\n\n\n\n\n\neruptions\nwaiting\ndensity\n\n\n\n\n0\n1.600000\n43.0\n0.003216\n\n\n1\n1.647297\n43.0\n0.003835\n\n\n2\n1.694595\n43.0\n0.004436\n\n\n3\n1.741892\n43.0\n0.004978\n\n\n4\n1.789189\n43.0\n0.005424\n\n\n\n\n\n\n\n\n(\n    ggplot(faithfuld, aes(\"waiting\", \"eruptions\", fill=\"density\")) \n    + geom_tile()\n)\n\n\n\n\n\n\n\n\nNotice that adding scale_fill_continuous() will not change the default plot.\n\n(\n    ggplot(faithfuld, aes(\"waiting\", \"eruptions\", fill=\"density\"))\n    + geom_tile()\n    + scale_fill_continuous()\n)\n\n\n\n\n\n\n\n\nThe scale aesthetics can be edited to other color maps. Use the cmap_name argument to specify an alternative palette. Find other available color maps in the matplotlib documentation.\n\n# Gallery, tiles\n\n(\n    ggplot(faithfuld, aes(\"waiting\", \"eruptions\", fill=\"density\"))\n    + geom_tile()\n    + scale_fill_continuous(cmap_name=\"plasma\")\n    + coord_cartesian(expand=False)\n)\n\n\n\n\n\n\n\n\n\nSource: Set default theme for all the plots"
  },
  {
    "objectID": "reference/scale_fill_cmap.html",
    "href": "reference/scale_fill_cmap.html",
    "title": " plotnine.scale_fill_cmap",
    "section": "",
    "text": "scale_fill_cmap(\n    cmap_name=\"viridis\",\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"colorbar\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_fill_cmap.html#init-parameters",
    "href": "reference/scale_fill_cmap.html#init-parameters",
    "title": " plotnine.scale_fill_cmap",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ncmap_name: str = 'viridis'\n\nA standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see colormaps."
  },
  {
    "objectID": "reference/scale_fill_cmap.html#parameter-attributes",
    "href": "reference/scale_fill_cmap.html#parameter-attributes",
    "title": " plotnine.scale_fill_cmap",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\", \"colorbar\"] | None = \"colorbar\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_discrete.html",
    "href": "reference/scale_discrete.html",
    "title": " plotnine.scales.scale_discrete.scale_discrete",
    "section": "",
    "text": "scale_discrete(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_discrete.html#parameter-attributes",
    "href": "reference/scale_discrete.html#parameter-attributes",
    "title": " plotnine.scales.scale_discrete.scale_discrete",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_continuous.html",
    "href": "reference/scale_continuous.html",
    "title": " plotnine.scales.scale_continuous.scale_continuous",
    "section": "",
    "text": "scale_continuous(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_continuous.html#parameter-attributes",
    "href": "reference/scale_continuous.html#parameter-attributes",
    "title": " plotnine.scales.scale_continuous.scale_continuous",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: GuideTypeT\n\nWhether to include a legend\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_continuous.html#notes",
    "href": "reference/scale_continuous.html#notes",
    "title": " plotnine.scales.scale_continuous.scale_continuous",
    "section": "Notes",
    "text": "Notes\nIf using the class directly all arguments must be keyword arguments."
  },
  {
    "objectID": "reference/scale_colour_identity.html",
    "href": "reference/scale_colour_identity.html",
    "title": " plotnine.scale_colour_identity",
    "section": "",
    "text": "scale_colour_identity(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_colour_identity.html#parameter-attributes",
    "href": "reference/scale_colour_identity.html#parameter-attributes",
    "title": " plotnine.scale_colour_identity",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = None\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_color_manual.html",
    "href": "reference/scale_color_manual.html",
    "title": " plotnine.scale_color_manual",
    "section": "",
    "text": "scale_color_manual(\n    values,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_color_manual.html#init-parameters",
    "href": "reference/scale_color_manual.html#init-parameters",
    "title": " plotnine.scale_color_manual",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nvalues: Sequence[Any] | dict[Any, Any] \n\nColors that make up the palette. The values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to colors."
  },
  {
    "objectID": "reference/scale_color_manual.html#parameter-attributes",
    "href": "reference/scale_color_manual.html#parameter-attributes",
    "title": " plotnine.scale_color_manual",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\n\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_color_hue.html",
    "href": "reference/scale_color_hue.html",
    "title": " plotnine.scale_color_hue",
    "section": "",
    "text": "scale_color_hue(\n    h=0.01,\n    l=0.6,\n    s=0.65,\n    color_space=\"hls\",\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_color_hue.html#init-parameters",
    "href": "reference/scale_color_hue.html#init-parameters",
    "title": " plotnine.scale_color_hue",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nh: float = 0.01\n\nHue. Must be in the range [0, 1]\n\nl: float = 0.6\n\nLightness. Must be in the range [0, 1]\n\ns: float = 0.65\n\nSaturation. Must be in the range [0, 1]\n\ncolor_space: Literal['hls', 'hsluv'] = 'hls'\n\nColor space to use. Should be one of hls or hsluv. https://www.hsluv.org/"
  },
  {
    "objectID": "reference/scale_color_hue.html#parameter-attributes",
    "href": "reference/scale_color_hue.html#parameter-attributes",
    "title": " plotnine.scale_color_hue",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_color_gray.html",
    "href": "reference/scale_color_gray.html",
    "title": " plotnine.scale_color_gray",
    "section": "",
    "text": "scale_color_gray(\n    start=0.2,\n    end=0.8,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_color_gray.html#init-parameters",
    "href": "reference/scale_color_gray.html#init-parameters",
    "title": " plotnine.scale_color_gray",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nstart: float = 0.2\n\nGrey value at low end of palette.\n\nend: float = 0.8\n\nGrey value at high end of palette"
  },
  {
    "objectID": "reference/scale_color_gray.html#parameter-attributes",
    "href": "reference/scale_color_gray.html#parameter-attributes",
    "title": " plotnine.scale_color_gray",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_color_gradient2.html",
    "href": "reference/scale_color_gradient2.html",
    "title": " plotnine.scale_color_gradient2",
    "section": "",
    "text": "scale_color_gradient2(\n    low=\"#832424\",\n    mid=\"#FFFFFF\",\n    high=\"#3A3A98\",\n    midpoint=0,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"colorbar\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_color_gradient2.html#init-parameters",
    "href": "reference/scale_color_gradient2.html#init-parameters",
    "title": " plotnine.scale_color_gradient2",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nlow: str = '#832424'\n\nLow color.\n\nmid: str = '#FFFFFF'\n\nMid-point color.\n\nhigh: str = '#3A3A98'\n\nHigh color.\n\nmidpoint: float = 0\n\nMid point of the input data range."
  },
  {
    "objectID": "reference/scale_color_gradient2.html#parameter-attributes",
    "href": "reference/scale_color_gradient2.html#parameter-attributes",
    "title": " plotnine.scale_color_gradient2",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\", \"colorbar\"] | None = \"colorbar\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_color_gradient2.html#see-also",
    "href": "reference/scale_color_gradient2.html#see-also",
    "title": " plotnine.scale_color_gradient2",
    "section": "See Also",
    "text": "See Also\n\nscale_color_gradient\n\n\n\nscale_color_gradientn"
  },
  {
    "objectID": "reference/scale_color_distiller.html",
    "href": "reference/scale_color_distiller.html",
    "title": " plotnine.scale_color_distiller",
    "section": "",
    "text": "scale_color_distiller(\n    type=\"seq\",\n    palette=1,\n    values=None,\n    direction=1,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"colorbar\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_color_distiller.html#init-parameters",
    "href": "reference/scale_color_distiller.html#init-parameters",
    "title": " plotnine.scale_color_distiller",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ntype: Literal['diverging', 'qualitative', 'sequential', 'div', 'qual', 'seq'] = 'seq'\n\nType of data\n\npalette: int | str = 1\n\nIf a string, will use that named palette. If a number, will index into the list of palettes of appropriate type.\n\nvalues: Sequence[float] | None = None\n\nList of points in the range [0, 1] at which to place each color. Must be the same size as colors. Default to evenly space the colors\n\ndirection: Literal[1, -1] = 1\n\nSets the order of colors in the scale. If 1, colors are as output brewer_pal. If -1, the order of colors is reversed."
  },
  {
    "objectID": "reference/scale_color_distiller.html#parameter-attributes",
    "href": "reference/scale_color_distiller.html#parameter-attributes",
    "title": " plotnine.scale_color_distiller",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\", \"colorbar\"] | None = \"colorbar\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_color_desaturate.html",
    "href": "reference/scale_color_desaturate.html",
    "title": " plotnine.scale_color_desaturate",
    "section": "",
    "text": "scale_color_desaturate(\n    color=\"red\",\n    prop=0,\n    reverse=False,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"colorbar\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_color_desaturate.html#init-parameters",
    "href": "reference/scale_color_desaturate.html#init-parameters",
    "title": " plotnine.scale_color_desaturate",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ncolor: str = 'red'\n\nColor to desaturate\n\nprop: float = 0\n\nSaturation channel of color will be multiplied by this value.\n\nreverse: bool = False\n\nWhether to go from color to desaturated color or desaturated color to color."
  },
  {
    "objectID": "reference/scale_color_desaturate.html#parameter-attributes",
    "href": "reference/scale_color_desaturate.html#parameter-attributes",
    "title": " plotnine.scale_color_desaturate",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\", \"colorbar\"] | None = \"colorbar\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_color_continuous.html",
    "href": "reference/scale_color_continuous.html",
    "title": " plotnine.scale_color_continuous",
    "section": "",
    "text": "scale_color_continuous(\n    cmap_name=\"viridis\",\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"colorbar\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_color_continuous.html#init-parameters",
    "href": "reference/scale_color_continuous.html#init-parameters",
    "title": " plotnine.scale_color_continuous",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ncmap_name: str = 'viridis'\n\nA standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see colormaps."
  },
  {
    "objectID": "reference/scale_color_continuous.html#parameter-attributes",
    "href": "reference/scale_color_continuous.html#parameter-attributes",
    "title": " plotnine.scale_color_continuous",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\", \"colorbar\"] | None = \"colorbar\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_color_cmap.html",
    "href": "reference/scale_color_cmap.html",
    "title": " plotnine.scale_color_cmap",
    "section": "",
    "text": "scale_color_cmap(\n    cmap_name=\"viridis\",\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"colorbar\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_color_cmap.html#init-parameters",
    "href": "reference/scale_color_cmap.html#init-parameters",
    "title": " plotnine.scale_color_cmap",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ncmap_name: str = 'viridis'\n\nA standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see colormaps."
  },
  {
    "objectID": "reference/scale_color_cmap.html#parameter-attributes",
    "href": "reference/scale_color_cmap.html#parameter-attributes",
    "title": " plotnine.scale_color_cmap",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\", \"colorbar\"] | None = \"colorbar\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_color_cmap.html#see-also",
    "href": "reference/scale_color_cmap.html#see-also",
    "title": " plotnine.scale_color_cmap",
    "section": "See Also",
    "text": "See Also\n\nmatplotlib.cm\n\n\n\nmatplotlib.colors"
  },
  {
    "objectID": "reference/scale_alpha_ordinal.html",
    "href": "reference/scale_alpha_ordinal.html",
    "title": " plotnine.scale_alpha_ordinal",
    "section": "",
    "text": "scale_alpha_ordinal(\n    range=(0.1, 1),\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_alpha_ordinal.html#init-parameters",
    "href": "reference/scale_alpha_ordinal.html#init-parameters",
    "title": " plotnine.scale_alpha_ordinal",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nrange: tuple[float, float] = (0.1, 1)\n\nRange ([Minimum, Maximum]) of output alpha values. Should be between 0 and 1."
  },
  {
    "objectID": "reference/scale_alpha_ordinal.html#parameter-attributes",
    "href": "reference/scale_alpha_ordinal.html#parameter-attributes",
    "title": " plotnine.scale_alpha_ordinal",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_alpha_identity.html",
    "href": "reference/scale_alpha_identity.html",
    "title": " plotnine.scale_alpha_identity",
    "section": "",
    "text": "scale_alpha_identity(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_alpha_identity.html#parameter-attributes",
    "href": "reference/scale_alpha_identity.html#parameter-attributes",
    "title": " plotnine.scale_alpha_identity",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = None\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_alpha_datetime.html",
    "href": "reference/scale_alpha_datetime.html",
    "title": " plotnine.scale_alpha_datetime",
    "section": "",
    "text": "scale_alpha_datetime(\n    date_breaks=None,\n    date_labels=None,\n    date_minor_breaks=None,\n    range=(0.1, 1),\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"datetime\"\n)"
  },
  {
    "objectID": "reference/scale_alpha_datetime.html#init-parameters",
    "href": "reference/scale_alpha_datetime.html#init-parameters",
    "title": " plotnine.scale_alpha_datetime",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ndate_breaks: str | None = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str | None = None\n\nFormat string for the labels. See strftime. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str | None = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks.\n\nrange: tuple[float, float] = (0.1, 1)\n\nRange ([Minimum, Maximum]) of output alpha values. Should be between 0 and 1."
  },
  {
    "objectID": "reference/scale_alpha_datetime.html#parameter-attributes",
    "href": "reference/scale_alpha_datetime.html#parameter-attributes",
    "title": " plotnine.scale_alpha_datetime",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: ( # pyright: ignore[reportIncompatibleVariableOverride]    tuple[float, timedelta]    | tuple[float, timedelta, float, timedelta]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, timedelta(0)) - Do not expand.\n(0, timedelta(days=1)) - Expand lower and upper limits by 1 day.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, timedelta(hours=6)) - Expand upper limit by 6 hours.\n(0, timedelta(minutes=5), 0.1, timdelta(0)) - Expand lower limit by 5 minutes and upper limit by 10%.\n(0, 0, 0.1, timedelta(weeks=2)) - Expand upper limit by 10% plus 2 weeks.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"datetime\""
  },
  {
    "objectID": "reference/scale_alpha.html",
    "href": "reference/scale_alpha.html",
    "title": " plotnine.scale_alpha",
    "section": "",
    "text": "scale_alpha(\n    range=(0.1, 1),\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_alpha.html#init-parameters",
    "href": "reference/scale_alpha.html#init-parameters",
    "title": " plotnine.scale_alpha",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nrange: tuple[float, float] = (0.1, 1)\n\nRange ([Minimum, Maximum]) of output alpha values. Should be between 0 and 1."
  },
  {
    "objectID": "reference/scale_alpha.html#parameter-attributes",
    "href": "reference/scale_alpha.html#parameter-attributes",
    "title": " plotnine.scale_alpha",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/save_as_pdf_pages.html",
    "href": "reference/save_as_pdf_pages.html",
    "title": " plotnine.save_as_pdf_pages",
    "section": "",
    "text": "save_as_pdf_pages(plots, filename=None, path=None, verbose=True, kwargs={})"
  },
  {
    "objectID": "reference/save_as_pdf_pages.html#parameters",
    "href": "reference/save_as_pdf_pages.html#parameters",
    "title": " plotnine.save_as_pdf_pages",
    "section": "Parameters",
    "text": "Parameters\n\n\nplots : Iterable[ggplot]\n\nPlot objects to write to file. plots may be either a collection such as a list or set\nbase_plot = ggplot(…)\nplots = [base_plot + ggtitle('%d of 3' % i) for i in range(1, 3)]\nsave_as_pdf_pages(plots)\nor, a generator that yields ggplot objects:\ndef myplots():\n    for i in range(1, 3):\n        yield ggplot(…) + ggtitle('%d of 3' % i)\nsave_as_pdf_pages(myplots())\n\nfilename : Optional[str | Path] = None\n\nFile name to write the plot to. If not specified, a name like “plotnine-save-.pdf” is used.\n\npath : str | None = None\n\nPath to save plot to (if you just want to set path and not filename).\n\nverbose : bool = True\n\nIf True, print the saving information.\n\nkwargs : Any = {}\n\nAdditional arguments to pass to savefig."
  },
  {
    "objectID": "reference/save_as_pdf_pages.html#notes",
    "href": "reference/save_as_pdf_pages.html#notes",
    "title": " plotnine.save_as_pdf_pages",
    "section": "Notes",
    "text": "Notes\nUsing pandas groupby methods, tidy data can be “faceted” across pages:\nfrom plotnine.data import mtcars\n\ndef facet_pages(column)\n    base_plot = [\n        aes(x=\"wt\", y=\"mpg\", label=\"name\"),\n        geom_text(),\n    ]\n    for label, group_data in mtcars.groupby(column):\n        yield ggplot(group_data) + base_plot + ggtitle(label)\n\nsave_as_pdf_pages(facet_pages('cyl'))\nUnlike save, save_as_pdf_pages does not process arguments for height or width. To set the figure size, add figure_size to the theme for some or all of the objects in plots:\nplot = ggplot(…)\n# The following are equivalent\nplot.save('filename.pdf', height=6, width=8)\nsave_as_pdf_pages([plot + theme(figure_size=(8, 6))])"
  },
  {
    "objectID": "reference/rect.html",
    "href": "reference/rect.html",
    "title": " plotnine.themes.themeable.rect",
    "section": "",
    "text": "rect(theme_element)"
  },
  {
    "objectID": "reference/rect.html#parameters",
    "href": "reference/rect.html#parameters",
    "title": " plotnine.themes.themeable.rect",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_rect"
  },
  {
    "objectID": "reference/presidential.html",
    "href": "reference/presidential.html",
    "title": " plotnine.data.presidential",
    "section": "",
    "text": "presidential = pd.read_csv(DATA_DIR / \"presidential.csv\", parse_dates=[1, 2])"
  },
  {
    "objectID": "reference/presidential.html#description",
    "href": "reference/presidential.html#description",
    "title": " plotnine.data.presidential",
    "section": "Description",
    "text": "Description\nThe names of each president, the start and end date of their term, and their party of 11 US presidents from Eisenhower to Obama."
  },
  {
    "objectID": "reference/presidential.html#format",
    "href": "reference/presidential.html#format",
    "title": " plotnine.data.presidential",
    "section": "Format",
    "text": "Format\nA data frame with 11 rows and 4 variables\n\n\n\nColumn\nDescription\n\n\n\n\nname\nName of president\n\n\nstart\nStart of presidential term\n\n\nend\nEnd of presidential term\n\n\nparty\nPolitical Party"
  },
  {
    "objectID": "reference/position_nudge.html",
    "href": "reference/position_nudge.html",
    "title": " plotnine.position_nudge",
    "section": "",
    "text": "position_nudge(x=0, y=0)"
  },
  {
    "objectID": "reference/position_nudge.html#parameters",
    "href": "reference/position_nudge.html#parameters",
    "title": " plotnine.position_nudge",
    "section": "Parameters",
    "text": "Parameters\n\n\nx : float = 0\n\nHorizontal nudge\n\ny : float = 0\n\nVertical nudge"
  },
  {
    "objectID": "reference/position_jitter.html",
    "href": "reference/position_jitter.html",
    "title": " plotnine.position_jitter",
    "section": "",
    "text": "position_jitter(width=None, height=None, random_state=None)"
  },
  {
    "objectID": "reference/position_jitter.html#parameters",
    "href": "reference/position_jitter.html#parameters",
    "title": " plotnine.position_jitter",
    "section": "Parameters",
    "text": "Parameters\n\n\nwidth : Optional[float] = None\n\nProportion to jitter in horizontal direction. If None, 0.4 of the resolution of the data.\n\nheight : Optional[float] = None\n\nProportion to jitter in vertical direction. If None, 0.4 of the resolution of the data.\n\nrandom_state : Optional[int | np.random.RandomState] = None\n\nSeed or Random number generator to use. If None, then numpy global generator numpy.random is used."
  },
  {
    "objectID": "reference/position_fill.html",
    "href": "reference/position_fill.html",
    "title": " plotnine.position_fill",
    "section": "",
    "text": "position_fill(vjust=1, reverse=False)\n\n\nNormalise stacked objects to unit height"
  },
  {
    "objectID": "reference/position_dodge.html",
    "href": "reference/position_dodge.html",
    "title": " plotnine.position_dodge",
    "section": "",
    "text": "position_dodge(width=None, preserve=\"total\")"
  },
  {
    "objectID": "reference/position_dodge.html#parameters",
    "href": "reference/position_dodge.html#parameters",
    "title": " plotnine.position_dodge",
    "section": "Parameters",
    "text": "Parameters\n\n\nwidth : Optional[float] = None\n\nDodging width, when different to the width of the individual elements. This is useful when you want to align narrow geoms with wider geoms\n\npreserve : Literal[\"total\", \"single\"] = \"total\"\n\nShould dodging preserve the total width of all elements at a position, or the width of a single element?"
  },
  {
    "objectID": "reference/plot_title_position.html",
    "href": "reference/plot_title_position.html",
    "title": " plotnine.themes.themeable.plot_title_position",
    "section": "",
    "text": "plot_title_position(theme_element)"
  },
  {
    "objectID": "reference/plot_title_position.html#parameters",
    "href": "reference/plot_title_position.html#parameters",
    "title": " plotnine.themes.themeable.plot_title_position",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : Literal[\"panel\", \"plot\"] = = \"panel\"\n\nIf “panel”, the title / subtitle are aligned with respect to the panels. If “plot”, they are aligned with the plot, excluding the margin space"
  },
  {
    "objectID": "reference/plot_tag_position.html",
    "href": "reference/plot_tag_position.html",
    "title": " plotnine.themes.themeable.plot_tag_position",
    "section": "",
    "text": "plot_tag_position(theme_element)"
  },
  {
    "objectID": "reference/plot_tag_position.html#parameters",
    "href": "reference/plot_tag_position.html#parameters",
    "title": " plotnine.themes.themeable.plot_tag_position",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : Literal[\"topleft\", \"top\", \"topright\", \"leftright\", \"bottomleft\", \"bottom\", \"bottomleft\"] | tuple[float, float] = = \"topleft\"\n\nIf the value is a string, the tag will be managed by the layout manager. If it is a tuple of (x, y) coordinates, they should be in figure space and the tag will be ignored by the layout manager."
  },
  {
    "objectID": "reference/plot_tag.html",
    "href": "reference/plot_tag.html",
    "title": " plotnine.themes.themeable.plot_tag",
    "section": "",
    "text": "plot_tag(theme_element)"
  },
  {
    "objectID": "reference/plot_tag.html#parameters",
    "href": "reference/plot_tag.html#parameters",
    "title": " plotnine.themes.themeable.plot_tag",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/plot_tag.html#notes",
    "href": "reference/plot_tag.html#notes",
    "title": " plotnine.themes.themeable.plot_tag",
    "section": "Notes",
    "text": "Notes\nThe ha & va of element_text have no effect in some cases. e.g. if plot_tag_position is “margin” and the tag is at the top it cannot be vertically aligned.\nAlso ha & va can be floats if it makes sense to justify the tag over a span. e.g. along the panel or plot, or when aligning with other tags in a composition."
  },
  {
    "objectID": "reference/plot_margin_top.html",
    "href": "reference/plot_margin_top.html",
    "title": " plotnine.themes.themeable.plot_margin_top",
    "section": "",
    "text": "plot_margin_top(theme_element)"
  },
  {
    "objectID": "reference/plot_margin_top.html#parameters",
    "href": "reference/plot_margin_top.html#parameters",
    "title": " plotnine.themes.themeable.plot_margin_top",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nMust be in the [0, 1] range. It is specified as a fraction of the figure width and figure height."
  },
  {
    "objectID": "reference/plot_margin_left.html",
    "href": "reference/plot_margin_left.html",
    "title": " plotnine.themes.themeable.plot_margin_left",
    "section": "",
    "text": "plot_margin_left(theme_element)"
  },
  {
    "objectID": "reference/plot_margin_left.html#parameters",
    "href": "reference/plot_margin_left.html#parameters",
    "title": " plotnine.themes.themeable.plot_margin_left",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nMust be in the [0, 1] range. It is specified as a fraction of the figure width and figure height."
  },
  {
    "objectID": "reference/plot_margin.html",
    "href": "reference/plot_margin.html",
    "title": " plotnine.themes.themeable.plot_margin",
    "section": "",
    "text": "plot_margin(theme_element)"
  },
  {
    "objectID": "reference/plot_margin.html#parameters",
    "href": "reference/plot_margin.html#parameters",
    "title": " plotnine.themes.themeable.plot_margin",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nMust be in the [0, 1] range. It is specified as a fraction of the figure width and figure height."
  },
  {
    "objectID": "reference/plot_caption.html",
    "href": "reference/plot_caption.html",
    "title": " plotnine.themes.themeable.plot_caption",
    "section": "",
    "text": "plot_caption(theme_element)"
  },
  {
    "objectID": "reference/plot_caption.html#parameters",
    "href": "reference/plot_caption.html#parameters",
    "title": " plotnine.themes.themeable.plot_caption",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/panel_spacing_y.html",
    "href": "reference/panel_spacing_y.html",
    "title": " plotnine.themes.themeable.panel_spacing_y",
    "section": "",
    "text": "panel_spacing_y(theme_element)"
  },
  {
    "objectID": "reference/panel_spacing_y.html#parameters",
    "href": "reference/panel_spacing_y.html#parameters",
    "title": " plotnine.themes.themeable.panel_spacing_y",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nSize as a fraction of the figure width."
  },
  {
    "objectID": "reference/panel_spacing_y.html#notes",
    "href": "reference/panel_spacing_y.html#notes",
    "title": " plotnine.themes.themeable.panel_spacing_y",
    "section": "Notes",
    "text": "Notes\nIt is deliberate to have the vertical spacing be a fraction of the width. That means that when panel_spacing_x is the equal panel_spacing_x, the spaces in both directions will be equal."
  },
  {
    "objectID": "reference/panel_spacing.html",
    "href": "reference/panel_spacing.html",
    "title": " plotnine.themes.themeable.panel_spacing",
    "section": "",
    "text": "panel_spacing(theme_element)"
  },
  {
    "objectID": "reference/panel_spacing.html#parameters",
    "href": "reference/panel_spacing.html#parameters",
    "title": " plotnine.themes.themeable.panel_spacing",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nSize as a fraction of the figure’s dimension."
  },
  {
    "objectID": "reference/panel_grid_minor_y.html",
    "href": "reference/panel_grid_minor_y.html",
    "title": " plotnine.themes.themeable.panel_grid_minor_y",
    "section": "",
    "text": "panel_grid_minor_y(theme_element)"
  },
  {
    "objectID": "reference/panel_grid_minor_y.html#parameters",
    "href": "reference/panel_grid_minor_y.html#parameters",
    "title": " plotnine.themes.themeable.panel_grid_minor_y",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/panel_grid_minor.html",
    "href": "reference/panel_grid_minor.html",
    "title": " plotnine.themes.themeable.panel_grid_minor",
    "section": "",
    "text": "panel_grid_minor(theme_element)"
  },
  {
    "objectID": "reference/panel_grid_minor.html#parameters",
    "href": "reference/panel_grid_minor.html#parameters",
    "title": " plotnine.themes.themeable.panel_grid_minor",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/panel_grid_major_x.html",
    "href": "reference/panel_grid_major_x.html",
    "title": " plotnine.themes.themeable.panel_grid_major_x",
    "section": "",
    "text": "panel_grid_major_x(theme_element)"
  },
  {
    "objectID": "reference/panel_grid_major_x.html#parameters",
    "href": "reference/panel_grid_major_x.html#parameters",
    "title": " plotnine.themes.themeable.panel_grid_major_x",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/panel_grid.html",
    "href": "reference/panel_grid.html",
    "title": " plotnine.themes.themeable.panel_grid",
    "section": "",
    "text": "panel_grid(theme_element)"
  },
  {
    "objectID": "reference/panel_grid.html#parameters",
    "href": "reference/panel_grid.html#parameters",
    "title": " plotnine.themes.themeable.panel_grid",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/panel_background.html",
    "href": "reference/panel_background.html",
    "title": " plotnine.themes.themeable.panel_background",
    "section": "",
    "text": "panel_background(theme_element)"
  },
  {
    "objectID": "reference/panel_background.html#parameters",
    "href": "reference/panel_background.html#parameters",
    "title": " plotnine.themes.themeable.panel_background",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_rect"
  },
  {
    "objectID": "reference/mtcars.html",
    "href": "reference/mtcars.html",
    "title": " plotnine.data.mtcars",
    "section": "",
    "text": "mtcars = pd.read_csv(DATA_DIR / \"mtcars.csv\")"
  },
  {
    "objectID": "reference/mtcars.html#description",
    "href": "reference/mtcars.html#description",
    "title": " plotnine.data.mtcars",
    "section": "Description",
    "text": "Description\nThe data was extracted from the 1974 Motor Trend US magazine, and comprises fuel consumption and 10 aspects of automobile design and performance for 32 automobiles (1973–74 models)."
  },
  {
    "objectID": "reference/mtcars.html#format",
    "href": "reference/mtcars.html#format",
    "title": " plotnine.data.mtcars",
    "section": "Format",
    "text": "Format\nA data frame with 32 observations on 11 variables.\n\n\n\nColumn\nDescription\n\n\n\n\nmpg\nMiles/(US) gallon\n\n\ncyl\nNumber of cylinders\n\n\ndisp\nDisplacement (cu.in.)\n\n\nhp\nGross horsepower\n\n\ndrat\nRear axle ratio\n\n\nwt\nWeight (1000 lbs)\n\n\nqsec\n1/4 mile time\n\n\nvs\nV/S\n\n\nam\nTransmission (0 = automatic, 1 = manual)\n\n\ngear\nNumber of forward gears\n\n\ncarb\nNumber of carburetors"
  },
  {
    "objectID": "reference/mtcars.html#source",
    "href": "reference/mtcars.html#source",
    "title": " plotnine.data.mtcars",
    "section": "Source",
    "text": "Source\nHenderson and Velleman (1981), Building multiple regression models interactively. Biometrics, 37, 391–411."
  },
  {
    "objectID": "reference/mpg.html",
    "href": "reference/mpg.html",
    "title": " plotnine.data.mpg",
    "section": "",
    "text": "mpg = pd.read_csv(DATA_DIR / \"mpg.csv\")"
  },
  {
    "objectID": "reference/mpg.html#description",
    "href": "reference/mpg.html#description",
    "title": " plotnine.data.mpg",
    "section": "Description",
    "text": "Description\nThis dataset contains a subset of the fuel economy data that the EPA makes available on http://fueleconomy.gov. It contains only models which had a new release every year between 1999 and 2008 - this was used as a proxy for the popularity of the car."
  },
  {
    "objectID": "reference/mpg.html#format",
    "href": "reference/mpg.html#format",
    "title": " plotnine.data.mpg",
    "section": "Format",
    "text": "Format\nA data frame with 234 rows and 11 variables\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\nmanufacturer\n\n\n\nmodel\n\n\n\ndispl\nengine displacement, in litres\n\n\nyear\n\n\n\ncyl\nnumber of cylinders\n\n\ntrans\ntype of transmission\n\n\ndrv\nf = front-wheel drive r = rear wheel drive 4 = 4wd\n\n\ncty\ncity miles per gallon\n\n\nhwy\nhighway miles per gallon\n\n\nfl\n\n\n\nclass"
  },
  {
    "objectID": "reference/meat.html",
    "href": "reference/meat.html",
    "title": " plotnine.data.meat",
    "section": "",
    "text": "meat = pd.read_csv(DATA_DIR / \"meat.csv\", parse_dates=[0])"
  },
  {
    "objectID": "reference/meat.html#source",
    "href": "reference/meat.html#source",
    "title": " plotnine.data.meat",
    "section": "Source",
    "text": "Source\nLivestock and Meat Dosmestic Data from the Economic Research Service of the U.S. DEPARTMENT OF AGRICULTURE."
  },
  {
    "objectID": "reference/line.html",
    "href": "reference/line.html",
    "title": " plotnine.themes.themeable.line",
    "section": "",
    "text": "line(theme_element)"
  },
  {
    "objectID": "reference/line.html#parameters",
    "href": "reference/line.html#parameters",
    "title": " plotnine.themes.themeable.line",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/legend_title_position.html",
    "href": "reference/legend_title_position.html",
    "title": " plotnine.themes.themeable.legend_title_position",
    "section": "",
    "text": "legend_title_position(theme_element)"
  },
  {
    "objectID": "reference/legend_title_position.html#parameters",
    "href": "reference/legend_title_position.html#parameters",
    "title": " plotnine.themes.themeable.legend_title_position",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : Literal[\"top\", \"bottom\", \"left\", \"right\"] | None\n\nPosition of the legend title. The default depends on the position of the legend."
  },
  {
    "objectID": "reference/legend_ticks_length.html",
    "href": "reference/legend_ticks_length.html",
    "title": " plotnine.themes.themeable.legend_ticks_length",
    "section": "",
    "text": "legend_ticks_length(theme_element)"
  },
  {
    "objectID": "reference/legend_ticks_length.html#parameters",
    "href": "reference/legend_ticks_length.html#parameters",
    "title": " plotnine.themes.themeable.legend_ticks_length",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nA good value should be in the range [0, 0.5]."
  },
  {
    "objectID": "reference/legend_text_legend.html",
    "href": "reference/legend_text_legend.html",
    "title": " plotnine.themes.themeable.legend_text_legend",
    "section": "",
    "text": "legend_text_legend(theme_element)"
  },
  {
    "objectID": "reference/legend_text_legend.html#parameters",
    "href": "reference/legend_text_legend.html#parameters",
    "title": " plotnine.themes.themeable.legend_text_legend",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/legend_text_legend.html#notes",
    "href": "reference/legend_text_legend.html#notes",
    "title": " plotnine.themes.themeable.legend_text_legend",
    "section": "Notes",
    "text": "Notes\nHorizontal alignment ha has no effect when the text is to the left or to the right. Likewise vertical alignment va has no effect when the text at the top or the bottom."
  },
  {
    "objectID": "reference/legend_text.html",
    "href": "reference/legend_text.html",
    "title": " plotnine.themes.themeable.legend_text",
    "section": "",
    "text": "legend_text(theme_element)"
  },
  {
    "objectID": "reference/legend_text.html#parameters",
    "href": "reference/legend_text.html#parameters",
    "title": " plotnine.themes.themeable.legend_text",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/legend_position_inside.html",
    "href": "reference/legend_position_inside.html",
    "title": " plotnine.themes.themeable.legend_position_inside",
    "section": "",
    "text": "legend_position_inside(theme_element)"
  },
  {
    "objectID": "reference/legend_position_inside.html#parameters",
    "href": "reference/legend_position_inside.html#parameters",
    "title": " plotnine.themes.themeable.legend_position_inside",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : tuple[float, float]\n\nWhere to place legends that are inside the panels / facets area. The values should be in the range [0, 1]. The default is to put it in the center ((.5, .5)) of the panels area."
  },
  {
    "objectID": "reference/legend_margin.html",
    "href": "reference/legend_margin.html",
    "title": " plotnine.themes.themeable.legend_margin",
    "section": "",
    "text": "legend_margin(theme_element)"
  },
  {
    "objectID": "reference/legend_margin.html#parameters",
    "href": "reference/legend_margin.html#parameters",
    "title": " plotnine.themes.themeable.legend_margin",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nValue in points"
  },
  {
    "objectID": "reference/legend_key_spacing_y.html",
    "href": "reference/legend_key_spacing_y.html",
    "title": " plotnine.themes.themeable.legend_key_spacing_y",
    "section": "",
    "text": "legend_key_spacing_y(theme_element)"
  },
  {
    "objectID": "reference/legend_key_spacing_y.html#parameters",
    "href": "reference/legend_key_spacing_y.html#parameters",
    "title": " plotnine.themes.themeable.legend_key_spacing_y",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : int\n\nSize in points"
  },
  {
    "objectID": "reference/legend_key_spacing.html",
    "href": "reference/legend_key_spacing.html",
    "title": " plotnine.themes.themeable.legend_key_spacing",
    "section": "",
    "text": "legend_key_spacing(theme_element)"
  },
  {
    "objectID": "reference/legend_key_spacing.html#parameters",
    "href": "reference/legend_key_spacing.html#parameters",
    "title": " plotnine.themes.themeable.legend_key_spacing",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : int\n\nSize in points"
  },
  {
    "objectID": "reference/legend_key_height.html",
    "href": "reference/legend_key_height.html",
    "title": " plotnine.themes.themeable.legend_key_height",
    "section": "",
    "text": "legend_key_height(theme_element)"
  },
  {
    "objectID": "reference/legend_key_height.html#parameters",
    "href": "reference/legend_key_height.html#parameters",
    "title": " plotnine.themes.themeable.legend_key_height",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nValue in points."
  },
  {
    "objectID": "reference/legend_justification_top.html",
    "href": "reference/legend_justification_top.html",
    "title": " plotnine.themes.themeable.legend_justification_top",
    "section": "",
    "text": "legend_justification_top(theme_element)"
  },
  {
    "objectID": "reference/legend_justification_top.html#parameters",
    "href": "reference/legend_justification_top.html#parameters",
    "title": " plotnine.themes.themeable.legend_justification_top",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : Literal[\"left\", \"center\", \"right\"] | float\n\nHow to justify the entire group with 1 or more guides. i.e. How to slide the legend along the top row. If a float, it should be in the range [0, 1], where 0 is \"left\" and 1 is \"right\"."
  },
  {
    "objectID": "reference/legend_justification_left.html",
    "href": "reference/legend_justification_left.html",
    "title": " plotnine.themes.themeable.legend_justification_left",
    "section": "",
    "text": "legend_justification_left(theme_element)"
  },
  {
    "objectID": "reference/legend_justification_left.html#parameters",
    "href": "reference/legend_justification_left.html#parameters",
    "title": " plotnine.themes.themeable.legend_justification_left",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : Literal[\"bottom\", \"center\", \"top\"] | float\n\nHow to justify the entire group with 1 or more guides. i.e. How to slide the legend along the left column. If a float, it should be in the range [0, 1], where 0 is \"bottom\" and 1 is \"top\"."
  },
  {
    "objectID": "reference/legend_justification_bottom.html",
    "href": "reference/legend_justification_bottom.html",
    "title": " plotnine.themes.themeable.legend_justification_bottom",
    "section": "",
    "text": "legend_justification_bottom(theme_element)"
  },
  {
    "objectID": "reference/legend_justification_bottom.html#parameters",
    "href": "reference/legend_justification_bottom.html#parameters",
    "title": " plotnine.themes.themeable.legend_justification_bottom",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : Literal[\"left\", \"center\", \"right\"] | float\n\nHow to justify the entire group with 1 or more guides. i.e. How to slide the legend along the bottom row. If a float, it should be in the range [0, 1], where 0 is \"left\" and 1 is \"right\"."
  },
  {
    "objectID": "reference/legend_frame.html",
    "href": "reference/legend_frame.html",
    "title": " plotnine.themes.themeable.legend_frame",
    "section": "",
    "text": "legend_frame(theme_element)"
  },
  {
    "objectID": "reference/legend_frame.html#parameters",
    "href": "reference/legend_frame.html#parameters",
    "title": " plotnine.themes.themeable.legend_frame",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_rect"
  },
  {
    "objectID": "reference/legend_box_spacing.html",
    "href": "reference/legend_box_spacing.html",
    "title": " plotnine.themes.themeable.legend_box_spacing",
    "section": "",
    "text": "legend_box_spacing(theme_element)"
  },
  {
    "objectID": "reference/legend_box_spacing.html#parameters",
    "href": "reference/legend_box_spacing.html#parameters",
    "title": " plotnine.themes.themeable.legend_box_spacing",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nValue in points."
  },
  {
    "objectID": "reference/legend_box_just.html",
    "href": "reference/legend_box_just.html",
    "title": " plotnine.themes.themeable.legend_box_just",
    "section": "",
    "text": "legend_box_just(theme_element)"
  },
  {
    "objectID": "reference/legend_box_just.html#parameters",
    "href": "reference/legend_box_just.html#parameters",
    "title": " plotnine.themes.themeable.legend_box_just",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : Literal[\"left\", \"right\", \"center\", \"top\", \"bottom\", \"baseline\"] = None\n\nIf None, the value that will apply depends on legend_box."
  },
  {
    "objectID": "reference/legend_box.html",
    "href": "reference/legend_box.html",
    "title": " plotnine.themes.themeable.legend_box",
    "section": "",
    "text": "legend_box(theme_element)"
  },
  {
    "objectID": "reference/legend_box.html#parameters",
    "href": "reference/legend_box.html#parameters",
    "title": " plotnine.themes.themeable.legend_box",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : Literal[\"vertical\", \"horizontal\"]\n\nWhether to stack up the legends vertically or horizontally."
  },
  {
    "objectID": "reference/layer.html",
    "href": "reference/layer.html",
    "title": " plotnine.layer.layer",
    "section": "",
    "text": "layer(\n    geom,\n    stat,\n    *,\n    mapping,\n    data,\n    position,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False\n)"
  },
  {
    "objectID": "reference/layer.html#parameters",
    "href": "reference/layer.html#parameters",
    "title": " plotnine.layer.layer",
    "section": "Parameters",
    "text": "Parameters\n\n\ngeom : geom\n\ngeom to used to draw this layer.\n\nstat : stat\n\nstat used for the statistical transformation of data in this layer\n\nmapping : aes\n\nAesthetic mappings.\n\ndata : Optional[LayerDataLike]\n\nData plotted in this layer. If None, the data from the ggplot object will be used.\n\nposition : position\n\nPosition object to adjust the geometries in this layer.\n\ninherit_aes : bool = True\n\nIf True inherit from the aesthetic mappings of the ggplot object.\n\nshow_legend : bool | dict[str, bool] | None = None\n\nWhether to make up and show a legend for the mappings of this layer. If None then an automatic/good choice is made\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even if the final image format is vector."
  },
  {
    "objectID": "reference/layer.html#notes",
    "href": "reference/layer.html#notes",
    "title": " plotnine.layer.layer",
    "section": "Notes",
    "text": "Notes\nThere is no benefit to manually creating a layer. You should always use a geom or stat."
  },
  {
    "objectID": "reference/layer.html#methods",
    "href": "reference/layer.html#methods",
    "title": " plotnine.layer.layer",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_aesthetics\nReturn a dataframe where the columns match the aesthetic mappings\n\n\ncompute_position\nCompute the position of each geometric object\n\n\ncompute_statistic\nCompute & return statistics for this layer\n\n\ndraw\nDraw geom\n\n\nfinish_statistics\nPrepare/modify data for plotting\n\n\nfrom_geom\nCreate a layer given a geom\n\n\nmap_statistic\nMapping aesthetics to computed statistics\n\n\nsetup\nPrepare layer for the plot building\n\n\nsetup_data\nPrepare/modify data for plotting\n\n\nuse_defaults\nPrepare/modify data for plotting\n\n\n\n\n compute_aesthetics\n\ncompute_aesthetics(plot)\n\n\nReturn a dataframe where the columns match the aesthetic mappings\nTransformations like ‘factor(cyl)’ and other expression evaluation are made in here\n\n\n\n compute_position\n\ncompute_position(layout)\n\n\nCompute the position of each geometric object\nThis is in concert with the other objects in the panel depending on the position class of the geom\n\n\n\n compute_statistic\n\ncompute_statistic(layout)\n\n\nCompute & return statistics for this layer\n\n\n\n draw\n\ndraw(layout, coord)\n\n\nDraw geom\n\n\nParameters\n\n\nlayout : Layout\n\nLayout object created when the plot is getting built\n\ncoord : coord\n\nType of coordinate axes\n\n\n\n\n\n\n finish_statistics\n\nfinish_statistics()\n\n\nPrepare/modify data for plotting\n\n\n\n from_geom \n\nfrom_geom(geom)\n\n\nCreate a layer given a geom\n\n\nParameters\n\n\ngeom : geom\n\ngeom from which a layer will be created\n\n\n\n\n\nReturns\n\n\nout : layer\n\nLayer that represents the specific geom.\n\n\n\n\n\n\n map_statistic\n\nmap_statistic(plot)\n\n\nMapping aesthetics to computed statistics\n\n\n\n setup\n\nsetup(plot)\n\n\nPrepare layer for the plot building\nGive the layer access to the data, mapping and environment\n\n\n\n setup_data\n\nsetup_data()\n\n\nPrepare/modify data for plotting\n\n\n\n use_defaults\n\nuse_defaults(data, aes_modifiers, scales=None)\n\n\nPrepare/modify data for plotting\n\n\nParameters\n\n\ndata : pd.DataFrame\n\nData\n\naes_modifiers : dict[str, Any]\n\nExpression to evaluate and replace aesthetics in the data."
  },
  {
    "objectID": "reference/labeller.html",
    "href": "reference/labeller.html",
    "title": " plotnine.labeller",
    "section": "",
    "text": "labeller(\n    rows=None, cols=None, multi_line=True, default=\"label_value\", kwargs={}\n)"
  },
  {
    "objectID": "reference/labeller.html#parameters",
    "href": "reference/labeller.html#parameters",
    "title": " plotnine.labeller",
    "section": "Parameters",
    "text": "Parameters\n\n\nrows : str | callable = None\n\nHow to label the rows\n\ncols : str | callable = None\n\nHow to label the columns\n\nmulti_line : bool = True\n\nWhether to place each variable on a separate line\n\ndefault : str | callable = \"label_value\"\n\nFallback labelling function. If it is a string, it should be one of [\"label_value\", \"label_both\", \"label_context\"].\n\nkwargs : dict = {}\n\n{variable name : function | string} pairs for renaming variables. A function to rename the variable or a string name."
  },
  {
    "objectID": "reference/label_context.html",
    "href": "reference/label_context.html",
    "title": " plotnine.label_context",
    "section": "",
    "text": "label_context(label_info, multi_line=True, sep=\": \")"
  },
  {
    "objectID": "reference/label_context.html#parameters",
    "href": "reference/label_context.html#parameters",
    "title": " plotnine.label_context",
    "section": "Parameters",
    "text": "Parameters\n\n\nlabel_info : strip_label_details\n\nLabel information\n\nmulti_line : bool = True\n\nWhether to place each variable on a separate line\n\nsep : str = \": \"\n\nSeparation between variable name and value"
  },
  {
    "objectID": "reference/label_context.html#returns",
    "href": "reference/label_context.html#returns",
    "title": " plotnine.label_context",
    "section": "Returns",
    "text": "Returns\n\n\nout : str\n\nConcatenated label values (or pairs of variable names & values)"
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "API Reference",
    "section": "",
    "text": "ggplot\nCreate a new ggplot object\n\n\nqplot\nQuick plot\n\n\nwatermark\nAdd watermark to plot\n\n\nlayer\nLayer\n\n\nPlotnineAnimation\nAnimation using ggplot objects\n\n\nsave_as_pdf_pages\nSave multiple ggplot objects to a PDF file, one per page.\n\n\n\n\n\n\n\nAesthetics are the visual properties of a plot. The following functions control how the data (and calculations based on the data) is mapped to the aesthetics.\n\n\n\n\naes\nCreate aesthetic mappings\n\n\nafter_stat\nEvaluate mapping after statistic has been calculated\n\n\nafter_scale\nEvaluate mapping after variable has been mapped to the scale\n\n\nstage\nStage allows you evaluating mapping at more than one stage\n\n\n\n\n\n\nThe expressions you write in the aes() call are evaluated inside an environment with a few functions that you may need from time to time. These functions are for your convenience, and you can expect them to to always be there.\n\n\n\n\nfactor\nTurn x in to a categorical (factor) variable\n\n\nreorder\nReorder categorical by sorting along another variable\n\n\n\n\n\n\n\n\nGeometric objects (geoms) are responsible for the visual representation of data points. geom_* classes determine the kind of geometric objects and every plot must have at least one geom added to it. The distinct visual aspects of the representation are controlled by the aes mapping.\n\n\n\n\ngeom\nBase class of all Geoms\n\n\n\n\n\n\n\n\ngeom_abline\nLines specified by slope and intercept\n\n\ngeom_area\nArea plot\n\n\ngeom_bar\nBar plot\n\n\ngeom_bin_2d\nHeatmap of 2d bin counts\n\n\ngeom_blank\nAn empty plot\n\n\ngeom_boxplot\nBox and whiskers plot\n\n\ngeom_col\nBar plot with base on the x-axis\n\n\ngeom_count\nPlot overlapping points\n\n\ngeom_crossbar\nVertical interval represented by a crossbar\n\n\ngeom_density\nSmooth density estimate\n\n\ngeom_density_2d\n2D density estimate\n\n\ngeom_dotplot\nDot plot\n\n\ngeom_errorbar\nVertical interval represented as an errorbar\n\n\ngeom_errorbarh\nHorizontal interval represented as an errorbar\n\n\ngeom_freqpoly\nFrequency polygon\n\n\ngeom_histogram\nHistogram\n\n\ngeom_hline\nHorizontal line\n\n\ngeom_jitter\nScatter plot with points jittered to reduce overplotting\n\n\ngeom_label\nTextual annotations with a background\n\n\ngeom_line\nConnected points\n\n\ngeom_linerange\nVertical interval represented by lines\n\n\ngeom_map\nDraw map feature\n\n\ngeom_path\nConnected points\n\n\ngeom_point\nPlot points (Scatter plot)\n\n\ngeom_pointdensity\nScatterplot with density estimation at each point\n\n\ngeom_pointrange\nVertical interval represented by a line with a point\n\n\ngeom_polygon\nPolygon, a filled path\n\n\ngeom_qq\nQuantile-Quantile plot\n\n\ngeom_qq_line\nQuantile-Quantile Line plot\n\n\ngeom_quantile\nQuantile lines from a quantile regression\n\n\ngeom_raster\nRasterized Rectangles specified using center points\n\n\ngeom_rect\nRectangles\n\n\ngeom_ribbon\nRibbon plot\n\n\ngeom_rug\nMarginal rug plot\n\n\ngeom_segment\nLine segments\n\n\ngeom_sina\nDraw a sina plot\n\n\ngeom_smooth\nA smoothed conditional mean\n\n\ngeom_spoke\nLine segment parameterised by location, direction and distance\n\n\ngeom_step\nStepped connected points\n\n\ngeom_text\nTextual annotations\n\n\ngeom_tile\nRectangles specified using a center points\n\n\ngeom_violin\nViolin Plot\n\n\ngeom_vline\nVertical line\n\n\n\n\n\n\n\n\n\n\nannotate\nCreate an annotation layer\n\n\nannotation_logticks\nMarginal log ticks.\n\n\nannotation_stripes\nAlternating stripes, centered around each label.\n\n\narrow\nDefine arrow (actually an arrowhead)\n\n\n\n\n\n\n\n\n\n\n\nlabs\nAdd labels for any aesthetics with a scale or title, subtitle & caption\n\n\nxlab\nLabel/name for the x aesthetic\n\n\nylab\nLabel/name for the y aesthetic\n\n\nggtitle\nCreate plot title\n\n\n\n\n\n\n\n\nStatistical transformations (stats) do aggregations and other computations on data before it is drawn out. stat_* determine the type of computation done on the data. Different types of computations yield varied results, so a stat must be paired with a geom that can represent all or some of the computations.\n\n\n\n\nstat\nBase class of all stats\n\n\n\n\n\n\n\n\nstat_bin\nCount cases in each interval\n\n\nstat_bin_2d\n2 Dimensional bin counts\n\n\nstat_bindot\nBinning for a dot plot\n\n\nstat_boxplot\nCompute boxplot statistics\n\n\nstat_count\nCounts the number of cases at each x position\n\n\nstat_density\nCompute density estimate\n\n\nstat_density_2d\nCompute 2D kernel density estimation\n\n\nstat_ecdf\nEmpirical Cumulative Density Function\n\n\nstat_ellipse\nCalculate normal confidence interval ellipse\n\n\nstat_function\nSuperimpose a function onto a plot\n\n\nstat_hull\n2 Dimensional Convex Hull\n\n\nstat_identity\nIdentity (do nothing) statistic\n\n\nstat_qq\nCalculation for quantile-quantile plot\n\n\nstat_qq_line\nCalculate line through quantile-quantile plot\n\n\nstat_quantile\nCompute quantile regression lines\n\n\nstat_sina\nCompute Sina plot values\n\n\nstat_smooth\nCalculate a smoothed conditional mean\n\n\nstat_sum\nSum unique values\n\n\nstat_summary\nCalculate summary statistics depending on x\n\n\nstat_summary_bin\nSummarise y values at x intervals\n\n\nstat_unique\nRemove duplicates\n\n\nstat_ydensity\nDensity estimate\n\n\n\n\n\n\n\nFaceting is a way to subset data and plot it on different panels.\n\n\n\n\nfacet\nBase class for all facets\n\n\n\n\n\n\n\n\nfacet_grid\nWrap 1D Panels onto 2D surface\n\n\nfacet_null\nA single Panel\n\n\nfacet_wrap\nWrap 1D Panels onto 2D surface\n\n\nlabeller\nFacet Strip Labelling\n\n\nas_labeller\nCoerse to labeller\n\n\nlabel_value\nKeep value as the label\n\n\nlabel_both\nConcatenate the facet variable with the value\n\n\nlabel_context\nCreate an unabiguous label string\n\n\n\n\n\n\n\nScales control the mapping from data to aesthetics. They take data and adjust it to fit the different aspects of the visual sense i.e. length, colour, size and shape.\n\n\n\n\n\n\nscale\nBase class for all scales\n\n\nscale_discrete\nBase class for all discrete scales\n\n\nscale_continuous\nBase class for all continuous scales\n\n\nscale_datetime\nBase class for all date/datetime scales\n\n\n\n\n\n\n\n\n\n\n\nscale_alpha\nContinuous Alpha Scale\n\n\nscale_alpha_continuous\nalias of scale_alpha\n\n\nscale_alpha_datetime\nDatetime Alpha Scale\n\n\nscale_alpha_discrete\nDiscrete Alpha Scale\n\n\nscale_alpha_ordinal\nOrdinal Alpha Scale\n\n\n\n\n\n\n\n\n\n\n\nscale_color_brewer\nSequential, diverging and qualitative discrete color scales\n\n\nscale_color_cmap\nCreate color scales using Matplotlib colormaps\n\n\nscale_color_cmap_d\nA discrete color scales using Matplotlib colormaps\n\n\nscale_color_continuous\nalias of scale_color_cmap\n\n\nscale_color_datetime\nDatetime color scale\n\n\nscale_color_desaturate\nCreate a desaturated color gradient\n\n\nscale_color_discrete\nalias of scale_color_hue\n\n\nscale_color_distiller\nSequential and diverging continuous color scales\n\n\nscale_color_gradient\nCreate a 2 point color gradient\n\n\nscale_color_gradient2\nCreate a 3 point diverging color gradient\n\n\nscale_color_gradientn\nCreate a n color gradient\n\n\nscale_color_gray\nalias of scale_color_grey\n\n\nscale_color_grey\nSequential grey color scale.\n\n\nscale_color_hue\nQualitative color scale with evenly spaced hues\n\n\nscale_color_ordinal\nalias of scale_color_cmap_d\n\n\nscale_fill_brewer\nSequential, diverging and qualitative color scales\n\n\nscale_fill_cmap\nCreate color scales using Matplotlib colormaps\n\n\nscale_fill_cmap_d\nCreate color scales using Matplotlib colormaps\n\n\nscale_fill_continuous\nalias of scale_fill_cmap\n\n\nscale_fill_datetime\nDatetime fill scale\n\n\nscale_fill_desaturate\nCreate a desaturated color gradient\n\n\nscale_fill_discrete\nalias of scale_fill_hue\n\n\nscale_fill_distiller\nSequential, diverging continuous color scales\n\n\nscale_fill_gradient\nCreate a 2 point color gradient\n\n\nscale_fill_gradient2\nCreate a 3 point diverging color gradient\n\n\nscale_fill_gradientn\nCreate a n color gradient\n\n\nscale_fill_gray\nalias of scale_fill_grey\n\n\nscale_fill_grey\nSequential grey color scale.\n\n\nscale_fill_hue\nQualitative color scale with evenly spaced hues\n\n\nscale_fill_ordinal\nalias of scale_fill_cmap_d\n\n\n\n\n\n\n\n\n\n\n\nscale_alpha_identity\nNo alpha scaling\n\n\nscale_color_identity\nNo color scaling\n\n\nscale_colour_identity\nalias of scale_color_identity\n\n\nscale_fill_identity\nNo color scaling\n\n\nscale_linetype_identity\nNo linetype scaling\n\n\nscale_shape_identity\nNo shape scaling\n\n\nscale_size_identity\nNo size scaling\n\n\n\n\n\n\n\n\n\n\n\nscale_linetype\nScale for line patterns\n\n\nscale_linetype_discrete\nalias of scale_linetype\n\n\n\n\n\n\n\n\n\n\n\nscale_alpha_manual\nCustom discrete alpha scale\n\n\nscale_color_manual\nCustom discrete color scale\n\n\nscale_colour_manual\nalias of scale_color_manual\n\n\nscale_fill_manual\nCustom discrete fill scale\n\n\nscale_linetype_manual\nCustom discrete linetype scale\n\n\nscale_shape_manual\nCustom discrete shape scale\n\n\nscale_size_manual\nCustom discrete size scale\n\n\n\n\n\n\n\n\n\n\n\nscale_x_continuous\nContinuous x position\n\n\nscale_x_date\nalias of scale_x_datetime\n\n\nscale_x_datetime\nContinuous x position for datetime data points\n\n\nscale_x_discrete\nDiscrete x position\n\n\nscale_x_log10\nContinuous x position log10 transformed scale\n\n\nscale_x_reverse\nContinuous x position reverse transformed scale\n\n\nscale_x_sqrt\nContinuous x position sqrt transformed scale\n\n\nscale_x_symlog\nContinuous x position symmetric logarithm transformed scale\n\n\nscale_x_timedelta\nContinuous x position for timedelta data points\n\n\nscale_y_continuous\nContinuous y position\n\n\nscale_y_date\nalias of scale_y_datetime\n\n\nscale_y_datetime\nContinuous y position for datetime data points\n\n\nscale_y_discrete\nDiscrete y position\n\n\nscale_y_log10\nContinuous y position log10 transformed scale\n\n\nscale_y_reverse\nContinuous y position reverse transformed scale\n\n\nscale_y_sqrt\nContinuous y position sqrt transformed scale\n\n\nscale_y_symlog\nContinuous y position symmetric logarithm transformed scale\n\n\nscale_y_timedelta\nContinuous y position for timedelta data points\n\n\n\n\n\n\n\n\n\n\n\nscale_shape\nScale for shapes\n\n\nscale_shape_discrete\nalias of scale_shape\n\n\n\n\n\n\n\n\n\n\n\nscale_size\nalias of scale_size_continuous\n\n\nscale_size_area\nContinuous area size scale\n\n\nscale_size_continuous\nContinuous area size scale\n\n\nscale_size_datetime\nDatetime area-size scale\n\n\nscale_size_discrete\nDiscrete area size scale\n\n\nscale_size_ordinal\nDiscrete area size scale\n\n\nscale_size_radius\nContinuous radius size scale\n\n\n\n\n\n\n\n\n\n\n\nscale_stroke\nalias of scale_stroke_continuous\n\n\nscale_stroke_continuous\nContinuous Stroke Scale\n\n\n\n\n\n\n\n\n\n\n\nlims\nSet aesthetic limits\n\n\nxlim\nSet x-axis limits\n\n\nylim\nSet y-axis limits\n\n\nexpand_limits\nExpand the limits any aesthetic using data\n\n\n\n\n\n\n\n\nGuides allow you to interpret data represented on a scales. Guides include the x and y axes, legends and colorbars.\n\n\n\n\nguide\nBase class for all guides\n\n\n\n\n\n\n\n\nguides\nGuides for each scale\n\n\nguide_legend\nLegend guide\n\n\nguide_colorbar\nGuide colorbar\n\n\n\n\n\n\n\nOverlapping objects can be visualized better if their positions are adjusted. That is what the position_* class do. Each geom is associated with one position adjustment class.\n\n\n\n\nposition\nBase class for all positions\n\n\n\n\n\n\n\n\nposition_dodge\nDodge overlaps and place objects side-by-side\n\n\nposition_dodge2\nDodge overlaps and place objects side-by-side\n\n\nposition_fill\nNormalise stacked objects to unit height\n\n\nposition_identity\nDo not adjust the position\n\n\nposition_jitter\nJitter points to avoid overplotting\n\n\nposition_jitterdodge\nDodge and jitter to minimise overlap\n\n\nposition_nudge\nNudge points\n\n\nposition_stack\nStack plotted objects on top of each other\n\n\n\n\n\n\n\nThemes control the visual appearance of the non-data elements the plot.\n\n\n\n\ntheme\nBase class for themes\n\n\n\n\n\n\n\n\ntheme_538\nTheme in the likeness of fivethirtyeight.com plots\n\n\ntheme_bw\nWhite background with black gridlines\n\n\ntheme_classic\nA classic-looking theme, with x & y axis lines and no gridlines\n\n\ntheme_dark\nThe dark cousin of theme_light\n\n\ntheme_gray\nA gray background with white gridlines.\n\n\ntheme_grey\nalias of theme_gray\n\n\ntheme_light\nA theme similar to theme_linedraw\n\n\ntheme_linedraw\nA theme with only black lines of various widths on white backgrounds\n\n\ntheme_matplotlib\nThe default matplotlib look and feel.\n\n\ntheme_minimal\nA minimalistic theme with no background annotations\n\n\ntheme_seaborn\nTheme for seaborn.\n\n\ntheme_tufte\nTufte Maximal Data, Minimal Ink Theme\n\n\ntheme_void\nA classic-looking theme, with x & y axis lines and\n\n\ntheme_xkcd\nxkcd theme\n\n\n\n\n\n\nThese define aspects of a plot that can be themed. They can be used to create a new theme or modify an existing theme. They define the keyword arguments to theme. Users should never create instances of themeable.\n\n\n\n\nthemeable\nAbstract class of things that can be themed.\n\n\n\n\n\n\n\n\naspect_ratio\nAspect ratio of the panel(s)\n\n\naxis_line\nx & y axis lines\n\n\naxis_line_x\nx-axis line\n\n\naxis_line_y\ny-axis line\n\n\naxis_text\nAxis tick labels\n\n\naxis_text_x\nx-axis tick labels\n\n\naxis_text_y\ny-axis tick labels\n\n\naxis_ticks\nx & y major and minor axis tick lines\n\n\naxis_ticks_length\nAxis tick length\n\n\naxis_ticks_length_major\nAxis major-tick length\n\n\naxis_ticks_length_major_x\nx-axis major-tick length\n\n\naxis_ticks_length_major_y\ny-axis major-tick length\n\n\naxis_ticks_length_minor\nAxis minor-tick length\n\n\naxis_ticks_length_minor_x\nx-axis minor-tick length\n\n\naxis_ticks_length_minor_y\nx-axis minor-tick length\n\n\naxis_ticks_major\nx & y axis major tick lines\n\n\naxis_ticks_major_x\nx-axis major tick lines\n\n\naxis_ticks_major_y\ny-axis major tick lines\n\n\naxis_ticks_minor\nx & y axis minor tick lines\n\n\naxis_ticks_minor_x\nx-axis tick lines\n\n\naxis_ticks_minor_y\ny-axis minor tick lines\n\n\naxis_ticks_x\nx major and minor axis tick lines\n\n\naxis_ticks_y\ny major and minor axis tick lines\n\n\naxis_title\nAxis labels\n\n\naxis_title_x\nx axis label\n\n\naxis_title_y\ny axis label\n\n\ndpi\nDPI with which to draw/save the figure\n\n\nfigure_size\nFigure size in inches\n\n\nlegend_background\nLegend background\n\n\nlegend_box\nHow to box up multiple legends\n\n\nlegend_box_background\nLegend box background\n\n\nlegend_box_just\nJustification of guide boxes\n\n\nlegend_box_margin\nPadding between the legends and the box\n\n\nlegend_box_spacing\nSpacing between the legend and the plotting area\n\n\nlegend_direction\nLayout items in the legend\n\n\nlegend_key_spacing\nSpacing between two entries in a legend\n\n\nlegend_key_spacing_x\nHorizontal spacing between two entries in a legend\n\n\nlegend_key_spacing_y\nVertical spacing between two entries in a legend\n\n\nlegend_frame\nFrame around colorbar\n\n\nlegend_justification\nJustification of any legend\n\n\nlegend_justification_bottom\nJustification of legends placed at the bottom\n\n\nlegend_justification_inside\nJustification of legends placed inside the axes\n\n\nlegend_justification_left\nJustification of legends placed on the left\n\n\nlegend_justification_right\nJustification of legends placed on the right\n\n\nlegend_justification_top\nJustification of legends placed at the top\n\n\nlegend_key\nLegend key background\n\n\nlegend_key_height\nLegend key background height\n\n\nlegend_key_size\nLegend key background width and height\n\n\nlegend_key_width\nLegend key background width\n\n\nlegend_margin\nPadding between the legend and the inner box\n\n\nlegend_position\nLocation of legend\n\n\nlegend_position_inside\nLocation of legend\n\n\nlegend_spacing\nSpacing between two adjacent legends\n\n\nlegend_text\nLegend text\n\n\nlegend_text_colorbar\nColorbar text\n\n\nlegend_text_legend\nLegend text for the common legend\n\n\nlegend_text_position\nPosition of the legend text\n\n\nlegend_ticks_length\nLength of ticks in the legend\n\n\nlegend_title\nLegend title\n\n\nlegend_title_position\nPosition of legend title\n\n\nline\nAll line elements\n\n\npanel_background\nPanel background\n\n\npanel_border\nPanel border\n\n\npanel_grid\nGrid lines\n\n\npanel_grid_major\nMajor grid lines\n\n\npanel_grid_major_x\nVertical major grid lines\n\n\npanel_grid_major_y\nHorizontal major grid lines\n\n\npanel_grid_minor\nMinor grid lines\n\n\npanel_grid_minor_x\nVertical minor grid lines\n\n\npanel_grid_minor_y\nHorizontal minor grid lines\n\n\npanel_ontop\nPlace panel background & gridlines over/under the data layers\n\n\npanel_spacing\nSpacing between the facet panels\n\n\npanel_spacing_x\nHorizontal spacing between the facet panels\n\n\npanel_spacing_y\nVertical spacing between the facet panels\n\n\nplot_background\nPlot background\n\n\nplot_caption\nPlot caption\n\n\nplot_caption_position\nHow to align the plot caption\n\n\nplot_margin\nPlot Margin\n\n\nplot_margin_bottom\nPlot Margin at the bottom\n\n\nplot_margin_left\nPlot Margin on the left\n\n\nplot_margin_right\nPlot Margin on the right\n\n\nplot_margin_top\nPlot Margin at the top\n\n\nplot_subtitle\nPlot subtitle\n\n\nplot_tag\nPlot tag\n\n\nplot_tag_location\nThe area where the tag will be positioned\n\n\nplot_tag_position\nPosition of the tag\n\n\nplot_title\nPlot title\n\n\nplot_title_position\nHow to align the plot title and plot subtitle\n\n\nrect\nAll rectangle elements\n\n\nstrip_align\nAlignment of the strip & its background w.r.t the panel border\n\n\nstrip_align_x\nVertical alignment of the strip & its background w.r.t the panel border\n\n\nstrip_align_y\nHorizontal alignment of the strip & its background w.r.t the panel border\n\n\nstrip_background\nFacet label background\n\n\nstrip_background_x\nHorizontal facet label background\n\n\nstrip_background_y\nVertical facet label background\n\n\nstrip_text\nFacet labels along both axes\n\n\nstrip_text_x\nFacet labels along the horizontal axis\n\n\nstrip_text_y\nFacet labels along the vertical axis\n\n\nsubplots_adjust\n\n\n\nsvg_usefonts\nHow to renderer fonts for svg images\n\n\ntext\nAll text elements in the plot\n\n\ntitle\nAll titles on the plot\n\n\n\n\n\n\n\n\n\n\n\ntheme_set\nChange the current(default) theme\n\n\ntheme_get\nReturn the default theme\n\n\ntheme_update\nModify elements of the current theme\n\n\n\n\n\n\n\n\nelement_line\ntheme element: line\n\n\nelement_rect\nTheme element: Rectangle\n\n\nelement_text\nTheme element: Text\n\n\nelement_blank\nTheme element: Blank\n\n\n\n\n\n\n\n\nCoordinate systems put together the two position scales to produce a 2d location.\n\n\n\n\ncoord\nBase class for all coordinate systems\n\n\n\n\n\n\n\n\ncoord_cartesian\nCartesian coordinate system\n\n\ncoord_equal\nCartesian coordinates with fixed relationship between x and y scales\n\n\ncoord_fixed\nCartesian coordinates with fixed relationship between x and y scales\n\n\ncoord_flip\nFlipped cartesian coordinates\n\n\ncoord_trans\nTransformed cartesian coordinate system\n\n\n\n\n\n\n\nWhen working interactively, some of the options make it convenient to create plots that have a common look and feel.\n\n\nThese are the methods that access the options.\n\n\n\n\nget_option\nGet package option\n\n\nset_option\nSet package option\n\n\n\n\n\n\n\nThese are all the options that you can set or get the values of.\n\n\n\n\naspect_ratio\nDefault aspect ratio used by the themes\n\n\nbase_family\nThe base font family for all text that is part of the theme.\n\n\nbase_margin\nA size that is proportional of the figure width and\n\n\ncurrent_theme\nTheme used when none is added to the ggplot object\n\n\ndpi\nDefault DPI used by the themes\n\n\nfigure_size\nDefault figure size in inches\n\n\nfigure_format\nThe format for the inline figures outputted by the jupyter kernel.\n\n\n\n\n\n\n\n\nFunctions that you may occasioanally find helpful\n\n\n\n\nget_aesthetic_limits\nGet the limits of an aesthetic\n\n\n\n\n\n\n\nThese datasets ship with the plotnine and you can import them with from the plotnine.data sub-package.\n\n\n\n\nanscombe_quartet\nAnscombe’s Quartet\n\n\ndiamonds\nPrices of 50,000 round cut diamonds\n\n\neconomics\nUS economic time series.\n\n\neconomics_long\nUS economic time series.\n\n\nfaithful\nOld Faithful Geyser Data\n\n\nfaithfuld\nOld Faithful Geyser Data\n\n\nhuron\nLevel of Lake Huron 1875–1972\n\n\nluv_colours\ncolors in Luv space.\n\n\nmeat\nUS Meat Production\n\n\nmidwest\nMidwest demographics.\n\n\nmpg\nFuel economy data from 1999 and 2008 for 38 popular models of car\n\n\nmsleep\nAn updated and expanded version of the mammals sleep dataset.\n\n\nmtcars\nMotor Trend Car Road Tests\n\n\npageviews\n\n\n\npresidential\nTerms of 11 presidents from Eisenhower to Obama.\n\n\nseals\nVector field of seal movements.\n\n\ntxhousing\nHousing sales in TX."
  },
  {
    "objectID": "reference/index.html#creating-a-plot",
    "href": "reference/index.html#creating-a-plot",
    "title": "API Reference",
    "section": "",
    "text": "ggplot\nCreate a new ggplot object\n\n\nqplot\nQuick plot\n\n\nwatermark\nAdd watermark to plot\n\n\nlayer\nLayer\n\n\nPlotnineAnimation\nAnimation using ggplot objects\n\n\nsave_as_pdf_pages\nSave multiple ggplot objects to a PDF file, one per page."
  },
  {
    "objectID": "reference/index.html#mapping-aesthetics",
    "href": "reference/index.html#mapping-aesthetics",
    "title": "API Reference",
    "section": "",
    "text": "Aesthetics are the visual properties of a plot. The following functions control how the data (and calculations based on the data) is mapped to the aesthetics.\n\n\n\n\naes\nCreate aesthetic mappings\n\n\nafter_stat\nEvaluate mapping after statistic has been calculated\n\n\nafter_scale\nEvaluate mapping after variable has been mapped to the scale\n\n\nstage\nStage allows you evaluating mapping at more than one stage\n\n\n\n\n\n\nThe expressions you write in the aes() call are evaluated inside an environment with a few functions that you may need from time to time. These functions are for your convenience, and you can expect them to to always be there.\n\n\n\n\nfactor\nTurn x in to a categorical (factor) variable\n\n\nreorder\nReorder categorical by sorting along another variable"
  },
  {
    "objectID": "reference/index.html#geoms",
    "href": "reference/index.html#geoms",
    "title": "API Reference",
    "section": "",
    "text": "Geometric objects (geoms) are responsible for the visual representation of data points. geom_* classes determine the kind of geometric objects and every plot must have at least one geom added to it. The distinct visual aspects of the representation are controlled by the aes mapping.\n\n\n\n\ngeom\nBase class of all Geoms\n\n\n\n\n\n\n\n\ngeom_abline\nLines specified by slope and intercept\n\n\ngeom_area\nArea plot\n\n\ngeom_bar\nBar plot\n\n\ngeom_bin_2d\nHeatmap of 2d bin counts\n\n\ngeom_blank\nAn empty plot\n\n\ngeom_boxplot\nBox and whiskers plot\n\n\ngeom_col\nBar plot with base on the x-axis\n\n\ngeom_count\nPlot overlapping points\n\n\ngeom_crossbar\nVertical interval represented by a crossbar\n\n\ngeom_density\nSmooth density estimate\n\n\ngeom_density_2d\n2D density estimate\n\n\ngeom_dotplot\nDot plot\n\n\ngeom_errorbar\nVertical interval represented as an errorbar\n\n\ngeom_errorbarh\nHorizontal interval represented as an errorbar\n\n\ngeom_freqpoly\nFrequency polygon\n\n\ngeom_histogram\nHistogram\n\n\ngeom_hline\nHorizontal line\n\n\ngeom_jitter\nScatter plot with points jittered to reduce overplotting\n\n\ngeom_label\nTextual annotations with a background\n\n\ngeom_line\nConnected points\n\n\ngeom_linerange\nVertical interval represented by lines\n\n\ngeom_map\nDraw map feature\n\n\ngeom_path\nConnected points\n\n\ngeom_point\nPlot points (Scatter plot)\n\n\ngeom_pointdensity\nScatterplot with density estimation at each point\n\n\ngeom_pointrange\nVertical interval represented by a line with a point\n\n\ngeom_polygon\nPolygon, a filled path\n\n\ngeom_qq\nQuantile-Quantile plot\n\n\ngeom_qq_line\nQuantile-Quantile Line plot\n\n\ngeom_quantile\nQuantile lines from a quantile regression\n\n\ngeom_raster\nRasterized Rectangles specified using center points\n\n\ngeom_rect\nRectangles\n\n\ngeom_ribbon\nRibbon plot\n\n\ngeom_rug\nMarginal rug plot\n\n\ngeom_segment\nLine segments\n\n\ngeom_sina\nDraw a sina plot\n\n\ngeom_smooth\nA smoothed conditional mean\n\n\ngeom_spoke\nLine segment parameterised by location, direction and distance\n\n\ngeom_step\nStepped connected points\n\n\ngeom_text\nTextual annotations\n\n\ngeom_tile\nRectangles specified using a center points\n\n\ngeom_violin\nViolin Plot\n\n\ngeom_vline\nVertical line\n\n\n\n\n\n\n\n\n\n\nannotate\nCreate an annotation layer\n\n\nannotation_logticks\nMarginal log ticks.\n\n\nannotation_stripes\nAlternating stripes, centered around each label.\n\n\narrow\nDefine arrow (actually an arrowhead)\n\n\n\n\n\n\n\n\n\n\n\nlabs\nAdd labels for any aesthetics with a scale or title, subtitle & caption\n\n\nxlab\nLabel/name for the x aesthetic\n\n\nylab\nLabel/name for the y aesthetic\n\n\nggtitle\nCreate plot title"
  },
  {
    "objectID": "reference/index.html#stats",
    "href": "reference/index.html#stats",
    "title": "API Reference",
    "section": "",
    "text": "Statistical transformations (stats) do aggregations and other computations on data before it is drawn out. stat_* determine the type of computation done on the data. Different types of computations yield varied results, so a stat must be paired with a geom that can represent all or some of the computations.\n\n\n\n\nstat\nBase class of all stats\n\n\n\n\n\n\n\n\nstat_bin\nCount cases in each interval\n\n\nstat_bin_2d\n2 Dimensional bin counts\n\n\nstat_bindot\nBinning for a dot plot\n\n\nstat_boxplot\nCompute boxplot statistics\n\n\nstat_count\nCounts the number of cases at each x position\n\n\nstat_density\nCompute density estimate\n\n\nstat_density_2d\nCompute 2D kernel density estimation\n\n\nstat_ecdf\nEmpirical Cumulative Density Function\n\n\nstat_ellipse\nCalculate normal confidence interval ellipse\n\n\nstat_function\nSuperimpose a function onto a plot\n\n\nstat_hull\n2 Dimensional Convex Hull\n\n\nstat_identity\nIdentity (do nothing) statistic\n\n\nstat_qq\nCalculation for quantile-quantile plot\n\n\nstat_qq_line\nCalculate line through quantile-quantile plot\n\n\nstat_quantile\nCompute quantile regression lines\n\n\nstat_sina\nCompute Sina plot values\n\n\nstat_smooth\nCalculate a smoothed conditional mean\n\n\nstat_sum\nSum unique values\n\n\nstat_summary\nCalculate summary statistics depending on x\n\n\nstat_summary_bin\nSummarise y values at x intervals\n\n\nstat_unique\nRemove duplicates\n\n\nstat_ydensity\nDensity estimate"
  },
  {
    "objectID": "reference/index.html#facets",
    "href": "reference/index.html#facets",
    "title": "API Reference",
    "section": "",
    "text": "Faceting is a way to subset data and plot it on different panels.\n\n\n\n\nfacet\nBase class for all facets\n\n\n\n\n\n\n\n\nfacet_grid\nWrap 1D Panels onto 2D surface\n\n\nfacet_null\nA single Panel\n\n\nfacet_wrap\nWrap 1D Panels onto 2D surface\n\n\nlabeller\nFacet Strip Labelling\n\n\nas_labeller\nCoerse to labeller\n\n\nlabel_value\nKeep value as the label\n\n\nlabel_both\nConcatenate the facet variable with the value\n\n\nlabel_context\nCreate an unabiguous label string"
  },
  {
    "objectID": "reference/index.html#scales",
    "href": "reference/index.html#scales",
    "title": "API Reference",
    "section": "",
    "text": "Scales control the mapping from data to aesthetics. They take data and adjust it to fit the different aspects of the visual sense i.e. length, colour, size and shape.\n\n\n\n\n\n\nscale\nBase class for all scales\n\n\nscale_discrete\nBase class for all discrete scales\n\n\nscale_continuous\nBase class for all continuous scales\n\n\nscale_datetime\nBase class for all date/datetime scales\n\n\n\n\n\n\n\n\n\n\n\nscale_alpha\nContinuous Alpha Scale\n\n\nscale_alpha_continuous\nalias of scale_alpha\n\n\nscale_alpha_datetime\nDatetime Alpha Scale\n\n\nscale_alpha_discrete\nDiscrete Alpha Scale\n\n\nscale_alpha_ordinal\nOrdinal Alpha Scale\n\n\n\n\n\n\n\n\n\n\n\nscale_color_brewer\nSequential, diverging and qualitative discrete color scales\n\n\nscale_color_cmap\nCreate color scales using Matplotlib colormaps\n\n\nscale_color_cmap_d\nA discrete color scales using Matplotlib colormaps\n\n\nscale_color_continuous\nalias of scale_color_cmap\n\n\nscale_color_datetime\nDatetime color scale\n\n\nscale_color_desaturate\nCreate a desaturated color gradient\n\n\nscale_color_discrete\nalias of scale_color_hue\n\n\nscale_color_distiller\nSequential and diverging continuous color scales\n\n\nscale_color_gradient\nCreate a 2 point color gradient\n\n\nscale_color_gradient2\nCreate a 3 point diverging color gradient\n\n\nscale_color_gradientn\nCreate a n color gradient\n\n\nscale_color_gray\nalias of scale_color_grey\n\n\nscale_color_grey\nSequential grey color scale.\n\n\nscale_color_hue\nQualitative color scale with evenly spaced hues\n\n\nscale_color_ordinal\nalias of scale_color_cmap_d\n\n\nscale_fill_brewer\nSequential, diverging and qualitative color scales\n\n\nscale_fill_cmap\nCreate color scales using Matplotlib colormaps\n\n\nscale_fill_cmap_d\nCreate color scales using Matplotlib colormaps\n\n\nscale_fill_continuous\nalias of scale_fill_cmap\n\n\nscale_fill_datetime\nDatetime fill scale\n\n\nscale_fill_desaturate\nCreate a desaturated color gradient\n\n\nscale_fill_discrete\nalias of scale_fill_hue\n\n\nscale_fill_distiller\nSequential, diverging continuous color scales\n\n\nscale_fill_gradient\nCreate a 2 point color gradient\n\n\nscale_fill_gradient2\nCreate a 3 point diverging color gradient\n\n\nscale_fill_gradientn\nCreate a n color gradient\n\n\nscale_fill_gray\nalias of scale_fill_grey\n\n\nscale_fill_grey\nSequential grey color scale.\n\n\nscale_fill_hue\nQualitative color scale with evenly spaced hues\n\n\nscale_fill_ordinal\nalias of scale_fill_cmap_d\n\n\n\n\n\n\n\n\n\n\n\nscale_alpha_identity\nNo alpha scaling\n\n\nscale_color_identity\nNo color scaling\n\n\nscale_colour_identity\nalias of scale_color_identity\n\n\nscale_fill_identity\nNo color scaling\n\n\nscale_linetype_identity\nNo linetype scaling\n\n\nscale_shape_identity\nNo shape scaling\n\n\nscale_size_identity\nNo size scaling\n\n\n\n\n\n\n\n\n\n\n\nscale_linetype\nScale for line patterns\n\n\nscale_linetype_discrete\nalias of scale_linetype\n\n\n\n\n\n\n\n\n\n\n\nscale_alpha_manual\nCustom discrete alpha scale\n\n\nscale_color_manual\nCustom discrete color scale\n\n\nscale_colour_manual\nalias of scale_color_manual\n\n\nscale_fill_manual\nCustom discrete fill scale\n\n\nscale_linetype_manual\nCustom discrete linetype scale\n\n\nscale_shape_manual\nCustom discrete shape scale\n\n\nscale_size_manual\nCustom discrete size scale\n\n\n\n\n\n\n\n\n\n\n\nscale_x_continuous\nContinuous x position\n\n\nscale_x_date\nalias of scale_x_datetime\n\n\nscale_x_datetime\nContinuous x position for datetime data points\n\n\nscale_x_discrete\nDiscrete x position\n\n\nscale_x_log10\nContinuous x position log10 transformed scale\n\n\nscale_x_reverse\nContinuous x position reverse transformed scale\n\n\nscale_x_sqrt\nContinuous x position sqrt transformed scale\n\n\nscale_x_symlog\nContinuous x position symmetric logarithm transformed scale\n\n\nscale_x_timedelta\nContinuous x position for timedelta data points\n\n\nscale_y_continuous\nContinuous y position\n\n\nscale_y_date\nalias of scale_y_datetime\n\n\nscale_y_datetime\nContinuous y position for datetime data points\n\n\nscale_y_discrete\nDiscrete y position\n\n\nscale_y_log10\nContinuous y position log10 transformed scale\n\n\nscale_y_reverse\nContinuous y position reverse transformed scale\n\n\nscale_y_sqrt\nContinuous y position sqrt transformed scale\n\n\nscale_y_symlog\nContinuous y position symmetric logarithm transformed scale\n\n\nscale_y_timedelta\nContinuous y position for timedelta data points\n\n\n\n\n\n\n\n\n\n\n\nscale_shape\nScale for shapes\n\n\nscale_shape_discrete\nalias of scale_shape\n\n\n\n\n\n\n\n\n\n\n\nscale_size\nalias of scale_size_continuous\n\n\nscale_size_area\nContinuous area size scale\n\n\nscale_size_continuous\nContinuous area size scale\n\n\nscale_size_datetime\nDatetime area-size scale\n\n\nscale_size_discrete\nDiscrete area size scale\n\n\nscale_size_ordinal\nDiscrete area size scale\n\n\nscale_size_radius\nContinuous radius size scale\n\n\n\n\n\n\n\n\n\n\n\nscale_stroke\nalias of scale_stroke_continuous\n\n\nscale_stroke_continuous\nContinuous Stroke Scale\n\n\n\n\n\n\n\n\n\n\n\nlims\nSet aesthetic limits\n\n\nxlim\nSet x-axis limits\n\n\nylim\nSet y-axis limits\n\n\nexpand_limits\nExpand the limits any aesthetic using data"
  },
  {
    "objectID": "reference/index.html#scale-guides",
    "href": "reference/index.html#scale-guides",
    "title": "API Reference",
    "section": "",
    "text": "Guides allow you to interpret data represented on a scales. Guides include the x and y axes, legends and colorbars.\n\n\n\n\nguide\nBase class for all guides\n\n\n\n\n\n\n\n\nguides\nGuides for each scale\n\n\nguide_legend\nLegend guide\n\n\nguide_colorbar\nGuide colorbar"
  },
  {
    "objectID": "reference/index.html#positions",
    "href": "reference/index.html#positions",
    "title": "API Reference",
    "section": "",
    "text": "Overlapping objects can be visualized better if their positions are adjusted. That is what the position_* class do. Each geom is associated with one position adjustment class.\n\n\n\n\nposition\nBase class for all positions\n\n\n\n\n\n\n\n\nposition_dodge\nDodge overlaps and place objects side-by-side\n\n\nposition_dodge2\nDodge overlaps and place objects side-by-side\n\n\nposition_fill\nNormalise stacked objects to unit height\n\n\nposition_identity\nDo not adjust the position\n\n\nposition_jitter\nJitter points to avoid overplotting\n\n\nposition_jitterdodge\nDodge and jitter to minimise overlap\n\n\nposition_nudge\nNudge points\n\n\nposition_stack\nStack plotted objects on top of each other"
  },
  {
    "objectID": "reference/index.html#themes",
    "href": "reference/index.html#themes",
    "title": "API Reference",
    "section": "",
    "text": "Themes control the visual appearance of the non-data elements the plot.\n\n\n\n\ntheme\nBase class for themes\n\n\n\n\n\n\n\n\ntheme_538\nTheme in the likeness of fivethirtyeight.com plots\n\n\ntheme_bw\nWhite background with black gridlines\n\n\ntheme_classic\nA classic-looking theme, with x & y axis lines and no gridlines\n\n\ntheme_dark\nThe dark cousin of theme_light\n\n\ntheme_gray\nA gray background with white gridlines.\n\n\ntheme_grey\nalias of theme_gray\n\n\ntheme_light\nA theme similar to theme_linedraw\n\n\ntheme_linedraw\nA theme with only black lines of various widths on white backgrounds\n\n\ntheme_matplotlib\nThe default matplotlib look and feel.\n\n\ntheme_minimal\nA minimalistic theme with no background annotations\n\n\ntheme_seaborn\nTheme for seaborn.\n\n\ntheme_tufte\nTufte Maximal Data, Minimal Ink Theme\n\n\ntheme_void\nA classic-looking theme, with x & y axis lines and\n\n\ntheme_xkcd\nxkcd theme\n\n\n\n\n\n\nThese define aspects of a plot that can be themed. They can be used to create a new theme or modify an existing theme. They define the keyword arguments to theme. Users should never create instances of themeable.\n\n\n\n\nthemeable\nAbstract class of things that can be themed.\n\n\n\n\n\n\n\n\naspect_ratio\nAspect ratio of the panel(s)\n\n\naxis_line\nx & y axis lines\n\n\naxis_line_x\nx-axis line\n\n\naxis_line_y\ny-axis line\n\n\naxis_text\nAxis tick labels\n\n\naxis_text_x\nx-axis tick labels\n\n\naxis_text_y\ny-axis tick labels\n\n\naxis_ticks\nx & y major and minor axis tick lines\n\n\naxis_ticks_length\nAxis tick length\n\n\naxis_ticks_length_major\nAxis major-tick length\n\n\naxis_ticks_length_major_x\nx-axis major-tick length\n\n\naxis_ticks_length_major_y\ny-axis major-tick length\n\n\naxis_ticks_length_minor\nAxis minor-tick length\n\n\naxis_ticks_length_minor_x\nx-axis minor-tick length\n\n\naxis_ticks_length_minor_y\nx-axis minor-tick length\n\n\naxis_ticks_major\nx & y axis major tick lines\n\n\naxis_ticks_major_x\nx-axis major tick lines\n\n\naxis_ticks_major_y\ny-axis major tick lines\n\n\naxis_ticks_minor\nx & y axis minor tick lines\n\n\naxis_ticks_minor_x\nx-axis tick lines\n\n\naxis_ticks_minor_y\ny-axis minor tick lines\n\n\naxis_ticks_x\nx major and minor axis tick lines\n\n\naxis_ticks_y\ny major and minor axis tick lines\n\n\naxis_title\nAxis labels\n\n\naxis_title_x\nx axis label\n\n\naxis_title_y\ny axis label\n\n\ndpi\nDPI with which to draw/save the figure\n\n\nfigure_size\nFigure size in inches\n\n\nlegend_background\nLegend background\n\n\nlegend_box\nHow to box up multiple legends\n\n\nlegend_box_background\nLegend box background\n\n\nlegend_box_just\nJustification of guide boxes\n\n\nlegend_box_margin\nPadding between the legends and the box\n\n\nlegend_box_spacing\nSpacing between the legend and the plotting area\n\n\nlegend_direction\nLayout items in the legend\n\n\nlegend_key_spacing\nSpacing between two entries in a legend\n\n\nlegend_key_spacing_x\nHorizontal spacing between two entries in a legend\n\n\nlegend_key_spacing_y\nVertical spacing between two entries in a legend\n\n\nlegend_frame\nFrame around colorbar\n\n\nlegend_justification\nJustification of any legend\n\n\nlegend_justification_bottom\nJustification of legends placed at the bottom\n\n\nlegend_justification_inside\nJustification of legends placed inside the axes\n\n\nlegend_justification_left\nJustification of legends placed on the left\n\n\nlegend_justification_right\nJustification of legends placed on the right\n\n\nlegend_justification_top\nJustification of legends placed at the top\n\n\nlegend_key\nLegend key background\n\n\nlegend_key_height\nLegend key background height\n\n\nlegend_key_size\nLegend key background width and height\n\n\nlegend_key_width\nLegend key background width\n\n\nlegend_margin\nPadding between the legend and the inner box\n\n\nlegend_position\nLocation of legend\n\n\nlegend_position_inside\nLocation of legend\n\n\nlegend_spacing\nSpacing between two adjacent legends\n\n\nlegend_text\nLegend text\n\n\nlegend_text_colorbar\nColorbar text\n\n\nlegend_text_legend\nLegend text for the common legend\n\n\nlegend_text_position\nPosition of the legend text\n\n\nlegend_ticks_length\nLength of ticks in the legend\n\n\nlegend_title\nLegend title\n\n\nlegend_title_position\nPosition of legend title\n\n\nline\nAll line elements\n\n\npanel_background\nPanel background\n\n\npanel_border\nPanel border\n\n\npanel_grid\nGrid lines\n\n\npanel_grid_major\nMajor grid lines\n\n\npanel_grid_major_x\nVertical major grid lines\n\n\npanel_grid_major_y\nHorizontal major grid lines\n\n\npanel_grid_minor\nMinor grid lines\n\n\npanel_grid_minor_x\nVertical minor grid lines\n\n\npanel_grid_minor_y\nHorizontal minor grid lines\n\n\npanel_ontop\nPlace panel background & gridlines over/under the data layers\n\n\npanel_spacing\nSpacing between the facet panels\n\n\npanel_spacing_x\nHorizontal spacing between the facet panels\n\n\npanel_spacing_y\nVertical spacing between the facet panels\n\n\nplot_background\nPlot background\n\n\nplot_caption\nPlot caption\n\n\nplot_caption_position\nHow to align the plot caption\n\n\nplot_margin\nPlot Margin\n\n\nplot_margin_bottom\nPlot Margin at the bottom\n\n\nplot_margin_left\nPlot Margin on the left\n\n\nplot_margin_right\nPlot Margin on the right\n\n\nplot_margin_top\nPlot Margin at the top\n\n\nplot_subtitle\nPlot subtitle\n\n\nplot_tag\nPlot tag\n\n\nplot_tag_location\nThe area where the tag will be positioned\n\n\nplot_tag_position\nPosition of the tag\n\n\nplot_title\nPlot title\n\n\nplot_title_position\nHow to align the plot title and plot subtitle\n\n\nrect\nAll rectangle elements\n\n\nstrip_align\nAlignment of the strip & its background w.r.t the panel border\n\n\nstrip_align_x\nVertical alignment of the strip & its background w.r.t the panel border\n\n\nstrip_align_y\nHorizontal alignment of the strip & its background w.r.t the panel border\n\n\nstrip_background\nFacet label background\n\n\nstrip_background_x\nHorizontal facet label background\n\n\nstrip_background_y\nVertical facet label background\n\n\nstrip_text\nFacet labels along both axes\n\n\nstrip_text_x\nFacet labels along the horizontal axis\n\n\nstrip_text_y\nFacet labels along the vertical axis\n\n\nsubplots_adjust\n\n\n\nsvg_usefonts\nHow to renderer fonts for svg images\n\n\ntext\nAll text elements in the plot\n\n\ntitle\nAll titles on the plot\n\n\n\n\n\n\n\n\n\n\n\ntheme_set\nChange the current(default) theme\n\n\ntheme_get\nReturn the default theme\n\n\ntheme_update\nModify elements of the current theme\n\n\n\n\n\n\n\n\nelement_line\ntheme element: line\n\n\nelement_rect\nTheme element: Rectangle\n\n\nelement_text\nTheme element: Text\n\n\nelement_blank\nTheme element: Blank"
  },
  {
    "objectID": "reference/index.html#coordinates",
    "href": "reference/index.html#coordinates",
    "title": "API Reference",
    "section": "",
    "text": "Coordinate systems put together the two position scales to produce a 2d location.\n\n\n\n\ncoord\nBase class for all coordinate systems\n\n\n\n\n\n\n\n\ncoord_cartesian\nCartesian coordinate system\n\n\ncoord_equal\nCartesian coordinates with fixed relationship between x and y scales\n\n\ncoord_fixed\nCartesian coordinates with fixed relationship between x and y scales\n\n\ncoord_flip\nFlipped cartesian coordinates\n\n\ncoord_trans\nTransformed cartesian coordinate system"
  },
  {
    "objectID": "reference/index.html#options",
    "href": "reference/index.html#options",
    "title": "API Reference",
    "section": "",
    "text": "When working interactively, some of the options make it convenient to create plots that have a common look and feel.\n\n\nThese are the methods that access the options.\n\n\n\n\nget_option\nGet package option\n\n\nset_option\nSet package option\n\n\n\n\n\n\n\nThese are all the options that you can set or get the values of.\n\n\n\n\naspect_ratio\nDefault aspect ratio used by the themes\n\n\nbase_family\nThe base font family for all text that is part of the theme.\n\n\nbase_margin\nA size that is proportional of the figure width and\n\n\ncurrent_theme\nTheme used when none is added to the ggplot object\n\n\ndpi\nDefault DPI used by the themes\n\n\nfigure_size\nDefault figure size in inches\n\n\nfigure_format\nThe format for the inline figures outputted by the jupyter kernel."
  },
  {
    "objectID": "reference/index.html#tools",
    "href": "reference/index.html#tools",
    "title": "API Reference",
    "section": "",
    "text": "Functions that you may occasioanally find helpful\n\n\n\n\nget_aesthetic_limits\nGet the limits of an aesthetic"
  },
  {
    "objectID": "reference/index.html#datasets",
    "href": "reference/index.html#datasets",
    "title": "API Reference",
    "section": "",
    "text": "These datasets ship with the plotnine and you can import them with from the plotnine.data sub-package.\n\n\n\n\nanscombe_quartet\nAnscombe’s Quartet\n\n\ndiamonds\nPrices of 50,000 round cut diamonds\n\n\neconomics\nUS economic time series.\n\n\neconomics_long\nUS economic time series.\n\n\nfaithful\nOld Faithful Geyser Data\n\n\nfaithfuld\nOld Faithful Geyser Data\n\n\nhuron\nLevel of Lake Huron 1875–1972\n\n\nluv_colours\ncolors in Luv space.\n\n\nmeat\nUS Meat Production\n\n\nmidwest\nMidwest demographics.\n\n\nmpg\nFuel economy data from 1999 and 2008 for 38 popular models of car\n\n\nmsleep\nAn updated and expanded version of the mammals sleep dataset.\n\n\nmtcars\nMotor Trend Car Road Tests\n\n\npageviews\n\n\n\npresidential\nTerms of 11 presidents from Eisenhower to Obama.\n\n\nseals\nVector field of seal movements.\n\n\ntxhousing\nHousing sales in TX."
  },
  {
    "objectID": "reference/guides.html",
    "href": "reference/guides.html",
    "title": " plotnine.guides",
    "section": "",
    "text": "guides(\n    alpha=None,\n    color=None,\n    fill=None,\n    linetype=None,\n    shape=None,\n    size=None,\n    stroke=None,\n    colour=None\n)"
  },
  {
    "objectID": "reference/guides.html#parameter-attributes",
    "href": "reference/guides.html#parameter-attributes",
    "title": " plotnine.guides",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nalpha: Optional[LegendOrColorbar | NoGuide] = None\n\nGuide for alpha scale.\n\ncolor: Optional[LegendOrColorbar | NoGuide] = None\n\nGuide for color scale.\n\nfill: Optional[LegendOrColorbar | NoGuide] = None\n\nGuide for fill scale.\n\nlinetype: Optional[LegendOnly | NoGuide] = None\n\nGuide for linetype scale.\n\nshape: Optional[LegendOnly | NoGuide] = None\n\nGuide for shape scale.\n\nsize: Optional[LegendOnly | NoGuide] = None\n\nGuide for size scale.\n\nstroke: Optional[LegendOnly | NoGuide] = None\n\nGuide for stroke scale.\n\ncolour: Optional[LegendOnly | NoGuide] = None\n\nGuide for colour scale."
  },
  {
    "objectID": "reference/guide_colorbar.html",
    "href": "reference/guide_colorbar.html",
    "title": " plotnine.guide_colorbar",
    "section": "",
    "text": "guide_colorbar(\n    title=None,\n    theme=Theme(),\n    position=None,\n    direction=None,\n    reverse=False,\n    order=0,\n    nbin=None,\n    display=\"gradient\",\n    alpha=None,\n    draw_ulim=True,\n    draw_llim=True\n)"
  },
  {
    "objectID": "reference/guide_colorbar.html#parameter-attributes",
    "href": "reference/guide_colorbar.html#parameter-attributes",
    "title": " plotnine.guide_colorbar",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\ntitle: Optional[str] = None\n\nTitle of the guide. Default is the name of the aesthetic or the name specified using lab\n\ntheme: Theme = field(default_factory=Theme)\n\nA theme to style the guide. If None, the plots theme is used.\n\nposition: Optional[LegendPosition] = None\n\nWhere to place the guide relative to the panels.\n\ndirection: Optional[Orientation] = None\n\nDirection of the guide. The default is depends on legend_position.\n\nreverse: bool = False\n\nWhether to reverse the order of the legend keys.\n\norder: int = 0\n\nOrder of this guide among multiple guides.\n\nnbin: Optional[int] = None\n\nNumber of bins for drawing a colorbar. A larger value yields a smoother colorbar\n\ndisplay: Literal[\"gradient\", \"rectangles\", \"raster\"] = \"gradient\"\n\nHow to render the colorbar.\n\nalpha: Optional[float] = None\n\nOpacity (in the range [0, 1]) of the colorbar. The default None, is to use the opacity of the plot.\n\ndraw_ulim: bool = True\n\nWhether to show the upper limit tick marks.\n\ndraw_llim: bool = True\n\nWhether to show the lower limit tick marks."
  },
  {
    "objectID": "reference/guide_colorbar.html#notes",
    "href": "reference/guide_colorbar.html#notes",
    "title": " plotnine.guide_colorbar",
    "section": "Notes",
    "text": "Notes\nTo correctly place a rasterized colorbar when saving the plot as an svg or pdf, you should set the dpi to 72 i.e. theme(dpi=72)."
  },
  {
    "objectID": "reference/ggtitle.html",
    "href": "reference/ggtitle.html",
    "title": " plotnine.ggtitle",
    "section": "",
    "text": "ggtitle(title=None, subtitle=None)"
  },
  {
    "objectID": "reference/ggtitle.html#parameters",
    "href": "reference/ggtitle.html#parameters",
    "title": " plotnine.ggtitle",
    "section": "Parameters",
    "text": "Parameters\n\n\ntitle : str | None = None\n\nPlot title"
  },
  {
    "objectID": "reference/get_option.html",
    "href": "reference/get_option.html",
    "title": " plotnine.options.get_option",
    "section": "",
    "text": "get_option(name)"
  },
  {
    "objectID": "reference/get_option.html#parameters",
    "href": "reference/get_option.html#parameters",
    "title": " plotnine.options.get_option",
    "section": "Parameters",
    "text": "Parameters\n\n\nname : str\n\nName of the option"
  },
  {
    "objectID": "reference/get_option.html#notes",
    "href": "reference/get_option.html#notes",
    "title": " plotnine.options.get_option",
    "section": "Notes",
    "text": "Notes\nSee reference for a list of all the available options."
  },
  {
    "objectID": "reference/geom_vline.html",
    "href": "reference/geom_vline.html",
    "title": " plotnine.geom_vline",
    "section": "",
    "text": "geom_vline(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=False,\n    show_legend=None,\n    raster=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_vline.html#parameters",
    "href": "reference/geom_vline.html#parameters",
    "title": " plotnine.geom_vline",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nxintercept\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = False\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_vline.html#examples",
    "href": "reference/geom_vline.html#examples",
    "title": " plotnine.geom_vline",
    "section": "Examples",
    "text": "Examples\n\n\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    geom_vline,\n    facet_grid,\n    labs,\n    element_rect,\n    theme,\n    theme_matplotlib,\n    theme_set,\n)\nfrom plotnine.data import mpg\n\n# Set default theme\n# matplotlib + the background of 538\ntheme_set(\n    theme_matplotlib()\n    + theme(\n        plot_background=element_rect(fill=\"#F0F0F0\"),\n        panel_background=element_rect(fill=\"#F0F0F0\"),\n        panel_spacing=0.015,\n        \n    )\n)\n\n\nVertical line\ngeom_vline() draws a vertical line, and is useful as a guide.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nIt’s useful to use geom_vline() with some data, so we start with a basic scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nAdd a vertical line to the scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_vline(xintercept=5)  # add one vertical line\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can add many vertical lines:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_vline(xintercept=[4, 5, 7])  # add many vertical lines using a list\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_vline(\n        xintercept=[4, 5, 7],\n        colour=[\"red\", \"orange\", \"green\"],  # add colour\n        size=[1, 2, 3],  # set line thickness\n        linetype=\"dotted\",  # set line type\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nAdd vertical lines to a facet plot:\n\n\nFacets with a Vertical Line\n\n# Gallery, lines\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_vline(xintercept=5, color=\"brown\", size=1)  # add a vertical line...\n    + facet_grid(\"drv\")  # ... to a facet plot\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\n\nSource: Set default theme"
  },
  {
    "objectID": "reference/geom_tile.html",
    "href": "reference/geom_tile.html",
    "title": " plotnine.geom_tile",
    "section": "",
    "text": "geom_tile(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_tile.html#parameters",
    "href": "reference/geom_tile.html#parameters",
    "title": " plotnine.geom_tile",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\nNone\n\n\nfill\n'#333333'\n\n\ngroup\n\n\n\nheight\nNone\n\n\nlinetype\n'solid'\n\n\nsize\n0.1\n\n\nwidth\nNone\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_tile.html#see-also",
    "href": "reference/geom_tile.html#see-also",
    "title": " plotnine.geom_tile",
    "section": "See Also",
    "text": "See Also\n\ngeom_rect"
  },
  {
    "objectID": "reference/geom_tile.html#examples",
    "href": "reference/geom_tile.html#examples",
    "title": " plotnine.geom_tile",
    "section": "Examples",
    "text": "Examples\n\n\nimport pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_tile,\n    geom_text,\n    scale_y_reverse,\n    scale_y_discrete,\n    scale_fill_brewer,\n    scale_color_manual,\n    coord_equal,\n    theme,\n    theme_void,\n    element_blank,\n    element_rect,\n    element_text,\n)\n\n\nPeriodic Table\nGraphing of highly organised tabular information\nRead the data.\n\nelements = pd.read_csv(\"data/elements.csv\")\nelements.head()\n\n\n\n\n\n\n\n\natomic number\nsymbol\nname\natomic mass\nCPK\nelectronic configuration\nelectronegativity\natomic radius\nion radius\nvan der Waals radius\n...\nEA\nstandard state\nbonding type\nmelting point\nboiling point\ndensity\nmetal\nyear discovered\ngroup\nperiod\n\n\n\n\n0\n1\nH\nHydrogen\n1.00794\n#FFFFFF\n1s1\n2.20\n37.0\nNaN\n120.0\n...\n-73.0\ngas\ndiatomic\n14.0\n20.0\n0.00009\nnonmetal\n1766\n1\n1\n\n\n1\n2\nHe\nHelium\n4.002602\n#D9FFFF\n1s2\nNaN\n32.0\nNaN\n140.0\n...\n0.0\ngas\natomic\nNaN\n4.0\n0.00000\nnoble gas\n1868\n18\n1\n\n\n2\n3\nLi\nLithium\n6.941\n#CC80FF\n[He] 2s1\n0.98\n134.0\n76 (+1)\n182.0\n...\n-60.0\nsolid\nmetallic\n454.0\n1615.0\n0.54000\nalkali metal\n1817\n1\n2\n\n\n3\n4\nBe\nBeryllium\n9.012182\n#C2FF00\n[He] 2s2\n1.57\n90.0\n45 (+2)\nNaN\n...\n0.0\nsolid\nmetallic\n1560.0\n2743.0\n1.85000\nalkaline earth metal\n1798\n2\n2\n\n\n4\n5\nB\nBoron\n10.811\n#FFB5B5\n[He] 2s2 2p1\n2.04\n82.0\n27 (+3)\nNaN\n...\n-27.0\nsolid\ncovalent network\n2348.0\n4273.0\n2.46000\nmetalloid\n1807\n13\n2\n\n\n\n\n5 rows × 21 columns\n\n\n\nAlter the data types of the information that will be plotted. This makes it convenient to work with.\n\nelements[\"group\"] = [-1 if g == \"-\" else int(g) for g in elements.group]\nelements[\"bonding type\"] = elements[\"bonding type\"].astype(\"category\")\nelements[\"metal\"] = elements[\"metal\"].astype(\"category\")\nelements[\"atomic_number\"] = elements[\"atomic number\"].astype(str)\n\nThe periodic table has two tables, a top and bottom. The elements in the top have groups, and those in the bottom have no groups. We make separate dataframes for both – they have different alignments.\n\ntop = elements.query(\"group != -1\").copy()\nbottom = elements.query(\"group == -1\").copy()\n\nThe top table is nice and well behaving. The x location of the elements indicate the group and the y locations the period.\n\ntop[\"x\"] = top.group\ntop[\"y\"] = top.period\n\nThe bottom table has 2 rows, with the atomic number increasing to the right. We create an x based on the atomic number and add a horizontal shift. As the dataframe is ordered by atomic number, the operation is easier. The bottom elements are labelled with a “period”. We add a vertical shift to give us a good y location that gives the appearance of two tables.\n\nnrows = 2\nhshift = 3.5\nvshift = 3\nbottom[\"x\"] = np.tile(np.arange(len(bottom) // nrows), nrows) + hshift\nbottom[\"y\"] = bottom.period + vshift\n\nWe will be plotting using tiles and we want to have some space between the tiles. We have set the x and y locations above to take up a unit of space. To get a good effect, the tile dimensions should be less than 1.\n\ntile_width = 0.95\ntile_height = 0.95\n\nFirst peak\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n)\n\n\n\n\n\n\n\n\nThe table upside down. We could have been more careful when creating the y locations since the periods are drawn in descending order. But, we can fix that with a reverse scale.\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + scale_y_reverse()  # new\n)\n\n\n\n\n\n\n\n\nLet us apply some color to it.\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")  # new\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + scale_y_reverse()\n)\n\n\n\n\n\n\n\n\n\nNow for some trick\nGoal: To add text to the tiles\nThere are four pieces of text that we shall add to the tiles, that is 4 geom_text additions. As we have two tables, that comes to 8 geom_text additions. When any geom is added to a ggplot object, behind the scenes a layer is created and added. We can create a group of layers that can be added to a ggplot object in one go using a list.\nWe use a function that accepts a dataframe, and returns a list of geoms.\n\ndef inner_text(data):\n    layers = [\n        geom_text(\n            data,\n            aes(label=\"atomic_number\"),\n            nudge_x=-0.40,\n            nudge_y=0.40,\n            ha=\"left\",\n            va=\"top\",\n            fontweight=\"normal\",\n            size=6,\n        ),\n        geom_text(data, aes(label=\"symbol\"), nudge_y=0.1, size=9),\n        geom_text(\n            data, aes(label=\"name\"), nudge_y=-0.125, fontweight=\"normal\", size=4.5\n        ),\n        geom_text(\n            data, aes(label=\"atomic mass\"), nudge_y=-0.3, fontweight=\"normal\", size=4.5\n        ),\n    ]\n    return layers\n\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)  # new\n    + inner_text(bottom)  # new\n    + scale_y_reverse()\n)\n\n\n\n\n\n\n\n\nIt is crowded in there and the tiles do not have equal dimentions. Use the theme create a larger figure. coord_equal give us equal units along the axes, this makes the tiles square.\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)\n    + inner_text(bottom)\n    + scale_y_reverse()\n    + coord_equal(expand=False)  # new\n    + theme(figure_size=(12, 6))  # new\n)\n\n\n\n\n\n\n\n\nIt is has all the information we want, except one for complication. Elements Lu and Lr also belong in the bottom table. One way to show this duality is to have tiles with two colors split horizontally.\nThe colors are determined by the metal field, and we know the x and y locations. We create a dataframe with this information to create a half-tile. A half-tile is centered at the quarter mark.\n\nsplit_df = pd.DataFrame(\n    {\n        \"x\": 3 - tile_width / 4,\n        \"y\": [6, 7],\n        \"metal\": pd.Categorical([\"lanthanoid\", \"actinoid\"]),\n    }\n)\n\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(split_df, aes(width=tile_width / 2, height=tile_height))  # new\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)\n    + inner_text(bottom)\n    + scale_y_reverse()\n    + coord_equal(expand=False)\n    + theme(figure_size=(12, 6))\n)\n\n\n\n\n\n\n\n\nChange the fill color for a different look and use a theme that clears out all the clutter.\n\nfrom plotnine import guides\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(split_df, aes(width=tile_width / 2, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)\n    + inner_text(bottom)\n    + scale_y_reverse()\n    + scale_fill_brewer(type=\"qual\", palette=3)  # new\n    + coord_equal(expand=False)\n    + theme_void()  # new\n    + theme(\n        figure_size=(12, 6),\n        plot_margin_left=0.01,\n        plot_margin_right=0.01,\n        plot_background=element_rect(fill=\"white\"),\n    )  # new\n)\n\n\n\n\n\n\n\n\nAdd the group number along the top most row of each column, and period number along the left side of the top table.\nFor the period number, we set the breaks on the y scale.\n\n# The location of the group number is the top most (and therefore smallest period)\n# element with the group\ngroupdf = top.groupby(\"group\").agg(y=(\"period\", \"min\")).reset_index()\n\nFinally,\n\n# Gallery, tiles\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(split_df, aes(width=tile_width / 2, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)\n    + inner_text(bottom)\n    + geom_text(\n        groupdf,\n        aes(\"group\", \"y\", label=\"group\"),\n        color=\"gray\",\n        nudge_y=0.525,\n        va=\"bottom\",\n        fontweight=\"normal\",\n        size=9,\n        inherit_aes=False,\n    )  # new\n    + scale_y_reverse(breaks=range(1, 8), limits=(0, 10.5))  # modified\n    + scale_fill_brewer(type=\"qual\", palette=3)\n    + coord_equal(expand=False)\n    + theme_void()\n    + theme(\n        figure_size=(12, 6),\n        plot_margin_left=0.01,\n        plot_margin_right=0.01,\n        plot_background=element_rect(fill=\"white\"),\n        axis_text_y=element_text(margin={\"r\": 5}, color=\"gray\", size=9),  # new\n    )\n)\n\n\n\n\n\n\n\n\nWhat we could have done different:\n\nAfter we set the x and y positions in th the top and bottom dataframes, we could have concatenated them back together. Then, that Layers trick would not save us much.\n\nPro tip: Save the plot as a pdf.\n\n\n\nAnnotated Heatmap\nConditinous data recorded at discrete time intervals over many cycles\nRead data\n\nflights = pd.read_csv(\"data/flights.csv\")\nmonths = flights[\"month\"].unique()  # Months ordered January, ..., December\nflights[\"month\"] = pd.Categorical(flights[\"month\"], categories=months)\nflights.head()\n\n\n\n\n\n\n\n\nyear\nmonth\npassengers\n\n\n\n\n0\n1949\nJanuary\n112\n\n\n1\n1949\nFebruary\n118\n\n\n2\n1949\nMarch\n132\n\n\n3\n1949\nApril\n129\n\n\n4\n1949\nMay\n121\n\n\n\n\n\n\n\n\n# We use 'factor(year)' -- a discrete -- instead of 'year' so that all the years\n# are displayed along the x-axis.\n# The .95s create spacing between the tiles.\n\n(\n    ggplot(flights, aes(\"factor(year)\", \"month\", fill=\"passengers\"))\n    + geom_tile(aes(width=0.95, height=0.95))\n    + geom_text(aes(label=\"passengers\"), size=9)\n)\n\n\n\n\n\n\n\n\nThat looks like what we want, but it could do with a few tweaks. First the contrast between the tiles and the text is not good for the lower passenger numbers. We use pd.cut to partition the number of passengers into two discrete groups.\n\nflights[\"p_group\"] = pd.cut(\n    flights[\"passengers\"], (0, 300, 1000), labels=(\"low\", \"high\")\n)\nflights.head()\n\n\n\n\n\n\n\n\nyear\nmonth\npassengers\np_group\n\n\n\n\n0\n1949\nJanuary\n112\nlow\n\n\n1\n1949\nFebruary\n118\nlow\n\n\n2\n1949\nMarch\n132\nlow\n\n\n3\n1949\nApril\n129\nlow\n\n\n4\n1949\nMay\n121\nlow\n\n\n\n\n\n\n\n\n(\n    ggplot(flights, aes(\"factor(year)\", \"month\", fill=\"passengers\"))\n    + geom_tile(aes(width=0.95, height=0.95))\n    + geom_text(aes(label=\"passengers\", color=\"p_group\"), size=9, show_legend=False)  # modified\n    + scale_color_manual([\"white\", \"black\"])  # new\n)\n\n\n\n\n\n\n\n\nLast tweaks, put January at the top and remove the axis ticks and plot background.\n\n# Gallery, tiles\n\n(\n    ggplot(flights, aes(\"factor(year)\", \"month\", fill=\"passengers\"))\n    + geom_tile(aes(width=0.95, height=0.95))\n    + geom_text(aes(label=\"passengers\", color=\"p_group\"), size=9, show_legend=False)\n    + scale_color_manual([\"white\", \"black\"])  # new\n    + scale_y_discrete(limits=months[::-1])  # new\n    + theme(  # new\n        axis_ticks=element_blank(),\n        panel_background=element_rect(fill=\"white\"),\n    )\n)\n\n\n\n\n\n\n\n\nYou can get similar results if you replace\n + geom_tile(aes(width=.95, height=.95))\n + geom_text(aes(label='passengers', color='p_group'), size=9, show_legend=False)\nwith\n+ geom_label(aes(label='passengers', color='p_group'), size=9, show_legend=False)\nCredit: This example is a recreation of this seaborn example.\n\nSource: Periodic Table"
  },
  {
    "objectID": "reference/geom_step.html",
    "href": "reference/geom_step.html",
    "title": " plotnine.geom_step",
    "section": "",
    "text": "geom_step(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    direction=\"hv\",\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_step.html#parameters",
    "href": "reference/geom_step.html#parameters",
    "title": " plotnine.geom_step",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\ndirection : Literal[\"hv\", \"vh\", \"mid\"] = \"hv\"\n\nhorizontal-vertical steps, vertical-horizontal steps or steps half-way between adjacent x values.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_step.html#see-also",
    "href": "reference/geom_step.html#see-also",
    "title": " plotnine.geom_step",
    "section": "See Also",
    "text": "See Also\n\ngeom_path\n\nFor documentation of extra parameters."
  },
  {
    "objectID": "reference/geom_step.html#examples",
    "href": "reference/geom_step.html#examples",
    "title": " plotnine.geom_step",
    "section": "Examples",
    "text": "Examples\n\n\n\nfrom plotnine import ggplot, aes, geom_step, geom_line, labs, theme, element_text\nfrom plotnine.data import economics\n\n\nStep plots\ngeom_step() connects points using ‘steps’ instead of a line.\n\n# inspect the data\neconomics.head()\n\n\n\n\n\n\n\n\ndate\npce\npop\npsavert\nuempmed\nunemploy\n\n\n\n\n0\n1967-07-01\n507.4\n198712\n12.5\n4.5\n2944\n\n\n1\n1967-08-01\n510.5\n198911\n12.5\n4.7\n2945\n\n\n2\n1967-09-01\n516.3\n199113\n11.7\n4.6\n2958\n\n\n3\n1967-10-01\n512.9\n199311\n12.5\n4.9\n3143\n\n\n4\n1967-11-01\n518.1\n199498\n12.5\n4.7\n3066\n\n\n\n\n\n\n\nPlot a step plot using geom_plot(). Notice from the first point the line travels vertically then horizontally:\n\n(\n    ggplot(\n        economics.iloc[:20],  # filter for first twenty rows (dates) to make steps more visible\n        aes(\"date\", \"unemploy\"),\n    )\n    + geom_step()  # step plot\n    + labs(x=\"date\", y=\"unemployment (,000)\")  # label x & y-axis\n    + theme(axis_text_x=element_text(angle=45))  # rotate x-axis text for readability\n)\n\n\n\n\n\n\n\n\nYou can see how geom_path() (shown in pink) differs from geom_line() (black):\n\n(\n    ggplot(economics.iloc[:20], aes(\"date\", \"unemploy\"))\n    + geom_step(\n        colour=\"#ff69b4\",  # plot geom_step as the first layer - colour pink\n        alpha=0.5,  # line transparency\n        size=2.5,\n    )  # line thickness\n    + geom_line()  # plot geom_line as the second layer\n    + labs(x=\"date\", y=\"unemployment (,000)\")\n    + theme(axis_text_x=element_text(angle=45))\n)\n\n\n\n\n\n\n\n\nRather than a line that travels vertically then horizontally, this order can be switched by specifying direction='vh' within geom_step(). Below direction='vh' is shown in black with the default direction='hv' shown in pink:\n\n(\n    ggplot(economics.iloc[:20], aes(\"date\", \"unemploy\"))\n    + geom_step(\n        colour=\"#ff69b4\",  # plot geom_path with default direction as the first layer - colour pink\n        linetype=\"dashed\",  # line type\n        size=2,  # line thickness\n        alpha=0.5,\n    )  # line transparency\n    + geom_step(direction=\"vh\")  # plot geom_path with step order reversed\n    + labs(x=\"date\", y=\"unemployment (,000)\")\n    + theme(axis_text_x=element_text(angle=45))\n)\n\n\n\n\n\n\n\n\n\nSource: Step plots"
  },
  {
    "objectID": "reference/geom_smooth.html",
    "href": "reference/geom_smooth.html",
    "title": " plotnine.geom_smooth",
    "section": "",
    "text": "geom_smooth(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"smooth\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    legend_fill_ratio=0.5,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_smooth.html#parameters",
    "href": "reference/geom_smooth.html#parameters",
    "title": " plotnine.geom_smooth",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n0.4\n\n\ncolor\n'black'\n\n\nfill\n'#999999'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n1\n\n\nymax\nNone\n\n\nymin\nNone\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"smooth\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nlegend_fill_ratio : float = 0.5\n\nHow much (vertically) of the legend box should be filled by the color that indicates the confidence intervals. Should be in the range [0, 1].\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_smooth.html#examples",
    "href": "reference/geom_smooth.html#examples",
    "title": " plotnine.geom_smooth",
    "section": "Examples",
    "text": "Examples\n\n\n\nfrom plotnine import ggplot, aes, geom_point, geom_smooth, labs, theme_matplotlib, theme_set\nfrom plotnine.data import mpg\n\ntheme_set(theme_matplotlib())\n\n\nSmoothed conditional means\nAids the eye in seeing patterns in the presence of overplotting.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_smooth()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nUse span to control the “wiggliness” of the default loess smoother. The span is the fraction of points used to fit each local regression: small numbers make a wigglier curve, larger numbers make a smoother curve.\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_smooth(span=0.3)\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can remove confidence interval around smooth with se=False:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_smooth(span=0.3, se=False)\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nInstead of a loess smooth, you can use any other modelling function:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_smooth(method=\"lm\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\n\n\nPoints & Linear Models\n\n# Gallery, points\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\", color=\"factor(drv)\"))\n    + geom_point()\n    + geom_smooth(method=\"lm\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\n\nSource: Smoothed conditional means"
  },
  {
    "objectID": "reference/geom_segment.html",
    "href": "reference/geom_segment.html",
    "title": " plotnine.geom_segment",
    "section": "",
    "text": "geom_segment(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    lineend=\"butt\",\n    arrow=None,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_segment.html#parameters",
    "href": "reference/geom_segment.html#parameters",
    "title": " plotnine.geom_segment",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\nxend\n\n\n\ny\n\n\n\nyend\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nlineend : Literal[\"butt\", \"round\", \"projecting\"] = \"butt\"\n\nLine end style. This option is applied for solid linetypes.\n\narrow : arrow = None\n\nArrow specification. Default is no arrow.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_segment.html#see-also",
    "href": "reference/geom_segment.html#see-also",
    "title": " plotnine.geom_segment",
    "section": "See Also",
    "text": "See Also\n\narrow\n\nfor adding arrowhead(s) to segments."
  },
  {
    "objectID": "reference/geom_segment.html#examples",
    "href": "reference/geom_segment.html#examples",
    "title": " plotnine.geom_segment",
    "section": "Examples",
    "text": "Examples\n\n\n# NOTE: This notebook uses the polars package\nimport numpy as np\n\nfrom plotnine import *\nimport polars as pl\nfrom polars import col\n\n\nAn Elaborate Range Plot\nComparing the point to point difference of many similar variables\nRead the data.\nSource: Pew Research Global Attitudes Spring 2015\n\n!head -n 20 \"data/survey-social-media.csv\"\n\nPSRAID,COUNTRY,Q145,Q146,Q70,Q74\n100000,Ethiopia,Female,35,No, \n100001,Ethiopia,Female,25,No, \n100002,Ethiopia,Male,40,Don’t know, \n100003,Ethiopia,Female,30,Don’t know, \n100004,Ethiopia,Male,22,No, \n100005,Ethiopia,Male,40,No, \n100006,Ethiopia,Female,20,No, \n100007,Ethiopia,Female,18,No,No\n100008,Ethiopia,Male,50,No, \n100009,Ethiopia,Male,35,No, \n100010,Ethiopia,Female,20,No, \n100011,Ethiopia,Female,30,Don’t know, \n100012,Ethiopia,Male,60,No, \n100013,Ethiopia,Male,18,No, \n100014,Ethiopia,Male,40,No, \n100015,Ethiopia,Male,28,Don’t know, \n100016,Ethiopia,Female,55,Don’t know, \n100017,Ethiopia,Male,30,Don’t know, \n100018,Ethiopia,Female,22,No, \n\n\n\ncolumns = dict(\n    COUNTRY=\"country\",\n    Q145=\"gender\",\n    Q146=\"age\",\n    Q70=\"use_internet\",\n    Q74=\"use_social_media\",\n)\n\ndata = (\n    pl.scan_csv(\n        \"data/survey-social-media.csv\",\n        schema_overrides=dict(Q146=pl.Utf8),\n    )\n    .rename(columns)\n    .select([\"country\", \"age\", \"use_social_media\"])\n    .collect()\n)\n\ndata.sample(10, seed=123)\n\n\nshape: (10, 3)\n\n\n\ncountry\nage\nuse_social_media\n\n\nstr\nstr\nstr\n\n\n\n\n\"India\"\n\"23\"\n\" \"\n\n\n\"Pakistan\"\n\"18\"\n\" \"\n\n\n\"Peru\"\n\"39\"\n\"Yes\"\n\n\n\"Jordan\"\n\"56\"\n\" \"\n\n\n\"United Kingdom\"\n\"35\"\n\"Yes\"\n\n\n\"Chile\"\n\"24\"\n\"Yes\"\n\n\n\"Israel\"\n\"32\"\n\"No\"\n\n\n\"Pakistan\"\n\"39\"\n\"No\"\n\n\n\"Chile\"\n\"26\"\n\"Yes\"\n\n\n\"Nigeria\"\n\"43\"\n\"Yes\"\n\n\n\n\n\n\nCreate age groups for users of social media\n\nyes_no = [\"Yes\", \"No\"]\nvalid_age_groups = [\"18-34\", \"35-49\", \"50+\"]\n\nrdata = (\n    data.with_columns(\n        age_group=pl.when(col(\"age\") &lt;= \"34\")\n        .then(pl.lit(\"18-34\"))\n        .when(col(\"age\") &lt;= \"49\")\n        .then(pl.lit(\"35-49\"))\n        .when(col(\"age\") &lt; \"98\")\n        .then(pl.lit(\"50+\"))\n        .otherwise(pl.lit(\"\")),\n        country_count=pl.len().over(\"country\"),\n    )\n    .filter(\n        col(\"age_group\").is_in(valid_age_groups) & col(\"use_social_media\").is_in(yes_no)\n    )\n    .group_by([\"country\", \"age_group\"])\n    .agg(\n        # social media use percentage\n        sm_use_percent=(col(\"use_social_media\") == \"Yes\").sum() * 100 / pl.len(),\n        # social media question response rate\n        smq_response_rate=col(\"use_social_media\").is_in(yes_no).sum()\n        * 100\n        / col(\"country_count\").first(),\n    )\n    .sort([\"country\", \"age_group\"])\n)\n\nrdata.head()\n\n\nshape: (5, 4)\n\n\n\ncountry\nage_group\nsm_use_percent\nsmq_response_rate\n\n\nstr\nstr\nf64\nf64\n\n\n\n\n\"Argentina\"\n\"18-34\"\n90.883191\n35.1\n\n\n\"Argentina\"\n\"35-49\"\n84.40367\n21.8\n\n\n\"Argentina\"\n\"50+\"\n67.333333\n15.0\n\n\n\"Australia\"\n\"18-34\"\n90.862944\n19.621514\n\n\n\"Australia\"\n\"35-49\"\n78.04878\n20.418327\n\n\n\n\n\n\nTop 14 countries by response rate to the social media question.\n\ndef format_column(column, fmt):\n    \"\"\"Format column using python format\"\"\"\n    def _fmt(s):\n        return pl.Series([fmt.format(x) if x is not None else x for x in s])\n    return pl.col(column).map_batches(_fmt)\n\nn = 14\n\ntop = (\n    rdata.group_by(\"country\")\n    .agg(r=col(\"smq_response_rate\").sum())\n    .sort(\"r\", descending=True)\n    .head(n)\n)\ntop_countries = set(top[\"country\"])\n\npoint_data = rdata.filter(col(\"country\").is_in(top_countries)).with_columns(\n    col(\"country\").cast(pl.Categorical),\n    sm_use_percent_str=pl.when(\n        col(\"country\")==\"United States\"\n    ).then(\n        format_column(\"sm_use_percent\", \"{:.0f}%\")\n    ).otherwise(\n        format_column(\"sm_use_percent\", \"{:.0f}\")\n    )\n)\n\npoint_data.head()\n\n\nshape: (5, 5)\n\n\n\ncountry\nage_group\nsm_use_percent\nsmq_response_rate\nsm_use_percent_str\n\n\ncat\nstr\nf64\nf64\nstr\n\n\n\n\n\"Australia\"\n\"18-34\"\n90.862944\n19.621514\n\"91\"\n\n\n\"Australia\"\n\"35-49\"\n78.04878\n20.418327\n\"78\"\n\n\n\"Australia\"\n\"50+\"\n48.479087\n52.390438\n\"48\"\n\n\n\"Canada\"\n\"18-34\"\n92.063492\n25.099602\n\"92\"\n\n\n\"Canada\"\n\"35-49\"\n75.925926\n21.513944\n\"76\"\n\n\n\n\n\n\n\nsegment_data = (\n    point_data.group_by(\"country\")\n    .agg(\n        min=col(\"sm_use_percent\").min(),\n        max=col(\"sm_use_percent\").max(),\n    )\n    .with_columns(gap=(col(\"max\") - col(\"min\")))\n    .sort(\n        \"gap\",\n    )\n    .with_columns(\n        min_str=format_column(\"min\", \"{:.0f}\"),\n        max_str=format_column(\"max\", \"{:.0f}\"),\n        gap_str=format_column(\"gap\", \"{:.0f}\"),\n    )\n)\n\nsegment_data.head()\n\n\nshape: (5, 7)\n\n\n\ncountry\nmin\nmax\ngap\nmin_str\nmax_str\ngap_str\n\n\ncat\nf64\nf64\nf64\nstr\nstr\nstr\n\n\n\n\n\"Russia\"\n76.07362\n95.151515\n19.077896\n\"76\"\n\"95\"\n\"19\"\n\n\n\"Israel\"\n55.405405\n88.311688\n32.906283\n\"55\"\n\"88\"\n\"33\"\n\n\n\"United Kingdom\"\n52.74463\n86.096257\n33.351627\n\"53\"\n\"86\"\n\"33\"\n\n\n\"United States\"\n52.597403\n88.669951\n36.072548\n\"53\"\n\"89\"\n\"36\"\n\n\n\"Canada\"\n53.986333\n92.063492\n38.077159\n\"54\"\n\"92\"\n\"38\"\n\n\n\n\n\n\nFormat the floating point data that will be plotted into strings\nFirst plot\n\n# The right column (youngest-oldest gap) location\nxgap = 112\n\n(\n    ggplot()\n    # Range strip\n    + geom_segment(\n        segment_data,\n        aes(x=\"min\", xend=\"max\", y=\"country\", yend=\"country\"),\n        size=6,\n        color=\"#a7a9ac\",\n    )\n    # Age group markers\n    + geom_point(\n        point_data,\n        aes(\"sm_use_percent\", \"country\", color=\"age_group\", fill=\"age_group\"),\n        size=5,\n        stroke=0.7,\n    )\n    # Age group percentages\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"50+\"),\n        aes(\n            x=\"sm_use_percent-2\",\n            y=\"country\",\n            label=\"sm_use_percent_str\",\n            color=\"age_group\",\n        ),\n        size=8,\n        ha=\"right\",\n        va=\"center_baseline\",\n    )\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"35-49\"),\n        aes(x=\"sm_use_percent+2\", y=\"country\", label=\"sm_use_percent_str\"),\n        size=8,\n        ha=\"left\",\n        va=\"center_baseline\",\n        color=\"white\",\n    )\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"18-34\"),\n        aes(\n            x=\"sm_use_percent+2\",\n            y=\"country\",\n            label=\"sm_use_percent_str\",\n            color=\"age_group\",\n        ),\n        size=8,\n        ha=\"left\",\n        va=\"center_baseline\",\n    )\n    # gap difference\n    + geom_text(\n        segment_data,\n        aes(x=xgap, y=\"country\", label=\"gap_str\"),\n        size=9,\n        fontweight=\"bold\",\n        format_string=\"+{}\",\n    )\n)\n\n\n\n\n\n\n\n\nTweak it\n\n# Gallery, elaborate\n\n# The right column (youngest-oldest gap) location\nxgap = 115\n\n(\n    ggplot()\n    # Background Strips                                     # new\n    + geom_segment(\n        segment_data,\n        aes(y=\"country\", yend=\"country\"),\n        x=0,\n        xend=101,\n        size=8.5,\n        color=\"#edece3\",\n    )\n    # vertical grid lines along the strips                  # new\n    + annotate(\n        \"segment\",\n        x=list(range(10, 100, 10)) * n,\n        xend=list(range(10, 100, 10)) * n,\n        y=np.tile(np.arange(1, n + 1), 9) - 0.25,\n        yend=np.tile(np.arange(1, n + 1), 9) + 0.25,\n        color=\"#CCCCCC\",\n    )\n    # Range strip\n    + geom_segment(\n        segment_data,\n        aes(x=\"min\", xend=\"max\", y=\"country\", yend=\"country\"),\n        size=6,\n        color=\"#a7a9ac\",\n    )\n    # Age group markers\n    + geom_point(\n        point_data,\n        aes(\"sm_use_percent\", \"country\", color=\"age_group\", fill=\"age_group\"),\n        size=5,\n        stroke=0.7,\n    )\n    # Age group percentages\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"50+\"),\n        aes(\n            x=\"sm_use_percent-2\",\n            y=\"country\",\n            label=\"sm_use_percent_str\",\n            color=\"age_group\",\n        ),\n        size=8,\n        ha=\"right\",\n        va=\"center_baseline\",\n    )\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"35-49\"),\n        aes(x=\"sm_use_percent+2\", y=\"country\", label=\"sm_use_percent_str\"),\n        size=8,\n        ha=\"left\",\n        va=\"center_baseline\",\n        color=\"white\",\n    )\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"18-34\"),\n        aes(\n            x=\"sm_use_percent+2\",\n            y=\"country\",\n            label=\"sm_use_percent_str\",\n            color=\"age_group\",\n        ),\n        size=8,\n        ha=\"left\",\n        va=\"center_baseline\",\n    )\n    # countries right-hand-size (instead of y-axis)         # new\n    + geom_text(\n        segment_data,\n        aes(y=\"country\", label=\"country\"),\n        x=-1,\n        size=8,\n        ha=\"right\",\n        va=\"center_baseline\",\n        fontweight=\"bold\",\n        color=\"#222222\",\n    )\n    # gap difference\n    + geom_vline(xintercept=xgap, color=\"#edece3\", size=32)  # new\n    + geom_text(\n        segment_data,\n        aes(x=xgap, y=\"country\", label=\"gap_str\"),\n        size=9,\n        va=\"center_baseline\",\n        fontweight=\"bold\",\n        format_string=\"+{}\",\n    )\n    # Annotations                                            # new\n    + annotate(\"text\", x=31, y=n + 1.1, label=\"50+\", size=9, color=\"#ea9f2f\", va=\"top\")\n    + annotate(\n        \"text\", x=56, y=n + 1.1, label=\"35-49\", size=9, color=\"#6d6e71\", va=\"top\"\n    )\n    + annotate(\n        \"text\", x=85, y=n + 1.1, label=\"18-34\", size=9, color=\"#939c49\", va=\"top\"\n    )\n    + annotate(\n        \"text\",\n        x=xgap,\n        y=n + 0.5,\n        label=\"Youngest-\\nOldest Gap\",\n        size=9,\n        color=\"#444444\",\n        va=\"bottom\",\n        ha=\"center\",\n    )\n    + annotate(\"point\", x=[31, 56, 85], y=n + 0.3, alpha=0.85, stroke=0)\n    + annotate(\n        \"segment\",\n        x=[31, 56, 85],\n        xend=[31, 56, 85],\n        y=n + 0.3,\n        yend=n + 0.8,\n        alpha=0.85,\n    )\n    + annotate(\n        \"hline\",\n        yintercept=[x + 0.5 for x in range(2, n, 2)],\n        alpha=0.5,\n        linetype=\"dotted\",\n        size=0.7,\n    )\n\n    # Better spacing and color                              # new\n    + scale_x_continuous(limits=(-18, xgap + 2))\n    + scale_y_discrete(expand=(0, 0.25, 0.1, 0))\n    + scale_fill_manual(values=[\"#c3ca8c\", \"#d1d3d4\", \"#f2c480\"])\n    + scale_color_manual(values=[\"#939c49\", \"#6d6e71\", \"#ea9f2f\"])\n    + guides(color=None, fill=None)\n    + theme_void()\n    + theme(figure_size=(8, 8.5))\n)\n\n\n\n\n\n\n\n\nInstead of looking at this plot as having a country variable on the y-axis and a percentage variable on the x-axis, we can view it as having vertically stacked up many indepedent variables, the values of which have a similar scale.\nProtip: Save a pdf file.\n\n\nChange in Order\nComparing a group of ranked items at two different times\nRead the data.\nSource: World Bank - Infanct Mortality Rate (per 1,000 live births)b\n\ndata = pl.read_csv(\n    \"data/API_SP.DYN.IMRT.IN_DS2_en_csv_v2/API_SP.DYN.IMRT.IN_DS2_en_csv_v2.csv\",\n    skip_rows=4,\n    null_values=\"\",\n    truncate_ragged_lines=True,\n)\n\n# Columns as valid python variables\nyear_columns = {c: f\"y{c}\" for c in data.columns if c[:2] in {\"19\", \"20\"}}\ndata = data.rename(\n    {\"Country Name\": \"country\", \"Country Code\": \"code\", **year_columns}\n).drop([\"Indicator Name\", \"Indicator Code\"])\ndata.head()\n\n\nshape: (5, 60)\n\n\n\ncountry\ncode\ny1960\ny1961\ny1962\ny1963\ny1964\ny1965\ny1966\ny1967\ny1968\ny1969\ny1970\ny1971\ny1972\ny1973\ny1974\ny1975\ny1976\ny1977\ny1978\ny1979\ny1980\ny1981\ny1982\ny1983\ny1984\ny1985\ny1986\ny1987\ny1988\ny1989\ny1990\ny1991\ny1992\ny1993\ny1994\ny1995\ny1996\ny1997\ny1998\ny1999\ny2000\ny2001\ny2002\ny2003\ny2004\ny2005\ny2006\ny2007\ny2008\ny2009\ny2010\ny2011\ny2012\ny2013\ny2014\ny2015\ny2016\n\n\n\nstr\nstr\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nstr\nstr\n\n\n\n\n\"Aruba\"\n\"ABW\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n\n\n\"Afghanistan\"\n\"AFG\"\nnull\n240.5\n236.3\n232.3\n228.5\n224.6\n220.7\n217.0\n213.3\n209.8\n206.1\n202.2\n198.2\n194.3\n190.3\n186.6\n182.6\n178.7\n174.5\n170.4\n166.1\n161.8\n157.5\n153.2\n148.7\n144.5\n140.2\n135.7\n131.3\n126.8\n122.5\n118.3\n114.4\n110.9\n107.7\n105.0\n102.7\n100.7\n98.9\n97.2\n95.4\n93.4\n91.2\n89.0\n86.7\n84.4\n82.3\n80.4\n78.6\n76.8\n75.1\n73.4\n71.7\n69.9\n68.1\n66.3\nnull\nnull\n\n\n\"Angola\"\n\"AGO\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n138.3\n137.5\n136.8\n136.0\n135.3\n134.9\n134.4\n134.1\n133.8\n133.6\n133.5\n133.5\n133.5\n133.4\n133.2\n132.8\n132.3\n131.5\n130.6\n129.5\n128.3\n126.9\n125.5\n124.1\n122.8\n121.2\n119.4\n117.1\n114.7\n112.2\n109.6\n106.8\n104.1\n101.4\n98.8\n96.0\nnull\nnull\n\n\n\"Albania\"\n\"ALB\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n73.0\n68.4\n64.0\n59.9\n56.1\n52.4\n49.1\n45.9\n43.2\n40.8\n38.6\n36.7\n35.1\n33.7\n32.5\n31.4\n30.3\n29.1\n27.9\n26.8\n25.5\n24.4\n23.2\n22.1\n21.0\n20.0\n19.1\n18.3\n17.4\n16.7\n16.0\n15.4\n14.8\n14.3\n13.8\n13.3\n12.9\n12.5\nnull\nnull\n\n\n\"Andorra\"\n\"AND\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n7.5\n7.0\n6.5\n6.1\n5.6\n5.2\n5.0\n4.6\n4.3\n4.1\n3.9\n3.7\n3.5\n3.3\n3.2\n3.1\n2.9\n2.8\n2.7\n2.6\n2.5\n2.4\n2.3\n2.2\n2.1\n2.1\nnull\nnull\n\n\n\n\n\n\nThe data includes regional aggregates. To tell apart the regional aggregates we need the metadata. Every row in the data table has a corresponding row in the metadata table. Where the row has regional aggregate data, the Region column in the metadata table is NaN.\n\ndef ordered_categorical(s, categories=None):\n    \"\"\"\n    Create a categorical ordered according to the categories\n    \"\"\"\n    name = getattr(s, \"name\", \"\")\n    if categories is None:\n        return pl.Series(name, s).cast(pl.Categorical)\n\n    with pl.StringCache():\n        pl.Series(categories).cast(pl.Categorical)\n        return pl.Series(name, s).cast(pl.Categorical)\n\n\ncolumns = {\"Country Code\": \"code\", \"Region\": \"region\", \"IncomeGroup\": \"income_group\"}\n\nmetadata = (\n    pl.scan_csv(\n        \"data/API_SP.DYN.IMRT.IN_DS2_en_csv_v2/Metadata_Country_API_SP.DYN.IMRT.IN_DS2_en_csv_v2.csv\"\n    )\n    .rename(columns)\n    .select(list(columns.values()))\n    .filter(\n        # Drop the regional aggregate information\n        (col(\"region\") != \"\") & (col(\"income_group\") != \"\")\n    )\n    .collect()\n)\n\ncat_order = [\"High income\", \"Upper middle income\", \"Lower middle income\", \"Low income\"]\nmetadata = metadata.with_columns(\n    ordered_categorical(metadata[\"income_group\"], cat_order)\n)\n\nmetadata.head(10)\n\n\nshape: (10, 3)\n\n\n\ncode\nregion\nincome_group\n\n\nstr\nstr\ncat\n\n\n\n\n\"ABW\"\n\"Latin America & Caribbean\"\n\"High income\"\n\n\n\"AFG\"\n\"South Asia\"\n\"Low income\"\n\n\n\"AGO\"\n\"Sub-Saharan Africa\"\n\"Lower middle income\"\n\n\n\"ALB\"\n\"Europe & Central Asia\"\n\"Upper middle income\"\n\n\n\"AND\"\n\"Europe & Central Asia\"\n\"High income\"\n\n\n\"ARE\"\n\"Middle East & North Africa\"\n\"High income\"\n\n\n\"ARG\"\n\"Latin America & Caribbean\"\n\"Upper middle income\"\n\n\n\"ARM\"\n\"Europe & Central Asia\"\n\"Lower middle income\"\n\n\n\"ASM\"\n\"East Asia & Pacific\"\n\"Upper middle income\"\n\n\n\"ATG\"\n\"Latin America & Caribbean\"\n\"High income\"\n\n\n\n\n\n\nRemove the regional aggregates, to create a table with only country data\n\ncountry_data = data.join(metadata, on=\"code\")\ncountry_data.head()\n\n\nshape: (5, 62)\n\n\n\ncountry\ncode\ny1960\ny1961\ny1962\ny1963\ny1964\ny1965\ny1966\ny1967\ny1968\ny1969\ny1970\ny1971\ny1972\ny1973\ny1974\ny1975\ny1976\ny1977\ny1978\ny1979\ny1980\ny1981\ny1982\ny1983\ny1984\ny1985\ny1986\ny1987\ny1988\ny1989\ny1990\ny1991\ny1992\ny1993\ny1994\ny1995\ny1996\ny1997\ny1998\ny1999\ny2000\ny2001\ny2002\ny2003\ny2004\ny2005\ny2006\ny2007\ny2008\ny2009\ny2010\ny2011\ny2012\ny2013\ny2014\ny2015\ny2016\n\nregion\nincome_group\n\n\nstr\nstr\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nstr\nstr\nstr\ncat\n\n\n\n\n\"Aruba\"\n\"ABW\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n\"Latin America & Caribbean\"\n\"High income\"\n\n\n\"Afghanistan\"\n\"AFG\"\nnull\n240.5\n236.3\n232.3\n228.5\n224.6\n220.7\n217.0\n213.3\n209.8\n206.1\n202.2\n198.2\n194.3\n190.3\n186.6\n182.6\n178.7\n174.5\n170.4\n166.1\n161.8\n157.5\n153.2\n148.7\n144.5\n140.2\n135.7\n131.3\n126.8\n122.5\n118.3\n114.4\n110.9\n107.7\n105.0\n102.7\n100.7\n98.9\n97.2\n95.4\n93.4\n91.2\n89.0\n86.7\n84.4\n82.3\n80.4\n78.6\n76.8\n75.1\n73.4\n71.7\n69.9\n68.1\n66.3\nnull\nnull\n\"South Asia\"\n\"Low income\"\n\n\n\"Angola\"\n\"AGO\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n138.3\n137.5\n136.8\n136.0\n135.3\n134.9\n134.4\n134.1\n133.8\n133.6\n133.5\n133.5\n133.5\n133.4\n133.2\n132.8\n132.3\n131.5\n130.6\n129.5\n128.3\n126.9\n125.5\n124.1\n122.8\n121.2\n119.4\n117.1\n114.7\n112.2\n109.6\n106.8\n104.1\n101.4\n98.8\n96.0\nnull\nnull\n\"Sub-Saharan Africa\"\n\"Lower middle income\"\n\n\n\"Albania\"\n\"ALB\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n73.0\n68.4\n64.0\n59.9\n56.1\n52.4\n49.1\n45.9\n43.2\n40.8\n38.6\n36.7\n35.1\n33.7\n32.5\n31.4\n30.3\n29.1\n27.9\n26.8\n25.5\n24.4\n23.2\n22.1\n21.0\n20.0\n19.1\n18.3\n17.4\n16.7\n16.0\n15.4\n14.8\n14.3\n13.8\n13.3\n12.9\n12.5\nnull\nnull\n\"Europe & Central Asia\"\n\"Upper middle income\"\n\n\n\"Andorra\"\n\"AND\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n7.5\n7.0\n6.5\n6.1\n5.6\n5.2\n5.0\n4.6\n4.3\n4.1\n3.9\n3.7\n3.5\n3.3\n3.2\n3.1\n2.9\n2.8\n2.7\n2.6\n2.5\n2.4\n2.3\n2.2\n2.1\n2.1\nnull\nnull\n\"Europe & Central Asia\"\n\"High income\"\n\n\n\n\n\n\nWe are interested in the changes in rank between 1960 and 2015. To plot a reasonable sized graph, we randomly sample 35 countries.\n\nsampled_data = (\n    country_data.drop_nulls(subset=[\"y1960\", \"y2015\"])\n    .sample(n=35, seed=123)\n    .with_columns(\n        y1960_rank=col(\"y1960\").rank(method=\"ordinal\").cast(pl.Int64),\n        y2015_rank=col(\"y2015\").rank(method=\"ordinal\").cast(pl.Int64),\n    )\n    .sort(\"y2015_rank\", descending=True)\n)\n\nsampled_data.head()\n\n\nshape: (5, 64)\n\n\n\ncountry\ncode\ny1960\ny1961\ny1962\ny1963\ny1964\ny1965\ny1966\ny1967\ny1968\ny1969\ny1970\ny1971\ny1972\ny1973\ny1974\ny1975\ny1976\ny1977\ny1978\ny1979\ny1980\ny1981\ny1982\ny1983\ny1984\ny1985\ny1986\ny1987\ny1988\ny1989\ny1990\ny1991\ny1992\ny1993\ny1994\ny1995\ny1996\ny1997\ny1998\ny1999\ny2000\ny2001\ny2002\ny2003\ny2004\ny2005\ny2006\ny2007\ny2008\ny2009\ny2010\ny2011\ny2012\ny2013\ny2014\ny2015\ny2016\n\nregion\nincome_group\ny1960_rank\ny2015_rank\n\n\nstr\nstr\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nstr\nstr\nstr\ncat\ni64\ni64\n\n\n\n\n\"Sierra Leone\"\n\"SLE\"\n223.6\n220.5\n217.5\n214.2\n211.0\n207.6\n204.2\n200.8\n197.3\n194.1\n191.0\n188.0\n185.2\n182.6\n180.0\n177.5\n175.3\n173.2\n171.2\n169.2\n167.3\n165.6\n164.1\n162.8\n161.5\n160.4\n159.4\n158.3\n157.6\n157.0\n156.5\n156.1\n155.7\n155.2\n154.5\n153.4\n152.0\n150.1\n148.1\n145.8\n143.3\n140.5\n137.7\n134.6\n131.4\n128.1\n124.5\n120.5\n116.2\n111.7\n107.0\n102.3\n97.9\n93.8\n90.2\n87.1\nnull\nnull\n\"Sub-Saharan Africa\"\n\"Low income\"\n35\n35\n\n\n\"Cote d'Ivoire\"\n\"CIV\"\n208.4\n203.0\n197.7\n192.8\n188.0\n183.3\n178.7\n174.2\n169.9\n165.4\n161.0\n156.4\n151.3\n146.1\n140.7\n135.1\n129.7\n124.7\n120.2\n116.6\n113.7\n111.4\n109.5\n108.0\n106.9\n106.1\n105.5\n105.2\n104.9\n104.9\n104.9\n104.8\n104.7\n104.7\n104.6\n104.4\n104.0\n103.3\n102.3\n101.0\n99.5\n97.7\n95.7\n93.6\n91.4\n88.9\n86.7\n84.1\n81.3\n79.0\n76.9\n75.0\n72.8\n70.6\n68.5\n66.6\nnull\nnull\n\"Sub-Saharan Africa\"\n\"Lower middle income\"\n33\n34\n\n\n\"Benin\"\n\"BEN\"\n186.9\n183.9\n180.6\n177.1\n173.6\n170.2\n166.8\n164.0\n161.5\n159.2\n157.1\n154.9\n152.5\n149.8\n146.8\n143.5\n140.1\n136.7\n133.6\n130.9\n128.7\n126.6\n124.7\n122.8\n120.9\n118.9\n116.9\n114.8\n112.6\n110.4\n108.0\n105.6\n103.2\n100.9\n98.9\n97.2\n95.6\n94.2\n92.7\n91.1\n89.3\n87.4\n85.2\n83.0\n80.8\n78.8\n76.9\n75.2\n73.7\n72.3\n71.0\n69.8\n68.5\n67.2\n65.7\n64.2\nnull\nnull\n\"Sub-Saharan Africa\"\n\"Low income\"\n32\n33\n\n\n\"Burkina Faso\"\n\"BFA\"\n161.3\n159.4\n157.5\n155.8\n154.3\n153.0\n151.8\n150.9\n150.2\n149.7\n149.3\n148.5\n147.1\n144.6\n141.0\n136.6\n131.9\n127.4\n123.4\n120.2\n117.6\n115.6\n113.9\n112.4\n110.8\n109.0\n107.1\n105.3\n103.8\n102.9\n102.5\n102.3\n102.4\n102.4\n102.1\n101.4\n100.5\n99.4\n98.3\n97.3\n96.2\n95.0\n93.4\n91.4\n88.9\n86.0\n82.7\n79.2\n75.8\n72.5\n69.7\n67.3\n65.4\n63.7\n62.2\n60.9\nnull\nnull\n\"Sub-Saharan Africa\"\n\"Low income\"\n30\n32\n\n\n\"Ghana\"\n\"GHA\"\n125.1\n123.8\n122.7\n121.8\n121.2\n120.8\n120.7\n120.6\n120.6\n120.5\n120.1\n119.5\n118.2\n116.5\n114.2\n111.5\n108.7\n106.0\n103.8\n102.1\n100.9\n100.1\n99.3\n98.4\n96.8\n94.7\n92.1\n89.0\n85.8\n82.7\n79.8\n77.5\n75.6\n74.1\n73.0\n72.0\n71.0\n69.8\n68.4\n66.7\n64.9\n63.0\n61.2\n59.6\n58.1\n56.8\n55.6\n54.4\n53.1\n51.7\n50.2\n48.6\n47.0\n45.5\n44.2\n42.8\nnull\nnull\n\"Sub-Saharan Africa\"\n\"Lower middle income\"\n25\n31\n\n\n\n\n\n\nFirst graph\n\n(\n    ggplot(sampled_data)\n    + geom_text(aes(1, \"y1960_rank\", label=\"country\"), ha=\"right\", size=9)\n    + geom_text(aes(2, \"y2015_rank\", label=\"country\"), ha=\"left\", size=9)\n    + geom_point(aes(1, \"y1960_rank\", color=\"income_group\"), size=2.5)\n    + geom_point(aes(2, \"y2015_rank\", color=\"income_group\"), size=2.5)\n    + geom_segment(\n        aes(x=1, y=\"y1960_rank\", xend=2, yend=\"y2015_rank\", color=\"income_group\")\n    )\n    + scale_y_reverse()\n)\n\n\n\n\n\n\n\n\nIt has the form we want, but we need to tweak it.\n\n# Text colors\nblack1 = \"#252525\"\nblack2 = \"#222222\"\n\n# Gallery, elaborate\n\n(\n    ggplot(sampled_data)\n    # Slight modifications for the original lines,\n    # 1. Nudge the text to either sides of the points\n    # 2. Alter the color and alpha values\n    + geom_text(\n        aes(1, \"y1960_rank\", label=\"country\"),\n        nudge_x=-0.05,\n        ha=\"right\",\n        size=9,\n        color=black1,\n    )\n    + geom_text(\n        aes(2, \"y2015_rank\", label=\"country\"),\n        nudge_x=0.05,\n        ha=\"left\",\n        size=9,\n        color=black1,\n    )\n    + geom_point(aes(1, \"y1960_rank\", color=\"income_group\"), size=2.5, alpha=0.7)\n    + geom_point(aes(2, \"y2015_rank\", color=\"income_group\"), size=2.5, alpha=0.7)\n    + geom_segment(\n        aes(x=1, y=\"y1960_rank\", xend=2, yend=\"y2015_rank\", color=\"income_group\"),\n        alpha=0.7,\n    )\n    # Text Annotations\n    + annotate(\n        \"text\",\n        x=1,\n        y=0,\n        label=\"Rank in 1960\",\n        fontweight=\"bold\",\n        ha=\"right\",\n        size=10,\n        color=black2,\n    )\n    + annotate(\n        \"text\",\n        x=2,\n        y=0,\n        label=\"Rank in 2015\",\n        fontweight=\"bold\",\n        ha=\"left\",\n        size=10,\n        color=black2,\n    )\n    + annotate(\n        \"text\", x=1.5, y=0, label=\"Lines show change in rank\", size=9, color=black1\n    )\n    + annotate(\n        \"label\",\n        x=1.5,\n        y=3,\n        label=\"Lower infant\\ndeath rates\",\n        size=9,\n        color=black1,\n        label_size=0,\n        fontstyle=\"italic\",\n    )\n    + annotate(\n        \"label\",\n        x=1.5,\n        y=33,\n        label=\"Higher infant\\ndeath rates\",\n        size=9,\n        color=black1,\n        label_size=0,\n        fontstyle=\"italic\",\n    )\n    # Prevent country names from being chopped off\n    + lims(x=(0.35, 2.65))\n    + labs(color=\"Income Group\")\n    # Countries with lower rates on top\n    + scale_y_reverse()\n    # Change colors\n    + scale_color_brewer(type=\"qual\", palette=2)\n    # Removes all decorations\n    + theme_void()\n    # Changing the figure size prevents the country names from squishing up\n    + theme(figure_size=(8, 11))\n)\n\n\n\n\n\n\n\n\n\nSource: NOTE: This notebook uses the polars package"
  },
  {
    "objectID": "reference/geom_ribbon.html",
    "href": "reference/geom_ribbon.html",
    "title": " plotnine.geom_ribbon",
    "section": "",
    "text": "geom_ribbon(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    outline_type=\"both\",\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_ribbon.html#parameters",
    "href": "reference/geom_ribbon.html#parameters",
    "title": " plotnine.geom_ribbon",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\nymax\n\n\n\nymin\n\n\n\nalpha\n1\n\n\ncolor\n'none'\n\n\nfill\n'#333333'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\nwhere\nTrue\n\n\n\nThe bold aesthetics are required.\nAesthetics Descriptions\n\nwhere\n\nDefine where to exclude horizontal regions from being filled. Regions between any two False values are skipped. For sensible demarcation the value used in the where predicate expression should match the ymin value or expression. i.e.\n aes(ymin=0, ymax=\"col1\", where=\"col1 &gt; 0\")  # good\n aes(ymin=0, ymax=\"col1\", where=\"col1 &gt; 10\")  # bad\n\n aes(ymin=col2, ymax=\"col1\", where=\"col1 &gt; col2\")  # good\n aes(ymin=col2, ymax=\"col1\", where=\"col1 &gt; col3\")  # bad\n\n\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\noutline_type : Literal[\"upper\", \"lower\", \"both\", \"full\"] = \"both\"\n\nHow to stroke to outline of the region / area. If upper, draw only upper bounding line. If lower, draw only lower bounding line. If both, draw both upper & lower bounding lines. If full, draw closed polygon around the area.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_raster.html",
    "href": "reference/geom_raster.html",
    "title": " plotnine.geom_raster",
    "section": "",
    "text": "geom_raster(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=True,\n    vjust=0.5,\n    hjust=0.5,\n    interpolation=None,\n    filterrad=4.0,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_raster.html#parameters",
    "href": "reference/geom_raster.html#parameters",
    "title": " plotnine.geom_raster",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\nfill\n'#333333'\n\n\ngroup\n\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = True\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nhjust : float = 0.5\n\nHorizontal justification for the rectangle at point x. Default is 0.5, which centers the rectangle horizontally. Must be in the range [0, 1].\n\nvjust : float = 0.5\n\nVertical justification for the rectangle at point y Default is 0.5, which centers the rectangle vertically. Must be in the range [0, 1].\n\ninterpolation : str = None\n\nHow to calculate values between the center points of adjacent rectangles. The default is None not to interpolate. Allowed values are:\n\"antialiased\"\n\"nearest\"\n\"bilinear\"\n\"bicubic\"\n\"spline16\"\n\"spline36\"\n\"hanning\"\n\"hamming\"\n\"hermite\"\n\"kaiser\"\n\"quadric\"\n\"catrom\"\n\"gaussian\"\n\"bessel\"\n\"mitchell\"\n\"sinc\"\n\"lanczos\"\n\"blackman\"\n\nfilterrad : float = 4.0\n\nThe filter radius for filters that have a radius parameter, i.e. when interpolation is one of: sinc, lanczos, blackman. Must be a number greater than zero.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_raster.html#see-also",
    "href": "reference/geom_raster.html#see-also",
    "title": " plotnine.geom_raster",
    "section": "See Also",
    "text": "See Also\n\ngeom_rect\n\n\n\ngeom_tile"
  },
  {
    "objectID": "reference/geom_qq_line.html",
    "href": "reference/geom_qq_line.html",
    "title": " plotnine.geom_qq_line",
    "section": "",
    "text": "geom_qq_line(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"qq_line\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_qq_line.html#parameters",
    "href": "reference/geom_qq_line.html#parameters",
    "title": " plotnine.geom_qq_line",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"qq_line\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_polygon.html",
    "href": "reference/geom_polygon.html",
    "title": " plotnine.geom_polygon",
    "section": "",
    "text": "geom_polygon(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_polygon.html#parameters",
    "href": "reference/geom_polygon.html#parameters",
    "title": " plotnine.geom_polygon",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\nNone\n\n\nfill\n'#333333'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_polygon.html#notes",
    "href": "reference/geom_polygon.html#notes",
    "title": " plotnine.geom_polygon",
    "section": "Notes",
    "text": "Notes\nAll paths in the same group aesthetic value make up a polygon."
  },
  {
    "objectID": "reference/geom_pointdensity.html",
    "href": "reference/geom_pointdensity.html",
    "title": " plotnine.geom_pointdensity",
    "section": "",
    "text": "geom_pointdensity(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"pointdensity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_pointdensity.html#parameters",
    "href": "reference/geom_pointdensity.html#parameters",
    "title": " plotnine.geom_pointdensity",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\nfill\nNone\n\n\ngroup\n\n\n\nshape\n'o'\n\n\nsize\n1.5\n\n\nstroke\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"pointdensity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_path.html",
    "href": "reference/geom_path.html",
    "title": " plotnine.geom_path",
    "section": "",
    "text": "geom_path(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    lineend=\"butt\",\n    linejoin=\"round\",\n    arrow=None,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_path.html#parameters",
    "href": "reference/geom_path.html#parameters",
    "title": " plotnine.geom_path",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nlineend : Literal[\"butt\", \"round\", \"projecting\"] = \"butt\"\n\nLine end style. This option is applied for solid linetypes.\n\nlinejoin : Literal[\"round\", \"miter\", \"bevel\"] = \"round\"\n\nLine join style. This option is applied for solid linetypes.\n\narrow : arrow = None\n\nArrow specification. Default is no arrow.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_path.html#see-also",
    "href": "reference/geom_path.html#see-also",
    "title": " plotnine.geom_path",
    "section": "See Also",
    "text": "See Also\n\narrow\n\nfor adding arrowhead(s) to paths."
  },
  {
    "objectID": "reference/geom_path.html#examples",
    "href": "reference/geom_path.html#examples",
    "title": " plotnine.geom_path",
    "section": "Examples",
    "text": "Examples\n\n\nimport pandas as pd\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_path,\n    geom_line,\n    labs,\n    scale_color_continuous,\n    element_text,\n    theme,\n)\nfrom plotnine.data import economics\n\n\nPath plots\ngeom_path() connects the observations in the order in which they appear in the data, this is different from geom_line() which connects observations in order of the variable on the x axis.\n\neconomics.head(10)  # notice the rows are ordered by date\n\n\n\n\n\n\n\n\ndate\npce\npop\npsavert\nuempmed\nunemploy\n\n\n\n\n0\n1967-07-01\n507.4\n198712\n12.5\n4.5\n2944\n\n\n1\n1967-08-01\n510.5\n198911\n12.5\n4.7\n2945\n\n\n2\n1967-09-01\n516.3\n199113\n11.7\n4.6\n2958\n\n\n3\n1967-10-01\n512.9\n199311\n12.5\n4.9\n3143\n\n\n4\n1967-11-01\n518.1\n199498\n12.5\n4.7\n3066\n\n\n5\n1967-12-01\n525.8\n199657\n12.1\n4.8\n3018\n\n\n6\n1968-01-01\n531.5\n199808\n11.7\n5.1\n2878\n\n\n7\n1968-02-01\n534.2\n199920\n12.2\n4.5\n3001\n\n\n8\n1968-03-01\n544.9\n200056\n11.6\n4.1\n2877\n\n\n9\n1968-04-01\n544.6\n200208\n12.2\n4.6\n2709\n\n\n\n\n\n\n\nBecause the data is in date order geom_path() (in pint) produces the same result as geom_line() (in black):\n\n(\n    ggplot(economics, aes(x=\"date\", y=\"unemploy\"))\n    + geom_line(size=5)  # plot geom_line as the first layer\n    + geom_path(\n        colour=\"#ff69b4\",  # plot a path - colour pink\n        size=1,\n    )\n    + labs(x=\"date\", y=\"unemployment (,000)\")  # label x & y-axis\n)\n\n\n\n\n\n\n\n\nPlotting unemployment (scaled by population) versus savings rate shows how geom_path() differs from geom_line(). Because geom_path() connects the observations in the order in which they appear in the data, this line is like a “journey through time”:\n\n(\n    ggplot(economics, aes(x=\"unemploy/pop\", y=\"psavert\"))\n    + geom_path()  # plot geom path\n    + labs(x=\"scaled unemployment\", y=\"saving rate\")  # label x & y-axis\n)\n\n\n\n\n\n\n\n\nComparing geom_line() (black) to geom_path() (pink) shows how these two plots differ in what they can show: geom_path() shows the savings rate has gone down over time, which is not evident with geom_path().\n\n(\n    ggplot(economics, aes(x=\"unemploy/pop\", y=\"psavert\"))\n    + geom_path(\n        colour=\"#ff69b4\",  # plot geom_path as the first layer - colour pink\n        alpha=0.5,  # line transparency\n        size=2.5,\n    )  # line thickness\n    + geom_line()  # layer geom_line\n    + labs(x=\"scaled unemployment\", y=\"saving rate\")  # label x & y-axis\n)\n\n\n\n\n\n\n\n\nThe geom_path can be easier to interpret if time is coloured in. First convert time to a number, and use this number to colour the path:\n\n# convert date to a number\neconomics[\"date_as_number\"] = pd.to_numeric(economics[\"date\"])\n\n\n# inspect new column\neconomics.head()\n\n\n\n\n\n\n\n\ndate\npce\npop\npsavert\nuempmed\nunemploy\ndate_as_number\n\n\n\n\n0\n1967-07-01\n507.4\n198712\n12.5\n4.5\n2944\n-79056000000000000\n\n\n1\n1967-08-01\n510.5\n198911\n12.5\n4.7\n2945\n-76377600000000000\n\n\n2\n1967-09-01\n516.3\n199113\n11.7\n4.6\n2958\n-73699200000000000\n\n\n3\n1967-10-01\n512.9\n199311\n12.5\n4.9\n3143\n-71107200000000000\n\n\n4\n1967-11-01\n518.1\n199498\n12.5\n4.7\n3066\n-68428800000000000\n\n\n\n\n\n\n\nThe path is coloured such that it changes with time using the command aes(colour='date_as_number') within geom_path().\n\n# input\nlegend_breaks = [\n    -79056000000000000,\n    709948800000000000,\n    1401580800000000000,\n]  # used to modify colour-graded legend\nlegend_labels = [\"1967-Jul\", \"1992-Jun\", \"2014-Jun\"]\n\n# plot\n(\n    ggplot(economics, aes(x=\"unemploy/pop\", y=\"psavert\"))\n    + geom_path(\n        aes(colour=\"date_as_number\")\n    )  # colour geom_path using time variable \"date_as_number\"\n    + labs(x=\"scaled unemployment\", y=\"saving rate\")\n    + scale_color_continuous(\n        breaks=legend_breaks,  # set legend breaks (where labels will appear)\n        labels=legend_labels,\n    )  # set labels on legend\n    + theme(legend_title=element_text(text=\"Date\"))  # set title of legend\n)\n\n\n\n\n\n\n\n\n\nSource: Path plots"
  },
  {
    "objectID": "reference/geom_linerange.html",
    "href": "reference/geom_linerange.html",
    "title": " plotnine.geom_linerange",
    "section": "",
    "text": "geom_linerange(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_linerange.html#parameters",
    "href": "reference/geom_linerange.html#parameters",
    "title": " plotnine.geom_linerange",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\nymax\n\n\n\nymin\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_linerange.html#examples",
    "href": "reference/geom_linerange.html#examples",
    "title": " plotnine.geom_linerange",
    "section": "Examples",
    "text": "Examples\n\n\nimport pandas as pd\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    geom_line,\n    geom_linerange,\n    element_blank,\n    element_rect,\n    theme,\n    theme_matplotlib,\n    theme_set,\n)\n\n# Set default theme\n# matplotlib + the background of 538\ntheme_set(\n    theme_matplotlib()\n    + theme(\n        plot_background=element_rect(fill=\"#F0F0F0\"),\n        panel_background=element_rect(fill=\"#F0F0F0\"),\n    )\n)\n\n\nUpper & Lower Trends\nThe data\n\ndf = pd.DataFrame({\n    \"x\": range(0, 6),\n    \"y\": [3, 4, 3.5, 4.5, 4, 4]\n})\n\nCreate the line ranges\n\n(ggplot(df, aes(\"x\", \"y\"))\n + geom_linerange(aes(ymin=\"y-2\", ymax=\"y\"))\n)\n\n\n\n\n\n\n\n\nAdd points at each end of the ranges.\n\n(ggplot(df, aes(\"x\", \"y\"))\n + geom_linerange(aes(ymin=\"y-2\", ymax=\"y\"))\n + geom_point()\n + geom_point(aes(y=\"y-2\"))\n\n)\n\n\n\n\n\n\n\n\nAdd a trend-line along the top of the ranges and one along the bottom of the ranges. The line is added before(below) the points.\n\n(ggplot(df, aes(\"x\", \"y\"))\n + geom_linerange(aes(ymin=\"y-2\", ymax=\"y\"))\n \n + geom_line()\n + geom_point()\n\n + geom_line(aes(y=\"y-2\"))\n + geom_point(aes(y=\"y-2\"))\n\n)\n\n\n\n\n\n\n\n\nAdd some color.\n\n# Gallery, lines\nmagenta = \"#9E2F68\"\nmagenta_light = \"#E5C8D6\"\n\nsea_green = \"#2F9E65\"\nsea_green_light = \"#C8E5D7\"\n\n(ggplot(df, aes(\"x\", \"y\"))\n + geom_linerange(aes(ymin=\"y-2\", ymax=\"y\"))\n \n + geom_line(color=magenta, size=3)\n + geom_point(color=magenta, fill=magenta_light, size=3, stroke=0.5)\n \n + geom_line(aes(y=\"y-2\"), color=sea_green, size=3)\n + geom_point(aes(y=\"y-2\"), color=sea_green, fill=sea_green_light, size=3, stroke=0.5)\n)\n\n\n\n\n\n\n\n\n\nSource: Set default theme"
  },
  {
    "objectID": "reference/geom_label.html",
    "href": "reference/geom_label.html",
    "title": " plotnine.geom_label",
    "section": "",
    "text": "geom_label(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    parse=False,\n    nudge_x=0,\n    nudge_y=0,\n    adjust_text=None,\n    format_string=None,\n    path_effects=None,\n    boxstyle=\"round\",\n    boxcolor=None,\n    label_padding=0.25,\n    label_r=0.25,\n    label_size=0.7,\n    tooth_size=None,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_label.html#parameters",
    "href": "reference/geom_label.html#parameters",
    "title": " plotnine.geom_label",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nlabel\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\nangle\n0\n\n\ncolor\n'black'\n\n\nfamily\nNone\n\n\nfill\n'white'\n\n\nfontstyle\n'normal'\n\n\nfontvariant\nNone\n\n\nfontweight\n'normal'\n\n\ngroup\n\n\n\nha\n'center'\n\n\nlineheight\n1.2\n\n\nsize\n11\n\n\nva\n'center'\n\n\n\nThe bold aesthetics are required.\nAesthetics Descriptions\n\nsize\n\nFloat or one of:\n{\n    \"xx-small\", \"x-small\", \"small\", \"medium\", \"large\",\n    \"x-large\", \"xx-large\"\n}\n\nha\n\nHorizontal alignment. One of {\"left\", \"center\", \"right\"}.\n\nva\n\nVertical alignment. One of {\"top\", \"center\", \"bottom\", \"baseline\", \"center_baseline\"}.\n\nfamily\n\nFont family. Can be a font name e.g. “Arial”, “Helvetica”, “Times”, … or a family that is one of {\"serif\", \"sans-serif\", \"cursive\", \"fantasy\", \"monospace\"}}\n\nfontweight\n\nFont weight. A numeric value in range 0-1000 or a string that is one of:\n{\n    \"ultralight\", \"light\", \"normal\", \"regular\", \"book\", \"medium\",\n    \"roman\", \"semibold\", \"demibold\", \"demi\", \"bold\", \"heavy\",\n    \"extra bold\", \"black\"\n}\n\nfontstyle\n\nFont style. One of {\"normal\", \"italic\", \"oblique\"}.\n\nfontvariant\n\nFont variant. One of {\"normal\", \"small-caps\"}.\n\n\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nboxstyle : str = \"round\"\n\nOptions are:\n'circle'\n'darrow'\n'larrow'\n'rarrow'\n'round '\n'round4'\n'roundtooth'\n'sawtooth'\n'square'\n\nboxcolor\n\nColor of box around the text. If None, the color is the same as the text.\n\nlabel_padding : float = 0.25\n\nAmount of padding\n\nlabel_r : float = 0.25\n\nRounding radius of corners.\n\nlabel_size : float = 0.7\n\nLinewidth of the label boundary.\n\ntooth_size : float = None\n\nSize of the roundtooth or sawtooth if they are the chosen boxstyle. The default depends on Matplotlib\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_label.html#see-also",
    "href": "reference/geom_label.html#see-also",
    "title": " plotnine.geom_label",
    "section": "See Also",
    "text": "See Also\n\ngeom_text\n\nFor documentation of the parameters. BoxStyle for the parameters that affect the boxstyle."
  },
  {
    "objectID": "reference/geom_hline.html",
    "href": "reference/geom_hline.html",
    "title": " plotnine.geom_hline",
    "section": "",
    "text": "geom_hline(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=False,\n    show_legend=None,\n    raster=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_hline.html#parameters",
    "href": "reference/geom_hline.html#parameters",
    "title": " plotnine.geom_hline",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nyintercept\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = False\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_hline.html#examples",
    "href": "reference/geom_hline.html#examples",
    "title": " plotnine.geom_hline",
    "section": "Examples",
    "text": "Examples\n\n\n\nfrom plotnine import ggplot, aes, geom_point, geom_hline, facet_grid, labs\nfrom plotnine.data import mpg\n\n\nHorizontal line\ngeom_hline() draws a vertical line, and is useful as a guide.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nIt’s useful to use geom_hline() with some data, so we start with a basic scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nNow add a horizontal line to the scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_hline(yintercept=25)  # add one horizonal line\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can add many horizontal lines:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_hline(yintercept=[25, 35, 45])  # add many horizontal lines using a list\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can change the look of the line:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_hline(\n        yintercept=25,\n        color=\"yellow\",  # set line colour\n        size=2,  # set line thickness\n        linetype=\"dashed\",  # set line type\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nAnd you can add horizontal lines to a facet plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_hline(yintercept=25)  # add a vertical line...\n    + facet_grid(\"drv\")  # ... to a facet plot\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\n\nSource: Horizontal line"
  },
  {
    "objectID": "reference/geom_freqpoly.html",
    "href": "reference/geom_freqpoly.html",
    "title": " plotnine.geom_freqpoly",
    "section": "",
    "text": "geom_freqpoly(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"bin\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    lineend=\"butt\",\n    linejoin=\"round\",\n    arrow=None,\n    **kwargs\n)\n\n\nFrequency polygon\nSee geom_path for documentation of the parameters."
  },
  {
    "objectID": "reference/geom_errorbar.html",
    "href": "reference/geom_errorbar.html",
    "title": " plotnine.geom_errorbar",
    "section": "",
    "text": "geom_errorbar(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    width=0.5,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_errorbar.html#parameters",
    "href": "reference/geom_errorbar.html#parameters",
    "title": " plotnine.geom_errorbar",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\nymax\n\n\n\nymin\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nwidth : float = 0.5\n\nBar width as a fraction of the resolution of the data.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_density_2d.html",
    "href": "reference/geom_density_2d.html",
    "title": " plotnine.geom_density_2d",
    "section": "",
    "text": "geom_density_2d(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"density_2d\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_density_2d.html#parameters",
    "href": "reference/geom_density_2d.html#parameters",
    "title": " plotnine.geom_density_2d",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"density_2d\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_crossbar.html",
    "href": "reference/geom_crossbar.html",
    "title": " plotnine.geom_crossbar",
    "section": "",
    "text": "geom_crossbar(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    width=0.5,\n    fatten=2,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_crossbar.html#parameters",
    "href": "reference/geom_crossbar.html#parameters",
    "title": " plotnine.geom_crossbar",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nymax\n\n\n\nymin\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\nfill\nNone\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nwidth : float = 0.5\n\nBox width as a fraction of the resolution of the data.\n\nfatten : float = 2\n\nA multiplicative factor used to increase the size of the middle bar across the box.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_col.html",
    "href": "reference/geom_col.html",
    "title": " plotnine.geom_col",
    "section": "",
    "text": "geom_col(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"stack\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    just=0.5,\n    width=None,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_col.html#parameters",
    "href": "reference/geom_col.html#parameters",
    "title": " plotnine.geom_col",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\nNone\n\n\nfill\n'#595959'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"stack\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\njust : float = 0.5\n\nHow to align the column with respect to the axis breaks. The default 0.5 aligns the center of the column with the break. 0 aligns the left of the of the column with the break and 1 aligns the right of the column with the break.\n\nwidth : float = None\n\nBar width. If None, the width is set to 90% of the resolution of the data.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_col.html#see-also",
    "href": "reference/geom_col.html#see-also",
    "title": " plotnine.geom_col",
    "section": "See Also",
    "text": "See Also\n\ngeom_bar"
  },
  {
    "objectID": "reference/geom_col.html#examples",
    "href": "reference/geom_col.html#examples",
    "title": " plotnine.geom_col",
    "section": "Examples",
    "text": "Examples\n\n\nimport pandas as pd\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_col,\n    geom_text,\n    position_dodge,\n    lims,\n    theme,\n    element_text,\n    element_blank,\n    element_rect,\n    element_line,\n)\n\n\nTwo Variable Bar Plot\nVisualising on a single plot the values of a variable that has nested (and independent) variables\nCreate the data\n\ndf = pd.DataFrame(\n    {\n        \"variable\": [\n            \"gender\",\n            \"gender\",\n            \"age\",\n            \"age\",\n            \"age\",\n            \"income\",\n            \"income\",\n            \"income\",\n            \"income\",\n        ],\n        \"category\": [\n            \"Female\",\n            \"Male\",\n            \"1-24\",\n            \"25-54\",\n            \"55+\",\n            \"Lo\",\n            \"Lo-Med\",\n            \"Med\",\n            \"High\",\n        ],\n        \"value\": [60, 40, 50, 30, 20, 10, 25, 25, 40],\n    }\n)\ndf[\"variable\"] = pd.Categorical(df[\"variable\"], categories=[\"gender\", \"age\", \"income\"])\ndf[\"category\"] = pd.Categorical(df[\"category\"], categories=df[\"category\"])\n\ndf\n\n\n\n\n\n\n\n\nvariable\ncategory\nvalue\n\n\n\n\n0\ngender\nFemale\n60\n\n\n1\ngender\nMale\n40\n\n\n2\nage\n1-24\n50\n\n\n3\nage\n25-54\n30\n\n\n4\nage\n55+\n20\n\n\n5\nincome\nLo\n10\n\n\n6\nincome\nLo-Med\n25\n\n\n7\nincome\nMed\n25\n\n\n8\nincome\nHigh\n40\n\n\n\n\n\n\n\nWe want to visualise this data and at a galance get an idea to how the value breaks down along the categorys for the different variable. Note that each variable has different categorys.\nFirst we make a simple plot with all this information and see what to draw from it.\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col()\n)\n\n\n\n\n\n\n\n\nAll the values along each variable add up to 100, but stacked together the difference within and without the groups is not clear. The solution is to dodge the bars.\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col(stat=\"identity\", position=\"dodge\")  # modified\n)  \n\n\n\n\n\n\n\n\nThis is good, it gives us the plot we want but the legend is not great. Each variable has a different set of categorys, but the legend has them all clamped together. We cannot easily change the legend, but we can replicate it’s purpose by labelling the individual bars.\nTo do this, we create a geom_text with position_dodge(width=0.9) to match the ratio of the space taken up by each variable. If there was no spacing between the bars of different variables, we would have width=1.\nA minor quack, when text extends beyond the limits we have to manually make space or it would get clipped. Therefore we adjust the bottom y limits.\n\ndodge_text = position_dodge(width=0.9)  # new\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col(stat=\"identity\", position=\"dodge\", show_legend=False)  # modified\n    + geom_text(\n        aes(y=-0.5, label=\"category\"),  # new\n        position=dodge_text,\n        color=\"gray\",\n        size=8,\n        angle=45,\n        va=\"top\",\n    )\n    + lims(y=(-5, 60))  # new\n)\n\n\n\n\n\n\n\n\nWould it look too crowded if we add value labels on top of the bars?\n\ndodge_text = position_dodge(width=0.9)\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col(stat=\"identity\", position=\"dodge\", show_legend=False)\n    + geom_text(\n        aes(y=-0.5, label=\"category\"),\n        position=dodge_text,\n        color=\"gray\",\n        size=8,\n        angle=45,\n        va=\"top\",\n    )\n    + geom_text(\n        aes(label=\"value\"),  # new\n        position=dodge_text,\n        size=8,\n        va=\"bottom\",\n        format_string=\"{}%\",\n    )\n    + lims(y=(-5, 60))\n)\n\n\n\n\n\n\n\n\nThat looks okay. The values line up with the categorys because we used the same dodge parameters. For the final polish, we remove the y-axis, clear out the panel and make the variable and category labels have the same color.\n\n# Gallery, bars\n\ndodge_text = position_dodge(width=0.9)\nccolor = \"#555555\"\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col(stat=\"identity\", position=\"dodge\", show_legend=False)\n    + geom_text(\n        aes(y=-0.5, label=\"category\"),\n        position=dodge_text,\n        color=ccolor,\n        size=8,\n        angle=45,\n        va=\"top\",\n    )  # modified\n    + geom_text(\n        aes(label=\"value\"),\n        position=dodge_text,\n        size=8,\n        va=\"bottom\",\n        format_string=\"{}%\",\n    )\n    + lims(y=(-5, 60))\n    + theme(\n        panel_background=element_rect(fill=\"white\"),  # new\n        axis_title_y=element_blank(),\n        axis_line_x=element_line(color=\"black\"),\n        axis_line_y=element_blank(),\n        axis_text_y=element_blank(),\n        axis_text_x=element_text(color=ccolor),\n        axis_ticks_major_y=element_blank(),\n        panel_grid=element_blank(),\n        panel_border=element_blank(),\n    )\n)\n\n\n\n\n\n\n\n\nCredit: I saved a plot this example is based on a while ago and forgot/misplaced the link to the source. The user considered it a minor coup.\n\nSource: Two Variable Bar Plot"
  },
  {
    "objectID": "reference/geom_blank.html",
    "href": "reference/geom_blank.html",
    "title": " plotnine.geom_blank",
    "section": "",
    "text": "geom_blank(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_blank.html#parameters",
    "href": "reference/geom_blank.html#parameters",
    "title": " plotnine.geom_blank",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\n\n\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_bar.html",
    "href": "reference/geom_bar.html",
    "title": " plotnine.geom_bar",
    "section": "",
    "text": "geom_bar(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"count\",\n    position=\"stack\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    just=0.5,\n    width=None,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_bar.html#parameters",
    "href": "reference/geom_bar.html#parameters",
    "title": " plotnine.geom_bar",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\nNone\n\n\nfill\n'#595959'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"count\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"stack\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\njust : float = 0.5\n\nHow to align the column with respect to the axis breaks. The default 0.5 aligns the center of the column with the break. 0 aligns the left of the of the column with the break and 1 aligns the right of the column with the break.\n\nwidth : float = None\n\nBar width. If None, the width is set to 90% of the resolution of the data.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_bar.html#see-also",
    "href": "reference/geom_bar.html#see-also",
    "title": " plotnine.geom_bar",
    "section": "See Also",
    "text": "See Also\n\ngeom_histogram"
  },
  {
    "objectID": "reference/geom_bar.html#examples",
    "href": "reference/geom_bar.html#examples",
    "title": " plotnine.geom_bar",
    "section": "Examples",
    "text": "Examples\n\n\n\nfrom plotnine import ggplot, aes, geom_bar, labs, coord_flip, theme_classic\nfrom plotnine.data import mpg\n\n\nBar chart\ngeom_bar() makes the height of the bar proportional to the number of cases in each group\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\n\n\nBar Plot with Counts\n\n# Gallery, distributions\nggplot(mpg) + geom_bar(aes(x=\"class\"))\n\n\n\n\n\n\n\n\n\n\nSorting the bars\nWe can use the internal function reorder to sort the bars depending on the size of each group. In this case we create a variable class2 with values equal to those of class so because class is a reserved name and:\nreorder(class, class, len)\nis not a valid python expression, while:\nreorder(class2, class2, len)\nis a valid python expression.\n\nmpg[\"class2\"] = mpg[\"class\"]\n\n(\n    ggplot(mpg)\n    + geom_bar(aes(x=\"reorder(class2, class2, len)\"))\n    + labs(x=\"class\")\n)\n\n\n\n\n\n\n\n\nAnd in descending order\n\n(\n    ggplot(mpg)\n    + geom_bar(\n        aes(x=\"reorder(class2, class2, len, ascending=False)\")\n    )\n    + labs(x=\"class\")\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(mpg)\n    + geom_bar(aes(x=\"class\", fill=\"drv\"))\n)\n\n\n\n\n\n\n\n\n\n\nHorizontal Bar Plot with Counts\n\n# Gallery, distributions\n(\n    ggplot(mpg) \n    + geom_bar(aes(x=\"class\", fill=\"drv\"))\n    + coord_flip()\n    + theme_classic()\n)\n\n\n\n\n\n\n\n\n\nSource: Bar chart"
  },
  {
    "objectID": "reference/geom_abline.html",
    "href": "reference/geom_abline.html",
    "title": " plotnine.geom_abline",
    "section": "",
    "text": "geom_abline(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=False,\n    show_legend=None,\n    raster=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_abline.html#parameters",
    "href": "reference/geom_abline.html#parameters",
    "title": " plotnine.geom_abline",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nintercept\n\n\n\nslope\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = False\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_abline.html#examples",
    "href": "reference/geom_abline.html#examples",
    "title": " plotnine.geom_abline",
    "section": "Examples",
    "text": "Examples\n\n\n\nfrom plotnine import ggplot, aes, geom_point, labs, geom_abline, facet_grid\nfrom plotnine.data import mpg\n\n\nAB line\ngeom_abline() draws a line when the yintercept and gradient is supplied, and is useful as a guide.\n\n# inspect the data\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nIt’s useful to use geom_abline() with some data, so we start with a basic scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nNow layer a line over the scatter plot using geom_abline(). geom_abline() requires inputs for the slope (default slope is 1) and y-intercept (default value is [0,0]).\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_abline(\n        intercept=45,  # set the y-intercept value\n        slope=-5,  # set the slope value\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can plot two lines on one plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_abline(\n        intercept=[45, 45],  # add many lines to a plot using a list for the y-intercepts...\n        slope=[-5, -7],  # ... and for the slopes\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can change the look of the line:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_abline(\n        intercept=45,\n        slope=-5,\n        color=\"blue\",  # set line colour\n        size=2,  # set line thickness\n        linetype=\"dashed\",  # set line type\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\ngeom_abline() can be used with a facet plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_abline(intercept=45, slope=-5)  # add a line ...\n    + facet_grid(\"drv\")  # ... to a facet plot.\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\n\nSource: AB line"
  },
  {
    "objectID": "reference/figure_size.html",
    "href": "reference/figure_size.html",
    "title": " plotnine.options.figure_size",
    "section": "",
    "text": "figure_size : tuple[float, float] = (640 / dpi, 480 / dpi)\n\n\nDefault figure size in inches"
  },
  {
    "objectID": "reference/faithfuld.html",
    "href": "reference/faithfuld.html",
    "title": " plotnine.data.faithfuld",
    "section": "",
    "text": "faithfuld = pd.read_csv(DATA_DIR / \"faithfuld.csv\")"
  },
  {
    "objectID": "reference/faithfuld.html#description",
    "href": "reference/faithfuld.html#description",
    "title": " plotnine.data.faithfuld",
    "section": "Description",
    "text": "Description\nWaiting time between eruptions and the duration of the eruption for the Old Faithful geyser in Yellowstone National Park, Wyoming, USA."
  },
  {
    "objectID": "reference/faithfuld.html#format",
    "href": "reference/faithfuld.html#format",
    "title": " plotnine.data.faithfuld",
    "section": "Format",
    "text": "Format\nA data frame with grid data for 272 observations on 2 variables and the density at those locations.\n\n\n\nColumn\nDescription\n\n\n\n\neruptions\nEruption time in mins\n\n\nwaiting W\naiting time to next eruption (in mins)\n\n\ndensity D\nensity Estimate"
  },
  {
    "objectID": "reference/faithfuld.html#details",
    "href": "reference/faithfuld.html#details",
    "title": " plotnine.data.faithfuld",
    "section": "Details",
    "text": "Details\nA closer look at faithful.eruptions reveals that these are heavily rounded times originally in seconds, where multiples of 5 are more frequent than expected under non-human measurement. For a better version of the eruption times, see the example below.\nThere are many versions of this dataset around: Azzalini and Bowman (1990) use a more complete version."
  },
  {
    "objectID": "reference/faithfuld.html#source",
    "href": "reference/faithfuld.html#source",
    "title": " plotnine.data.faithfuld",
    "section": "Source",
    "text": "Source\nW. Härdle."
  },
  {
    "objectID": "reference/faithfuld.html#references",
    "href": "reference/faithfuld.html#references",
    "title": " plotnine.data.faithfuld",
    "section": "References",
    "text": "References\nHärdle, W. (1991) Smoothing Techniques with Implementation in S. New York: Springer.\nAzzalini, A. and Bowman, A. W. (1990). A look at some data on the Old Faithful geyser. Applied Statistics 39, 357–365."
  },
  {
    "objectID": "reference/factor.html",
    "href": "reference/factor.html",
    "title": " plotnine.mapping._eval_environment.factor",
    "section": "",
    "text": "factor(values, categories=None, ordered=None)"
  },
  {
    "objectID": "reference/factor.html#parameters",
    "href": "reference/factor.html#parameters",
    "title": " plotnine.mapping._eval_environment.factor",
    "section": "Parameters",
    "text": "Parameters\n\n\nvalues : Sequence[Any]\n\nThe values of the categorical. If categories are given, values not in categories will be replaced with NaN.\n\ncategories : Sequence[Any] | None = None\n\nThe unique categories for this categorical. If not given, the categories are assumed to be the unique values of values (sorted, if possible, otherwise in the order in which they appear).\n\nordered : bool | None = None\n\nWhether or not this categorical is treated as a ordered categorical. If True, the resulting categorical will be ordered. An ordered categorical respects, when sorted, the order of its categories attribute (which in turn is the categories argument, if provided)."
  },
  {
    "objectID": "reference/factor.html#examples",
    "href": "reference/factor.html#examples",
    "title": " plotnine.mapping._eval_environment.factor",
    "section": "Examples",
    "text": "Examples\n\n\nfrom plotnine import ggplot, aes, geom_bar\nfrom plotnine.data import mtcars\n\nggplot(mtcars, aes(x=\"factor(cyl)\")) + geom_bar()\n\n\n\n\n\n\n\n\nSource: factor.ipynb"
  },
  {
    "objectID": "reference/facet_null.html",
    "href": "reference/facet_null.html",
    "title": " plotnine.facet_null",
    "section": "",
    "text": "facet_null(shrink=True)"
  },
  {
    "objectID": "reference/facet_null.html#parameters",
    "href": "reference/facet_null.html#parameters",
    "title": " plotnine.facet_null",
    "section": "Parameters",
    "text": "Parameters\n\n\nshrink : bool = True\n\nWhether to shrink the scales to the output of the statistics instead of the raw data."
  },
  {
    "objectID": "reference/facet.html",
    "href": "reference/facet.html",
    "title": " plotnine.facets.facet.facet",
    "section": "",
    "text": "facet(\n    scales=\"fixed\",\n    shrink=True,\n    labeller=\"label_value\",\n    as_table=True,\n    drop=True,\n    dir=\"h\"\n)"
  },
  {
    "objectID": "reference/facet.html#parameters",
    "href": "reference/facet.html#parameters",
    "title": " plotnine.facets.facet.facet",
    "section": "Parameters",
    "text": "Parameters\n\n\nscales : Literal[\"fixed\", \"free\", \"free_x\", \"free_y\"] = \"fixed\"\n\nWhether x or y scales should be allowed (free) to vary according to the data on each of the panel.\n\nshrink : bool = True\n\nWhether to shrink the scales to the output of the statistics instead of the raw data. Default is True.\n\nlabeller : CanBeStripLabellingFunc = \"label_value\"\n\nHow to label the facets. A string value if it should be one of [\"label_value\", \"label_both\", \"label_context\"].\n\nas_table : bool = True\n\nIf True, the facets are laid out like a table with the highest values at the bottom-right. If False the facets are laid out like a plot with the highest value a the top-right\n\ndrop : bool = True\n\nIf True, all factor levels not used in the data will automatically be dropped. If False, all factor levels will be shown, regardless of whether or not they appear in the data.\n\ndir : Literal[\"h\", \"v\"] = \"h\"\n\nDirection in which to layout the panels. h for horizontal and v for vertical."
  },
  {
    "objectID": "reference/facet.html#methods",
    "href": "reference/facet.html#methods",
    "title": " plotnine.facets.facet.facet",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_layout\nCompute layout\n\n\nfinish_data\nModify data before it is drawn out by the geom\n\n\nmake_strips\nCreate strips for the facet\n\n\nmap\nAssign a data points to panels\n\n\nset_limits_breaks_and_labels\nAdd limits, breaks and labels to the axes\n\n\nsetup_data\nAllow the facet to manipulate the data\n\n\nsetup_params\nCreate facet parameters\n\n\ntrain_position_scales\nCompute ranges for the x and y scales\n\n\n\n\n compute_layout\n\ncompute_layout(data)\n\n\nCompute layout\n\n\nParameters\n\n\ndata : list[pd.DataFrame]\n\nDataframe for a each layer\n\n\n\n\n\n\n finish_data\n\nfinish_data(data, layout)\n\n\nModify data before it is drawn out by the geom\nThe default is to return the data without modification. Subclasses should override this method as the require.\n\n\nParameters\n\n\ndata : pd.DataFrame\n\nA single layer’s data.\n\nlayout : Layout\n\nLayout\n\n\n\n\n\nReturns\n\n\npd.DataFrame\n\nModified layer data\n\n\n\n\n\n\n make_strips\n\nmake_strips(layout_info, ax)\n\n\nCreate strips for the facet\n\n\nParameters\n\n\nlayout_info : layout_details\n\nLayout information. Row from the layout table\n\nax : Axes\n\nAxes to label\n\n\n\n\n\n\n map\n\nmap(data, layout)\n\n\nAssign a data points to panels\n\n\nParameters\n\n\ndata : pd.DataFrame\n\nData for a layer\n\nlayout : pd.DataFrame\n\nAs returned by self.compute_layout\n\n\n\n\n\nReturns\n\n\npd.DataFrame\n\nData with all points mapped to the panels on which they will be plotted.\n\n\n\n\n\n\n set_limits_breaks_and_labels\n\nset_limits_breaks_and_labels(panel_params, ax)\n\n\nAdd limits, breaks and labels to the axes\n\n\nParameters\n\n\npanel_params : panel_view\n\nrange information for the axes\n\nax : Axes\n\nAxes\n\n\n\n\n\n\n setup_data\n\nsetup_data(data)\n\n\nAllow the facet to manipulate the data\n\n\nParameters\n\n\ndata : list[pd.DataFrame]\n\nData for each of the layers\n\n\n\n\n\nReturns\n\n\nlist[pd.DataFrame]\n\nData for each of the layers\n\n\n\n\n\nNotes\nThis method will be called after setup_params, therefore the params property will be set.\n\n\n\n setup_params\n\nsetup_params(data)\n\n\nCreate facet parameters\n\n\nParameters\n\n\ndata : list[pd.DataFrame]\n\nPlot data and data for the layers\n\n\n\n\n\n\n train_position_scales\n\ntrain_position_scales(layout, layers)\n\n\nCompute ranges for the x and y scales"
  },
  {
    "objectID": "reference/element_text.html",
    "href": "reference/element_text.html",
    "title": " plotnine.element_text",
    "section": "",
    "text": "element_text(\n    family=None,\n    style=None,\n    weight=None,\n    color=None,\n    size=None,\n    ha=None,\n    va=None,\n    ma=None,\n    rotation=None,\n    linespacing=None,\n    backgroundcolor=None,\n    margin=None,\n    rotation_mode=None,\n    kwargs={}\n)"
  },
  {
    "objectID": "reference/element_text.html#parameters",
    "href": "reference/element_text.html#parameters",
    "title": " plotnine.element_text",
    "section": "Parameters",
    "text": "Parameters\n\n\nfamily : str | list[str] | None = None\n\nFont family. See set_family for supported values.\n\nstyle : str | Sequence[str] | None = None\n\nFont style\n\ncolor : str | tuple[float, float, float] | tuple[float, float, float, float] | Sequence[str | tuple[float, float, float] | tuple[float, float, float, float]] | None = None\n\nText color\n\nweight : int | str | Sequence[int | str] | None = None\n\nShould be one of normal, bold, heavy, light, ultrabold or ultralight.\n\nsize : float | Sequence[float] | None = None\n\ntext size\n\nha : Literal[\"center\", \"left\", \"right\"] | float | None = None\n\nHorizontal Alignment.\n\nva : Literal[\"center\", \"top\", \"bottom\", \"baseline\", \"center_baseline\"] | float | None = None\n\nVertical alignment.\n\nma : Literal[\"center\", \"left\", \"right\"] | float | None = None\n\nHorizontal Alignment for multiline text.\n\nrotation : Literal[\"vertical\", \"horizontal\"] | float | Sequence[Literal[\"vertical\", \"horizontal\"]] | Sequence[float] | None = None\n\nRotation angle in the range [0, 360]. The rotation is affected by the rotation_mode.\n\nrotation_mode : Literal[\"default\", \"anchor\"] | None = None\n\nHow to do the rotation. If None or \"default\", first rotate the text then align the bounding box of the rotated text. If \"anchor\", first align the unrotated text then rotate the text around the point of alignment.\n\nlinespacing : float = None\n\nLine spacing\n\nbackgroundcolor : str | tuple[float, float, float] | tuple[float, float, float, float] | Sequence[str | tuple[float, float, float] | tuple[float, float, float, float]] | None = None\n\nBackground color\n\nmargin : Margin | dict[Literal[\"t\", \"b\", \"l\", \"r\", \"unit\"], Any] | None = None\n\nMargin around the text. The keys are t, b, l, r and units. The tblr keys are floats. The unit is one of pt, lines or in. Not all text themeables support margin parameters and other than the units, only some of the other keys may apply.\n\nkwargs : Any = {}\n\nParameters recognised by Text"
  },
  {
    "objectID": "reference/element_text.html#notes",
    "href": "reference/element_text.html#notes",
    "title": " plotnine.element_text",
    "section": "Notes",
    "text": "Notes\nelement_text will accept parameters that conform to the ggplot2 element_text API, but it is preferable the Matplotlib based API described above."
  },
  {
    "objectID": "reference/element_line.html",
    "href": "reference/element_line.html",
    "title": " plotnine.element_line",
    "section": "",
    "text": "element_line(\n    *,\n    color=None,\n    size=None,\n    linetype=None,\n    lineend=None,\n    colour=None,\n    kwargs={}\n)"
  },
  {
    "objectID": "reference/element_line.html#parameters",
    "href": "reference/element_line.html#parameters",
    "title": " plotnine.element_line",
    "section": "Parameters",
    "text": "Parameters\n\n\ncolor : str | tuple = None\n\nline color\n\ncolour : str | tuple = None\n\nalias of color\n\nlinetype : str | tuple = None\n\nline style. if a string, it should be one of solid, dashed, dashdot or dotted. you can create interesting dashed patterns using tuples, see set_linestyle.\n\nsize : float = None\n\nline thickness\n\nkwargs : dict = {}\n\nParameters recognised by line2d."
  },
  {
    "objectID": "reference/economics_long.html",
    "href": "reference/economics_long.html",
    "title": " plotnine.data.economics_long",
    "section": "",
    "text": "economics_long = pd.read_csv(DATA_DIR / \"economics_long.csv\", parse_dates=[0])"
  },
  {
    "objectID": "reference/economics_long.html#description",
    "href": "reference/economics_long.html#description",
    "title": " plotnine.data.economics_long",
    "section": "Description",
    "text": "Description\nThis dataset was produced from US economic time series data available from http://research.stlouisfed.org/fred2. economics is in “wide” format, economics_long is in “long” format."
  },
  {
    "objectID": "reference/economics_long.html#format",
    "href": "reference/economics_long.html#format",
    "title": " plotnine.data.economics_long",
    "section": "Format",
    "text": "Format\nA data frame with 478 rows and 6 variables\n\n\n\nColumn\nDescription\n\n\n\n\ndate\nMonth of data collection\n\n\npsavert\npersonal savings rate 1\n\n\npce\npersonal consumption expenditures, in billions of dollars 2\n\n\nunemploy\nnumber of unemployed in thousands 3\n\n\nuempmed\nmedian duration of unemployment, in week 4\n\n\npop\ntotal population, in thousands 5"
  },
  {
    "objectID": "reference/economics_long.html#footnotes",
    "href": "reference/economics_long.html#footnotes",
    "title": " plotnine.data.economics_long",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttp://research.stlouisfed.org/fred2/series/PSAVERT↩︎\nhttp://research.stlouisfed.org/fred2/series/PCE↩︎\nhttp://research.stlouisfed.org/fred2/series/UNEMPLOY↩︎\nhttp://research.stlouisfed.org/fred2/series/UEMPMED↩︎\nhttp://research.stlouisfed.org/fred2/series/POP↩︎"
  },
  {
    "objectID": "reference/dpi.html",
    "href": "reference/dpi.html",
    "title": " plotnine.options.dpi",
    "section": "",
    "text": "dpi : int = 100\n\n\nDefault DPI used by the themes"
  },
  {
    "objectID": "reference/current_theme.html",
    "href": "reference/current_theme.html",
    "title": " plotnine.options.current_theme",
    "section": "",
    "text": "current_theme : Optional[theme | Type[theme]] = None\n\n\nTheme used when none is added to the ggplot object\nAnother way to do it, to set a default theme using theme_set()."
  },
  {
    "objectID": "reference/coord_flip.html",
    "href": "reference/coord_flip.html",
    "title": " plotnine.coord_flip",
    "section": "",
    "text": "coord_flip(xlim=None, ylim=None, expand=True)"
  },
  {
    "objectID": "reference/coord_flip.html#parameters",
    "href": "reference/coord_flip.html#parameters",
    "title": " plotnine.coord_flip",
    "section": "Parameters",
    "text": "Parameters\n\n\nxlim : tuple[float, float] = None\n\nLimits for x axis. If None, then they are automatically computed.\n\nylim : tuple[float, float] = None\n\nLimits for y axis. If None, then they are automatically computed.\n\nexpand : bool = True\n\nIf True, expand the coordinate axes by some factor. If False, use the limits from the data."
  },
  {
    "objectID": "reference/coord_equal.html",
    "href": "reference/coord_equal.html",
    "title": " plotnine.coord_equal",
    "section": "",
    "text": "coord_equal(ratio=1, xlim=None, ylim=None, expand=True)"
  },
  {
    "objectID": "reference/coord_equal.html#parameters",
    "href": "reference/coord_equal.html#parameters",
    "title": " plotnine.coord_equal",
    "section": "Parameters",
    "text": "Parameters\n\n\nratio : float = 1\n\nDesired aspect_ratio (:math:y/x) of the panel(s).\n\nxlim : tuple[float, float] = None\n\nLimits for x axis. If None, then they are automatically computed.\n\nylim : tuple[float, float] = None\n\nLimits for y axis. If None, then they are automatically computed.\n\nexpand : bool = True\n\nIf True, expand the coordinate axes by some factor. If False, use the limits from the data."
  },
  {
    "objectID": "reference/coord_equal.html#notes",
    "href": "reference/coord_equal.html#notes",
    "title": " plotnine.coord_equal",
    "section": "Notes",
    "text": "Notes\nTo specify aspect ratio of the visual size for the axes use the aspect_ratio themeable.\nggplot(data, aes('x', 'y')) + theme(aspect_ratio=0.5)\nWhen changing the aspect_ratio in either way, the width of the panel remains constant (as derived from the plotnine.themes.themeable.figure_size themeable) and the height is altered to achieve desired ratio."
  },
  {
    "objectID": "reference/coord.html",
    "href": "reference/coord.html",
    "title": " plotnine.coords.coord.coord",
    "section": "",
    "text": "coord()"
  },
  {
    "objectID": "reference/coord.html#attributes",
    "href": "reference/coord.html#attributes",
    "title": " plotnine.coords.coord.coord",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nis_linear\nbool(x) -&gt; bool\n\n\n\n\n is_linear\n\nis_linear = False\n\n\nbool(x) -&gt; bool\nReturns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed."
  },
  {
    "objectID": "reference/coord.html#methods",
    "href": "reference/coord.html#methods",
    "title": " plotnine.coords.coord.coord",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\naspect\nReturn desired aspect ratio for the plot\n\n\nbacktransform_range\nBacktransform the panel range in panel_params to data coordinates\n\n\nlabels\nModify labels\n\n\nrange\nReturn the range along the dimensions of the coordinate system\n\n\nsetup_data\nAllow the coordinate system to manipulate the layer data\n\n\nsetup_layout\nAllow the coordinate system alter the layout dataframe\n\n\nsetup_panel_params\nCompute the range and break information for the panel\n\n\nsetup_params\nCreate additional parameters\n\n\ntransform\nTransform data before it is plotted\n\n\n\n\n aspect\n\naspect(panel_params)\n\n\nReturn desired aspect ratio for the plot\nIf not overridden by the subclass, this method returns None, which means that the coordinate system does not influence the aspect ratio.\n\n\n\n backtransform_range\n\nbacktransform_range(panel_params)\n\n\nBacktransform the panel range in panel_params to data coordinates\nCoordinate systems that do any transformations should override this method. e.g. coord_trans has to override this method.\n\n\n\n labels\n\nlabels(cur_labels)\n\n\nModify labels\n\n\nParameters\n\n\ncur_labels : labels_view\n\nCurrent labels. The coord can modify them as necessary.\n\n\n\n\n\nReturns\n\n\nlabels_view\n\nModified labels. Same object as the input.\n\n\n\n\n\n\n range\n\nrange(panel_params)\n\n\nReturn the range along the dimensions of the coordinate system\n\n\n\n setup_data\n\nsetup_data(data)\n\n\nAllow the coordinate system to manipulate the layer data\n\n\nParameters\n\n\ndata : list[pd.DataFrame]\n\nData for all Layer\n\n\n\n\n\nReturns\n\n\nlist[pd.DataFrame]\n\nModified layer data\n\n\n\n\n\n\n setup_layout\n\nsetup_layout(layout)\n\n\nAllow the coordinate system alter the layout dataframe\n\n\nParameters\n\n\nlayout : pd.DataFrame\n\nDataframe in which data is assigned to panels and scales\n\n\n\n\n\nReturns\n\n\npd.DataFrame\n\nlayout dataframe altered to according to the requirements of the coordinate system.\n\n\n\n\n\nNotes\nThe input dataframe may be changed.\n\n\n\n setup_panel_params\n\nsetup_panel_params(scale_x, scale_y)\n\n\nCompute the range and break information for the panel\n\n\n\n setup_params\n\nsetup_params(data)\n\n\nCreate additional parameters\nA coordinate system may need to create parameters depending on the original data that the layers get.\n\n\nParameters\n\n\ndata : list[pd.DataFrame]\n\nData for each layer before it is manipulated in any way.\n\n\n\n\n\n\n transform\n\ntransform(data, panel_params, munch=False)\n\n\nTransform data before it is plotted\nThis is used to “transform the coordinate axes”. Subclasses should override this method"
  },
  {
    "objectID": "reference/base_family.html",
    "href": "reference/base_family.html",
    "title": " plotnine.options.base_family",
    "section": "",
    "text": "base_family : str = \"sans-serif\"\n\n\nThe base font family for all text that is part of the theme. Default is sans-serif and one is chosen automatically from rcParams[“font.san-serif”]"
  },
  {
    "objectID": "reference/axis_title_x.html",
    "href": "reference/axis_title_x.html",
    "title": " plotnine.themes.themeable.axis_title_x",
    "section": "",
    "text": "axis_title_x(theme_element)"
  },
  {
    "objectID": "reference/axis_title_x.html#parameters",
    "href": "reference/axis_title_x.html#parameters",
    "title": " plotnine.themes.themeable.axis_title_x",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/axis_ticks_y.html",
    "href": "reference/axis_ticks_y.html",
    "title": " plotnine.themes.themeable.axis_ticks_y",
    "section": "",
    "text": "axis_ticks_y(theme_element)"
  },
  {
    "objectID": "reference/axis_ticks_y.html#parameters",
    "href": "reference/axis_ticks_y.html#parameters",
    "title": " plotnine.themes.themeable.axis_ticks_y",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/axis_ticks_minor_y.html",
    "href": "reference/axis_ticks_minor_y.html",
    "title": " plotnine.themes.themeable.axis_ticks_minor_y",
    "section": "",
    "text": "axis_ticks_minor_y(theme_element)"
  },
  {
    "objectID": "reference/axis_ticks_minor_y.html#parameters",
    "href": "reference/axis_ticks_minor_y.html#parameters",
    "title": " plotnine.themes.themeable.axis_ticks_minor_y",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/axis_ticks_minor.html",
    "href": "reference/axis_ticks_minor.html",
    "title": " plotnine.themes.themeable.axis_ticks_minor",
    "section": "",
    "text": "axis_ticks_minor(theme_element)"
  },
  {
    "objectID": "reference/axis_ticks_minor.html#parameters",
    "href": "reference/axis_ticks_minor.html#parameters",
    "title": " plotnine.themes.themeable.axis_ticks_minor",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/axis_ticks_major_x.html",
    "href": "reference/axis_ticks_major_x.html",
    "title": " plotnine.themes.themeable.axis_ticks_major_x",
    "section": "",
    "text": "axis_ticks_major_x(theme_element)"
  },
  {
    "objectID": "reference/axis_ticks_major_x.html#parameters",
    "href": "reference/axis_ticks_major_x.html#parameters",
    "title": " plotnine.themes.themeable.axis_ticks_major_x",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/axis_ticks_length_minor_y.html",
    "href": "reference/axis_ticks_length_minor_y.html",
    "title": " plotnine.themes.themeable.axis_ticks_length_minor_y",
    "section": "",
    "text": "axis_ticks_length_minor_y(theme_element)"
  },
  {
    "objectID": "reference/axis_ticks_length_minor_y.html#parameters",
    "href": "reference/axis_ticks_length_minor_y.html#parameters",
    "title": " plotnine.themes.themeable.axis_ticks_length_minor_y",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float | complex\n\nValue in points. A negative value creates the ticks inside the plot panel. A complex value (e.g. 3j) creates ticks that span both in and out of the panel."
  },
  {
    "objectID": "reference/axis_ticks_length_minor.html",
    "href": "reference/axis_ticks_length_minor.html",
    "title": " plotnine.themes.themeable.axis_ticks_length_minor",
    "section": "",
    "text": "axis_ticks_length_minor(theme_element)"
  },
  {
    "objectID": "reference/axis_ticks_length_minor.html#parameters",
    "href": "reference/axis_ticks_length_minor.html#parameters",
    "title": " plotnine.themes.themeable.axis_ticks_length_minor",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float | complex\n\nValue in points. A negative value creates the ticks inside the plot panel. A complex value (e.g. 3j) creates ticks that span both in and out of the panel."
  },
  {
    "objectID": "reference/axis_ticks_length_major_x.html",
    "href": "reference/axis_ticks_length_major_x.html",
    "title": " plotnine.themes.themeable.axis_ticks_length_major_x",
    "section": "",
    "text": "axis_ticks_length_major_x(theme_element)"
  },
  {
    "objectID": "reference/axis_ticks_length_major_x.html#parameters",
    "href": "reference/axis_ticks_length_major_x.html#parameters",
    "title": " plotnine.themes.themeable.axis_ticks_length_major_x",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float | complex\n\nValue in points. A negative value creates the ticks inside the plot panel. A complex value (e.g. 3j) creates ticks that span both in and out of the panel."
  },
  {
    "objectID": "reference/axis_ticks_length.html",
    "href": "reference/axis_ticks_length.html",
    "title": " plotnine.themes.themeable.axis_ticks_length",
    "section": "",
    "text": "axis_ticks_length(theme_element)"
  },
  {
    "objectID": "reference/axis_ticks_length.html#parameters",
    "href": "reference/axis_ticks_length.html#parameters",
    "title": " plotnine.themes.themeable.axis_ticks_length",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float | complex\n\nValue in points. A negative value creates the ticks inside the plot panel. A complex value (e.g. 3j) creates ticks that span both in and out of the panel."
  },
  {
    "objectID": "reference/axis_text_y.html",
    "href": "reference/axis_text_y.html",
    "title": " plotnine.themes.themeable.axis_text_y",
    "section": "",
    "text": "axis_text_y(theme_element)"
  },
  {
    "objectID": "reference/axis_text_y.html#parameters",
    "href": "reference/axis_text_y.html#parameters",
    "title": " plotnine.themes.themeable.axis_text_y",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/axis_text_y.html#notes",
    "href": "reference/axis_text_y.html#notes",
    "title": " plotnine.themes.themeable.axis_text_y",
    "section": "Notes",
    "text": "Notes\nUse the margin to control the gap between the ticks and the text. e.g.\ntheme(axis_text_y=element_text(margin={\"r\": 5, \"units\": \"pt\"}))\ncreates a margin of 5 points."
  },
  {
    "objectID": "reference/axis_text.html",
    "href": "reference/axis_text.html",
    "title": " plotnine.themes.themeable.axis_text",
    "section": "",
    "text": "axis_text(theme_element)"
  },
  {
    "objectID": "reference/axis_text.html#parameters",
    "href": "reference/axis_text.html#parameters",
    "title": " plotnine.themes.themeable.axis_text",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/axis_text.html#notes",
    "href": "reference/axis_text.html#notes",
    "title": " plotnine.themes.themeable.axis_text",
    "section": "Notes",
    "text": "Notes\nUse the margin to control the gap between the ticks and the text. e.g.\ntheme(axis_text=element_text(margin={\"t\": 5, \"r\": 5, \"units\": \"pt\"}))\ncreates a margin of 5 points."
  },
  {
    "objectID": "reference/axis_line_x.html",
    "href": "reference/axis_line_x.html",
    "title": " plotnine.themes.themeable.axis_line_x",
    "section": "",
    "text": "axis_line_x(theme_element)"
  },
  {
    "objectID": "reference/axis_line_x.html#parameters",
    "href": "reference/axis_line_x.html#parameters",
    "title": " plotnine.themes.themeable.axis_line_x",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/axis_line_x.html#attributes",
    "href": "reference/axis_line_x.html#attributes",
    "title": " plotnine.themes.themeable.axis_line_x",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nposition\nstr(object=’’) -&gt; str\n\n\n\n\n position\n\nposition = \"bottom\"\n\n\nstr(object=’’) -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str\nCreate a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to ‘strict’."
  },
  {
    "objectID": "reference/aspect_ratio.html",
    "href": "reference/aspect_ratio.html",
    "title": " plotnine.options.aspect_ratio",
    "section": "",
    "text": "aspect_ratio : Literal[\"auto\"] | float = \"auto\"\n\n\nDefault aspect ratio used by the themes"
  },
  {
    "objectID": "reference/arrow.html",
    "href": "reference/arrow.html",
    "title": " plotnine.arrow",
    "section": "",
    "text": "arrow(angle=30, length=0.2, ends=\"last\", type=\"open\")"
  },
  {
    "objectID": "reference/arrow.html#parameters",
    "href": "reference/arrow.html#parameters",
    "title": " plotnine.arrow",
    "section": "Parameters",
    "text": "Parameters\n\n\nangle : float = 30\n\nangle in degrees between the tail a single edge.\n\nlength : float = 0.2\n\nof the edge in “inches”\n\nends : Literal[\"first\", \"last\", \"both\"] = \"last\"\n\nAt which end of the line to draw the arrowhead\n\ntype : Literal[\"open\", \"closed\"] = \"open\"\n\nWhen it is closed, it is also filled"
  },
  {
    "objectID": "reference/annotation_stripes.html",
    "href": "reference/annotation_stripes.html",
    "title": " plotnine.annotation_stripes",
    "section": "",
    "text": "annotation_stripes(\n    fill=(\"#AAAAAA\", \"#CCCCCC\"),\n    fill_range=\"auto\",\n    direction=\"vertical\",\n    extend=(0, 1),\n    kwargs={}\n)"
  },
  {
    "objectID": "reference/annotation_stripes.html#parameters",
    "href": "reference/annotation_stripes.html#parameters",
    "title": " plotnine.annotation_stripes",
    "section": "Parameters",
    "text": "Parameters\n\n\nfill : Sequence[str] = (\"#AAAAAA\", \"#CCCCCC\")\n\nList of colors for the strips.\n\nfill_range : Literal[\"auto\", \"cycle\", \"no\", \"nocycle\"] = \"auto\"\n\nHow to fill stripes beyond the range of scale:\n\"cycle\"      # keep cycling the colors of the\n             # stripes after the range ends\n\"nocycle\"    # stop cycling the colors of the\n             # stripes after the range ends\n\"auto\"       # \"cycle\" for continuous scales and\n             # \"nocycle\" for discrete scales.\n\"no\"         # Do not add stripes passed the range\n             # passed the range of the scales\n\ndirection : Literal[\"horizontal\", \"vertical\"] = \"vertical\"\n\nOrientation of the stripes\n\nextend : tuple[float, float] = (0, 1)\n\nRange of the stripes. The default is (0, 1), top to bottom. The values should be in the range [0, 1].\n\n**kwargs : Any = {}\n\nOther aesthetic parameters for the rectangular stripes. They include; alpha, color, linetype, and size."
  },
  {
    "objectID": "reference/annotate.html",
    "href": "reference/annotate.html",
    "title": " plotnine.annotate",
    "section": "",
    "text": "annotate(\n    geom,\n    x=None,\n    y=None,\n    xmin=None,\n    xmax=None,\n    xend=None,\n    xintercept=None,\n    ymin=None,\n    ymax=None,\n    yend=None,\n    yintercept=None,\n    kwargs={}\n)"
  },
  {
    "objectID": "reference/annotate.html#parameters",
    "href": "reference/annotate.html#parameters",
    "title": " plotnine.annotate",
    "section": "Parameters",
    "text": "Parameters\n\n\ngeom : str | type[geom_base_class]\n\ngeom to use for annotation, or name of geom (e.g. ‘point’).\n\nx : float | None = None\n\nPosition\n\ny : float | None = None\n\nPosition\n\nxmin : float | None = None\n\nPosition\n\nymin : float | None = None\n\nPosition\n\nxmax : float | None = None\n\nPosition\n\nymax : float | None = None\n\nPosition\n\nxend : float | None = None\n\nPosition\n\nyend : float | None = None\n\nPosition\n\nxintercept : float | None = None\n\nPosition\n\nyintercept : float | None = None\n\nPosition\n\nkwargs : Any = {}\n\nOther aesthetics or parameters to the geom."
  },
  {
    "objectID": "reference/annotate.html#notes",
    "href": "reference/annotate.html#notes",
    "title": " plotnine.annotate",
    "section": "Notes",
    "text": "Notes\nThe positioning aethetics x, y, xmin, ymin, xmax, ymax, xend, yend, xintercept, yintercept depend on which geom is used.\nYou should choose or ignore accordingly.\nAll geoms are created with stat=\"identity\"."
  },
  {
    "objectID": "reference/after_scale.html",
    "href": "reference/after_scale.html",
    "title": " plotnine.after_scale",
    "section": "",
    "text": "after_scale(x)"
  },
  {
    "objectID": "reference/after_scale.html#parameters",
    "href": "reference/after_scale.html#parameters",
    "title": " plotnine.after_scale",
    "section": "Parameters",
    "text": "Parameters\n\n\nx : str\n\nAn expression"
  },
  {
    "objectID": "reference/after_scale.html#see-also",
    "href": "reference/after_scale.html#see-also",
    "title": " plotnine.after_scale",
    "section": "See Also",
    "text": "See Also\n\nafter_stat\n\n\n\nstage"
  },
  {
    "objectID": "reference/after_scale.html#examples",
    "href": "reference/after_scale.html#examples",
    "title": " plotnine.after_scale",
    "section": "Examples",
    "text": "Examples\n\n\nimport pandas as pd\n\nfrom plotnine import ggplot, aes, after_scale, geom_bar, theme_classic\n\n\nafter_scale\nThe bars in geom_bar have two aesthetics that control the coloring; fill for the interior and color for the boundary/edge. Using after_scale we can create a matching combination of these two.\nStart off with a mapping to the color.\n\ndf = pd.DataFrame({\"var1\": [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]})\n\n(\n    ggplot(df, aes(\"var1\", color=\"factor(var1)\"))\n    + geom_bar(size=1)\n)\n\n\n\n\n\n\n\n\nWe can match the color with the fill.\n\n(\n    ggplot(df, aes(\"var1\", color=\"factor(var1)\"))\n    + geom_bar(aes(fill=after_scale(\"color\")), size=1)\n)\n\n\n\n\n\n\n\n\nAs after_scale takes an expression, for the fill aesthetic we can modify the color by adding to it an alpha channel i.e. '#AABBCC' to '#AABBCC66'.\n\n(\n    ggplot(df, aes(\"var1\", color=\"factor(var1)\"))\n    + geom_bar(aes(fill=after_scale('color + \"66\"')), size=1)\n)\n\n\n\n\n\n\n\n\nWe rely on the fact that you can append a string to all elements of a pandas series\npd.Series(['#AABBCC', '#112233']) + '66' == pd.Series(['#AABBCC66', '#11223366'])\nWith a fitting theme.\n\n(\n    ggplot(df, aes(\"var1\", color=\"factor(var1)\"))\n    + geom_bar(aes(fill=after_scale('color + \"66\"')), size=1)\n    + theme_classic()\n)\n\n\n\n\n\n\n\n\n\nSource: after_scale"
  },
  {
    "objectID": "reference/PlotnineAnimation.html",
    "href": "reference/PlotnineAnimation.html",
    "title": " plotnine.animation.PlotnineAnimation",
    "section": "",
    "text": "PlotnineAnimation(\n    plots, interval=200, repeat_delay=None, repeat=True, blit=False\n)"
  },
  {
    "objectID": "reference/PlotnineAnimation.html#parameters",
    "href": "reference/PlotnineAnimation.html#parameters",
    "title": " plotnine.animation.PlotnineAnimation",
    "section": "Parameters",
    "text": "Parameters\n\n\nplots : Iterable[ggplot]\n\nggplot objects that make up the the frames of the animation\n\ninterval : int = 200\n\nDelay between frames in milliseconds. Defaults to 200.\n\nrepeat_delay : int = None\n\nIf the animation in repeated, adds a delay in milliseconds before repeating the animation. Defaults to None.\n\nrepeat : bool = True\n\nControls whether the animation should repeat when the sequence of frames is completed. Defaults to True.\n\nblit : bool = False\n\nControls whether blitting is used to optimize drawing. Defaults to False."
  },
  {
    "objectID": "reference/PlotnineAnimation.html#notes",
    "href": "reference/PlotnineAnimation.html#notes",
    "title": " plotnine.animation.PlotnineAnimation",
    "section": "Notes",
    "text": "Notes\n\nThe plots should have the same facet and the facet should not have fixed x and y scales.\nThe scales of all the plots should have the same limits. It is a good idea to create a scale (with limits) for each aesthetic and add them to all the plots."
  },
  {
    "objectID": "reference/PlotnineAnimation.html#examples",
    "href": "reference/PlotnineAnimation.html#examples",
    "title": " plotnine.animation.PlotnineAnimation",
    "section": "Examples",
    "text": "Examples\n\n\nimport pandas as pd\nimport numpy as np\nfrom plotnine import ggplot, aes, geom_path, theme, theme_void, lims\nfrom plotnine.animation import PlotnineAnimation\n\n# for animation in the notebook\nfrom matplotlib import rc\n\nrc(\"animation\", html=\"html5\")\n\n\nSpiral Animation\nHow to create Animations\nThe PlotnineAnimation methods takes a sequence of plots and animates them. The best way to create the sequence is to use a function that generates plots.\nNOTE: When creating the plots make sure all the plots have scales with the same limits for each aesthetic, including the x and y aesthetics.\n\n# Parameters used to control the spiral\nn = 100\ntightness = 1.3\nkmin = 1\nkmax = 25\nnum_frames = 25\ntheta = np.linspace(-np.pi, np.pi, n)\n\n\ndef plot(k):\n    # For every plot we change the theta\n    _theta = theta * k\n\n    # Polar Equation of each spiral\n    r = tightness * _theta\n\n    df = pd.DataFrame({\n        \"theta\": _theta,\n        \"r\": r,\n        \"x\": r * np.sin(_theta),\n        \"y\": r * np.cos(_theta)\n    })\n\n    p = (\n        ggplot(df)\n        + geom_path(aes(\"x\", \"y\", color=\"theta\"), size=1)\n        + lims(\n            # All the plots have scales with the same limits\n            x=(-130, 130),\n            y=(-130, 130),\n            color=(-kmax * np.pi, kmax * np.pi),\n        )\n        + theme_void()\n        + theme(aspect_ratio=1)\n    )\n    return p\n\n\n# It is better to use a generator instead of a list\nplots = (plot(k) for k in np.linspace(kmin, kmax, num_frames))\nani = PlotnineAnimation(plots, interval=100, repeat_delay=500)\n# ani.save('/tmp/animation.mp4')\nani\n\n\n  \n  Your browser does not support the video tag.\n\n\n\nThe final image of the spiral\n\n# Gallery Plot\n\nplot(kmax)\n\n\n\n\n\n\n\n\n\nSource: for animation in the notebook"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "plotnine {{< var version >}}",
    "section": "",
    "text": "From ad-hoc plots to publication-ready figures.\n                \n                \n                    Turn your data into beautiful visualizations using the grammar of graphics.\n                \n            \n            \n                \n            \n        \n\n        \n            \n                 Get started\n            \n            \n                 API reference\n            \n        \n    \n\n\n\n\n\n\n\n\n\n    \n        \n            \n\n                \n                \n                    \n                    \n                    \n                    \n                    \n                    \n                \n                \n\n                \n                    \n                    \n                    \n                    \n                    \n                    \n                \n\n                \n                    \n                    \n                        \n                            \n                                \n                            \n                        \n                        \n                        \n                        \n                            \n                                \n                            \n                        \n                    \n                    \n                    \n                    \n                        \n                            \n                                \n                            \n                        \n                        \n                        \n                        \n                            \n                                \n                            \n                        \n                    \n                    \n                    \n                    \n                        \n                            \n                                \n                            \n                        \n                        \n                        \n                        \n                            \n                                \n                            \n                        \n                    \n                    \n                    \n                    \n                        \n                            \n                                \n                            \n                        \n                        \n                        \n                        \n                            \n                                \n                            \n                        \n                    \n                    \n                    \n                    \n                        \n                            \n                                \n                            \n                        \n                        \n                        \n                        \n                            \n                                \n                            \n                        \n                    \n                    \n                    \n                    \n                        \n                            \n                                \n                            \n                        \n                        \n                        \n                        \n                            \n                                \n                            \n                        \n                    \n                    \n                    \n                    \n                        \n                            \n                                \n                            \n                        \n                        \n                        \n                        \n                            \n                                \n                            \n                        \n                    \n                    \n                    \n                    \n                        \n                            \n                                \n                            \n                        \n                        \n                        \n                        \n                            \n                                \n                            \n                        \n                    \n                    \n                    \n                    \n                        \n                            \n                                \n                            \n                        \n                        \n                        \n                        \n                            \n                                \n                            \n                        \n                    \n                    \n                    \n                    \n                        \n                            \n                                \n                            \n                        \n                        \n                        \n                        \n                            \n                                \n                            \n                        \n                    \n                    \n                    \n                    \n                        \n                            \n                                \n                            \n                        \n                        \n                        \n                        \n                            \n                                \n                            \n                        \n                    \n                    \n                    \n                    \n                        \n                            \n                                \n                            \n                        \n                        \n                        \n                        \n                            \n                                \n                            \n                        \n                    \n                    \n                    \n                    \n                        \n                            \n                                \n                            \n                        \n                        \n                        \n                        \n                            \n                                \n                            \n                        \n                    \n                    \n                    \n                    \n                        \n                            \n                                \n                            \n                        \n                        \n                        \n                        \n                            \n                                \n                            \n                        \n                    \n                    \n                    \n                    \n                        \n                            \n                                \n                            \n                        \n                        \n                        \n                        \n                            \n                                \n                            \n                        \n                    \n                    \n                    \n                    \n                        \n                            \n                                \n                            \n                        \n                        \n                        \n                        \n                            \n                                \n                            \n                        \n                    \n                    \n                    \n                    \n                        \n                            \n                                \n                            \n                        \n                        \n                        \n                        \n                            \n                                \n                            \n                        \n                    \n                    \n                    \n                    \n                        \n                            \n                                \n                            \n                        \n                        \n                        \n                        \n                            \n                                \n                            \n                        \n                    \n                    \n                    \n                \n\n                \n                    \n                    \n                    \n                    \n                    \n                    \n                \n\n                \n                \n                    \n                    \n                    \n                    \n                    \n                    \n                \n                \n            \n            \n               \n            \n        \n    \n\n\n\n\n\n    \n\n        \n    \n        \n            \n                \n                 A grammar of graphics for Python\n            \n            \n                Plotnine is a data visualization package for Python based on the grammar of graphics, a coherent system for describing and building graphs. The syntax is similar to ggplot2, a widely successful R package.Let’s explore Plotnine’s features and walk through a typical workflow by visualizing Anscombe’s Quartet—four small datasets with different distributions but nearly identical descriptive statistics. They’re perhaps the best argument for visualizing data. You can see the final result belowon the right.\n            \n            \n            \n        \n        \n            \n                \n                    \n                \n                \n            \n\n        \n    \n    \n\n        \n    \n        \n            \n                \n                 Get started quickly\n            \n            \n                With Plotnine you can create ad-hoc plots with just a single line of code.\n            \n            \n            \n                \n                from plotnine import * \nfrom plotnine.data import anscombes_quartet \n\nggplot(anscombes_quartet, aes(x=\"x\", y=\"y\")) + geom_point()\n\n\n            \n            \n            \n            \n                Our data contains two continuous variables, so let’s start with a basic scatter plot.It doesn’t make much sense just yet; we need a way to distinguish between the four datasets.\n            \n            \n        \n        \n            \n                \n                    \n                \n                \n                \n                    \n                \n                \n            \n\n        \n    \n    \n\n        \n    \n        \n            \n                \n                 Sensible defaults\n            \n            \n                Legends, labels, breaks, color palettes. Many elements are added automatically based on the data.\n            \n            \n            \n                \n                (\n    ggplot(anscombes_quartet, aes(\"x\", \"y\", color=\"dataset\"))\n    + geom_point()\n)\n\n\n            \n            \n            \n            \n                By coloring each point according to the dataset it belongs to, the plot automatically gets a legend. The colors are chosen automatically as well. But don’t worry, as we’ll see later, everything can be adjusted.It’s still rather messy, so let’s try a different approach.\n            \n            \n        \n        \n            \n                \n                    \n                \n                \n                \n                    \n                \n                \n            \n\n        \n    \n    \n\n        \n    \n        \n            \n                \n                 Subset declaratively\n            \n            \n                Any data visualization can be repeated across multiple panels without writing a for loop.\n            \n            \n            \n                \n                (\n    ggplot(anscombes_quartet, aes(\"x\", \"y\", color=\"dataset\"))\n    + geom_point()\n    + facet_wrap(\"dataset\")\n)\n\n\n            \n            \n            \n            \n                That’s better. The panels make the use of color redundant, so that’s something we need to fix.\n            \n            \n        \n        \n            \n                \n                    \n                \n                \n                \n                    \n                \n                \n            \n\n        \n    \n    \n\n        \n    \n        \n            \n                \n                 Visualizations have layers\n            \n            \n                The data and the mapping of columns are inherited, but can be changed per layer.\n            \n            \n            \n                \n                (\n    ggplot(anscombes_quartet, aes(\"x\", \"y\", color=\"dataset\"))\n    + geom_point()\n    + geom_smooth(method=\"lm\", se=False, fullrange=True)\n    + facet_wrap(\"dataset\")\n)\n\n\n            \n            \n            \n            \n                These scatter plots with trend lines clearly supports Anscombe’s point: that datasets with different distributions can have the same descriptive statistics.When you’re doing exploratory data analysis, this plot might be good enough. But when you want to publish this, you may want to customize it further.\n            \n            \n        \n        \n            \n                \n                    \n                \n                \n                \n                    \n                \n                \n            \n\n        \n    \n    \n\n        \n    \n        \n            \n                \n                 Override any default\n            \n            \n                Anything that you see, can be adjusted.\n            \n            \n            \n                \n                (\n    ggplot(anscombes_quartet, aes(\"x\", \"y\"))\n    + geom_point(color=\"sienna\", fill=\"darkorange\", size=3)\n    + geom_smooth(method=\"lm\", se=False, fullrange=True,\n                  color=\"steelblue\", size=1)\n    + facet_wrap(\"dataset\")\n    + scale_y_continuous(breaks=(4, 8, 12))\n    + coord_fixed(xlim=(3, 22), ylim=(2, 14))\n    + labs(title=\"Anscombe’s Quartet\")\n)\n\n\n            \n            \n            \n            \n                Here we change the sizes and colors, improve the breaks, and add a title.\n            \n            \n        \n        \n            \n                \n                    \n                \n                \n                \n                    \n                \n                \n            \n\n        \n    \n    \n\n        \n    \n        \n            \n                \n                 Plotnine goes to eleven\n            \n            \n                Finally, customize the theme to match your personal style or your organization’s brand.\n            \n            \n            \n                \n                (\n    ggplot(anscombes_quartet, aes(\"x\", \"y\"))\n    + geom_point(color=\"sienna\", fill=\"orange\", size=3)\n    + geom_smooth(method=\"lm\", se=False, fullrange=True,\n                  color=\"steelblue\", size=1)\n    + facet_wrap(\"dataset\")\n    + labs(title=\"Anscombe’s Quartet\")\n    + scale_y_continuous(breaks=(4, 8, 12))\n    + coord_fixed(xlim=(3, 22), ylim=(2, 14)) \n    + theme_tufte(base_family=\"Futura\", base_size=16)\n    + theme(\n        axis_line=element_line(color=\"#4d4d4d\"),\n        axis_ticks_major=element_line(color=\"#00000000\"),\n        axis_title=element_blank(),\n        panel_spacing=0.09,\n    )\n)\n\n\n            \n            \n            \n            \n                There you have it, we started with a single line of code, and incrementally improved and customized our data visualization.Curious how you can start creating these kinds of visualizations with your own data? In the next section we cover how to install Plotnine.\n            \n            \n        \n        \n            \n                \n                    \n                \n                \n            \n\n        \n    \n    \n\n\n\n\n    \n        \n            \n            \n            \n                Next: Installation \n            \n            \n            \n        \n    \n\n\n\n    \n        \n            Plotnine\n            \n                Guide\n                Reference\n                Gallery\n                Blog\n                GitHub\n            \n        \n        \n            \n                By"
  },
  {
    "objectID": "guide/themes-custom.html",
    "href": "guide/themes-custom.html",
    "title": "Custom themes",
    "section": "",
    "text": "custom themes\n\naxis\n\narea: title, text, ticks, minor.ticks\nsub-area: length\nloc: x[.top, bottom, left, right]\n\nlegend\n\narea: spacing, key, ticks, axis, text, title, position, box\nbig attr: background, margin, frame, direction, byrow, location\nsub attr:\n\nx, y\nsize, height, width\ntop, bottom, right, left, inside\njust, margin, background, spacing\n\n\npanel\n\narea: spacing, grid\nattrs: background, border, ontop\n\nplot\n\narea: title, subtitle, caption, tag\nattrs: background, position, location\n\nstrip\n\narea: background, text\nattrs:\n\nx, y\nbottom, top\nleft, right\nswitch.pad.grid\nswitch.pad.wrap\n\n\ncomplete, validate"
  },
  {
    "objectID": "guide/shortcuts.html",
    "href": "guide/shortcuts.html",
    "title": "Shortcut functions",
    "section": "",
    "text": "from plotnine import *\nfrom plotnine.data import mpg"
  },
  {
    "objectID": "guide/shortcuts.html#labs-for-titles-scale-names",
    "href": "guide/shortcuts.html#labs-for-titles-scale-names",
    "title": "Shortcut functions",
    "section": "labs() for titles, scale names",
    "text": "labs() for titles, scale names\n\n(\n    ggplot(mpg, aes(\"displ\", \"hwy\", color=\"class\"))\n    + geom_point()\n    + scale_x_continuous(name=\"Engine displacement (litres)\")\n    + scale_y_continuous(name=\"Highway miles per gallon\")\n    + scale_color_discrete(name=\"Car class\")\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(mpg, aes(\"displ\", \"hwy\", color=\"class\"))\n    + geom_point()\n    + labs(\n        title = \"Use labs() to quickly set labels\",\n        x = \"Engine displacement (litres)\",\n        y = \"Highway miles per gallon\",\n        color = \"Car class\"\n    )\n)"
  },
  {
    "objectID": "guide/shortcuts.html#lims-for-scale-limits",
    "href": "guide/shortcuts.html#lims-for-scale-limits",
    "title": "Shortcut functions",
    "section": "lims() for scale limits",
    "text": "lims() for scale limits"
  },
  {
    "objectID": "guide/shortcuts.html#expand_limits-for-data-based-limits",
    "href": "guide/shortcuts.html#expand_limits-for-data-based-limits",
    "title": "Shortcut functions",
    "section": "expand_limits() for data-based limits",
    "text": "expand_limits() for data-based limits\n\nref coord_cartesion, scale limits argument, xlim, ylim"
  },
  {
    "objectID": "guide/shortcuts.html#annotate-for-quick-plot-text",
    "href": "guide/shortcuts.html#annotate-for-quick-plot-text",
    "title": "Shortcut functions",
    "section": "annotate() for quick plot text",
    "text": "annotate() for quick plot text"
  },
  {
    "objectID": "guide/scale-misc.html",
    "href": "guide/scale-misc.html",
    "title": "Scale linetype, shapes, sizes",
    "section": "",
    "text": "linetype and shape tend to be simple\nsize supports a range of scale types\nrefer to aesthetics specification"
  },
  {
    "objectID": "guide/scale-misc.html#linetype-specifying-values",
    "href": "guide/scale-misc.html#linetype-specifying-values",
    "title": "Scale linetype, shapes, sizes",
    "section": "Linetype: specifying values",
    "text": "Linetype: specifying values\n\nimport pandas as pd\n\nfrom plotnine.data import penguins\nfrom plotnine import *\n\ndf = pd.DataFrame(\n    {\n        \"group\": [\"A\"] * 2 + [\"B\"] * 2,\n        \"condition\": [\"treatment\", \"control\"] * 2,\n        \"measure\": [3, 1, 2, 1],\n    }\n)\n\np = (\n    ggplot(df, aes(\"condition\", \"measure\", group=\"group\"))\n    + geom_line(aes(linetype=\"group\"), size=1)\n    + geom_point(aes(fill=\"group\", shape=\"group\"), size=4)\n)\n\np\np + scale_linetype_manual(breaks=[\"A\", \"B\"], values=[\"dotted\", \"dashdot\"])"
  },
  {
    "objectID": "guide/scale-misc.html#shape-specifying-values",
    "href": "guide/scale-misc.html#shape-specifying-values",
    "title": "Scale linetype, shapes, sizes",
    "section": "Shape: specifying values",
    "text": "Shape: specifying values\np = (\n    ggplot(df, aes(\"condition\", \"measure\", group=\"group\"))\n    + geom_line(aes(linetype=\"group\"), size=1)\n    + geom_point(aes(fill=\"group\", shape=\"group\"), size=4)\n)\n\np\np + scale_shape_manual(breaks=[\"A\", \"B\"], values=[\"s\", \"o\"])"
  },
  {
    "objectID": "guide/scale-misc.html#size-choosing-a-style",
    "href": "guide/scale-misc.html#size-choosing-a-style",
    "title": "Scale linetype, shapes, sizes",
    "section": "Size: choosing a style",
    "text": "Size: choosing a style\np = ggplot(df, aes(\"condition\", \"measure\", group=\"group\", size=\"measure\")) + geom_point(\n    aes(size=\"measure\")\n)\n\np + scale_size_radius()\np + scale_size_area()"
  },
  {
    "objectID": "guide/position-adjustments.html",
    "href": "guide/position-adjustments.html",
    "title": "Position adjustments",
    "section": "",
    "text": "Position adjustments determine the placement of overlapping geoms. For example, they can jitter points by applying a small amount of noise, or dodge bars to put them side-by-side. Use the position= argument to geoms to specify adjustments.",
    "crumbs": [
      "Guide",
      "Basics",
      "Position adjustments"
    ]
  },
  {
    "objectID": "guide/position-adjustments.html#setup",
    "href": "guide/position-adjustments.html#setup",
    "title": "Position adjustments",
    "section": "Setup",
    "text": "Setup\n\nfrom plotnine import *\nfrom plotnine.data import diamonds",
    "crumbs": [
      "Guide",
      "Basics",
      "Position adjustments"
    ]
  },
  {
    "objectID": "guide/position-adjustments.html#jittering-points",
    "href": "guide/position-adjustments.html#jittering-points",
    "title": "Position adjustments",
    "section": "Jittering points",
    "text": "Jittering points\nUse position_jitter() to add a small amount of noise to the x- and y-axis for geoms like points. This enables viewers to see overlapping items on dense plots.\nThe plots below show points before and after applying jitter.\np = ggplot(diamonds.head(1000), aes(\"cut\", \"carat\", fill=\"clarity\"))\n\np + geom_point()\np + geom_point(position=position_jitter())",
    "crumbs": [
      "Guide",
      "Basics",
      "Position adjustments"
    ]
  },
  {
    "objectID": "guide/position-adjustments.html#stacking-filling-and-dodging-bars",
    "href": "guide/position-adjustments.html#stacking-filling-and-dodging-bars",
    "title": "Position adjustments",
    "section": "Stacking, filling, and dodging bars",
    "text": "Stacking, filling, and dodging bars\nBy default, geoms like geom_bar() stack bars on top of each other (position_stack()). Use position_fill() to make the stacked bars all together the same height (set at 1), and position_dodge() to move bars side-by-side.\nfrom plotnine.data import diamonds\n\np = ggplot(diamonds, aes(\"color\", fill=\"cut\")) + theme(legend_position=\"none\")\n\np + geom_bar(position=position_stack())  # default\np + geom_bar(position=position_fill())\np + geom_bar(position=position_dodge())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReversing order\nThe position_stack() and position_fill() functions supports a reverse argument. This reverses the order within stacked bars.\np = ggplot(diamonds, aes(\"color\", fill=\"cut\"))\n\np + geom_bar(position=position_fill())\np + geom_bar(position=position_fill(reverse=True))\n\n\n\n\n\n\n\n\n\n\n\n\nSpacing between dodged bars\nUse the width argument to position_dodge() to increase or decrease the spacing between dodged bars.\nimport pandas as pd\n\ndf = pd.DataFrame({\"x\": [1, 1, 2, 2], \"n\": [1, 2, 3, 4], \"fill\": [\"A\", \"B\"] * 2})\n\nggplot(df, aes(\"x\", \"n\", fill=\"fill\")) + geom_col(position=position_dodge(width=0.5))\n\n\n\n\n\n\n\nNotice that setting width=0.5 caused the bars to overlap. Setting width higher increases the distance between the center of the bars.\n\n\nLabelling bars\nIf you want to add a label to dodged bars, it’s often necessary to set the dodge width for both the bars and the text.\n\ndodge = position_dodge(width=0.6)\n(\n    ggplot(df, aes(\"x\", \"n\", fill=\"fill\", label=\"n\"))\n    + geom_col(position=dodge, width=0.5)\n    + geom_text(position=dodge)\n)\n\n\n\n\n\n\n\n\n\n\nJitterdodging\nIf you want to combine jittering and dodging, use position_jitterdodge().",
    "crumbs": [
      "Guide",
      "Basics",
      "Position adjustments"
    ]
  },
  {
    "objectID": "guide/position-adjustments.html#dodging-with-missing-bars",
    "href": "guide/position-adjustments.html#dodging-with-missing-bars",
    "title": "Position adjustments",
    "section": "Dodging with missing bars",
    "text": "Dodging with missing bars\nWhen dodging bars, if a bar is missing from the plot (e.g. due to missing data), it often shows up by making another bar especially wide.\n\nfrom plotnine.data import mpg\n\nggplot(mpg, aes(\"class\", fill=\"factor(cyl)\")) + geom_bar(position=position_dodge())\n\n\n\n\n\n\n\n\nNotice that 2seater on the left has only a single bar that’s as wide as car classes with 4 bars. This is because bars occupy the same amount of room within an x-axis grouping.\nIn order to preserve space within a grouping for missing bars, you can calculate counts yourself, and add explicit rows for missing combinations in the data.\n\ndf_crossed = mpg[[\"cyl\"]].merge(mpg[[\"class\"]], how=\"cross\")\n\n# count rows, then explicitly add 0 counts for missing combinations\nfull_counts = (\n    mpg.groupby([\"cyl\", \"class\"])\n    .size()\n    .reset_index(name=\"n\")\n    .merge(df_crossed, how=\"right\")\n    .fillna(0)\n)\n\n(\n    ggplot(\n        full_counts,\n        aes(\"class\", \"n\", color=\"factor(cyl)\", fill=\"factor(cyl)\"),\n    )\n    + geom_col(position=position_dodge())\n)\n\n\n\n\n\n\n\n\nNote that setting the color= aesthetic makes the bars with height 0 visible (by setting the color of the rectangle border).",
    "crumbs": [
      "Guide",
      "Basics",
      "Position adjustments"
    ]
  },
  {
    "objectID": "guide/position-adjustments.html#dodging-lines-and-points",
    "href": "guide/position-adjustments.html#dodging-lines-and-points",
    "title": "Position adjustments",
    "section": "Dodging lines and points",
    "text": "Dodging lines and points\nWhen dodging lines and points, the width= argument to position_dodge() is necessary.\n\ndf = pd.DataFrame(\n    {\n        \"group\": [\"A\"] * 2 + [\"B\"] * 2,\n        \"condition\": [\"treatment\", \"control\"] * 2,\n        \"measure\": [3, 1, 2, 1],\n    }\n)\n\n\ndodge = position_dodge(width=0.1)\n\n(\n    ggplot(df, aes(\"condition\", \"measure\", fill=\"group\", group=\"group\"))\n    + geom_line(position=dodge)\n    + geom_point(size=4, position=dodge)\n    + expand_limits(y=0)\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Position adjustments"
    ]
  },
  {
    "objectID": "guide/position-adjustments.html#nudge-a-fixed-amount",
    "href": "guide/position-adjustments.html#nudge-a-fixed-amount",
    "title": "Position adjustments",
    "section": "Nudge a fixed amount",
    "text": "Nudge a fixed amount\nUse position_nudge() to move points or text a fixed amount in the x- and y-directions.\n\nhighest_mpg = mpg[(mpg[\"hwy\"] == mpg[\"hwy\"].max()) & (mpg[\"cty\"] == mpg[\"cty\"].max())]\n\n(\n    ggplot(mpg, aes(\"cty\", \"hwy\"))\n    + geom_point()\n    + geom_text(\n        aes(label=\"model\"),\n        position=position_nudge(x=-1, y=-2),\n        data=highest_mpg,\n    )\n)\n\n\n\n\n\n\n\n\nNote however that geoms like geom_text() provide nudge_x and nudge_y arguments that are more convenient for nudging text.",
    "crumbs": [
      "Guide",
      "Basics",
      "Position adjustments"
    ]
  },
  {
    "objectID": "guide/operators.html",
    "href": "guide/operators.html",
    "title": "Operators: +, >>",
    "section": "",
    "text": "Plotnine overloads the + and &gt;&gt; operators to make it easier to compose and pass data to plots.\nfrom plotnine import *\nfrom plotnine.data import mpg",
    "crumbs": [
      "Guide",
      "Miscellaneous",
      "Operators: `+`, `>>`"
    ]
  },
  {
    "objectID": "guide/operators.html#the-operator",
    "href": "guide/operators.html#the-operator",
    "title": "Operators: +, >>",
    "section": "The + operator",
    "text": "The + operator\nUse + to add geoms, scales, and themes to a plot.\n(\n    ggplot(mpg, aes(\"displ\", \"hwy\"))\n    + geom_point(aes(fill=\"class\"))  # first geom\n    + theme_minimal()  # theme\n)",
    "crumbs": [
      "Guide",
      "Miscellaneous",
      "Operators: `+`, `>>`"
    ]
  },
  {
    "objectID": "guide/operators.html#the-operator-1",
    "href": "guide/operators.html#the-operator-1",
    "title": "Operators: +, >>",
    "section": "The >> operator",
    "text": "The &gt;&gt; operator\nUse the &gt;&gt; operator to pipe data into a plot.\n\n(\n    mpg\n    # piped into plot\n    &gt;&gt; ggplot(aes(\"displ\", \"hwy\", fill=\"class\")) + geom_point()\n)",
    "crumbs": [
      "Guide",
      "Miscellaneous",
      "Operators: `+`, `>>`"
    ]
  },
  {
    "objectID": "guide/operators.html#why-operators",
    "href": "guide/operators.html#why-operators",
    "title": "Operators: +, >>",
    "section": "Why operators?",
    "text": "Why operators?\n\nComposable and extendable\nOperators enable plot actions to use syntax that’s composable and extendable. This means two things:\n\ncomposable: you can add additional components like geoms to a plot.\nextendable: components defined in other libraries—like new kinds of geoms—can be added to a plot using the same + syntax.\n\nFor example, suppose you defined your own Plotnine theme, as shown below:\n\ndef my_theme(base_size=11):\n    return (\n        theme_grey(base_size=base_size)  # start with grey theme\n        + theme(axis_text_x=element_text(angle=90))  # customize x-axis\n    )\n\nYou can use this theme with the + operator, just like the built-in Plotnine themes:\n\n(\n    ggplot(mpg, aes(\"displ\", \"hwy\", fill=\"class\"))\n    + geom_point()\n    + my_theme(base_size=16)  # apply custom theme\n)\n\n\n\n\n\n\n\n\nNotice that the custom my_theme() component was added to the plot, in the same way anything else is (e.g. geom_point()).\n\n\nKeep method chains going\nThe &gt;&gt; operator allows you to keep method chains going, without needing to create intermediate variables. This is especially useful when using Polars DataFrames, where you often want to do small bits of data wrangling before piping into the plot.\n\nimport polars as pl\n\npl_mpg = pl.from_pandas(mpg)\n\n(\n    pl_mpg\n    #\n    # label high mpg cars\n    .with_columns(good_mpg=pl.col(\"hwy\") &gt; 30)\n    #\n    # remove compact cars\n    .filter(pl.col(\"class\") != \"compact\")\n    #\n    # pipe into plot\n    &gt;&gt; ggplot(aes(\"displ\", \"hwy\", fill=\"good_mpg\")) + geom_point()\n)",
    "crumbs": [
      "Guide",
      "Miscellaneous",
      "Operators: `+`, `>>`"
    ]
  },
  {
    "objectID": "guide/maps.html",
    "href": "guide/maps.html",
    "title": "Maps",
    "section": "",
    "text": "from plotnine import *\nimport geodatasets\nimport geopandas as gp\n\nchicago = gp.read_file(geodatasets.get_path(\"geoda.chicago_commpop\"))\ngroceries = gp.read_file(geodatasets.get_path(\"geoda.groceries\"))\n\n\n(\n    ggplot(chicago)\n    + geom_map() \n    + coord_fixed()\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(chicago, aes(fill=\"POP2010\"))\n    + geom_map() \n    + coord_fixed()\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(chicago, aes(fill=\"POP2010\"))\n    + geom_map()\n    #+ scale_fill_cmap('plasma')\n    #+ scale_fill_gradientn([\"green\", \"purple\", \"papayawhip\"])\n    #+ scale_fill_gradient(low=\"green\", high=\"blue\")\n    #+ scale_fill_gradient2()\n)\n# scale_fill_gradient\n# scale_fill_continuous\n\n\n\n\n\n\n\n\n\n(\n    ggplot(chicago)\n    + geom_map(fill=None)\n    #+ geom_map(fill=None)\n    + theme_void()\n    + coord_fixed()\n)\n\n\n\n\n\n\n\n\n\nMissing data\n\nimport numpy as np\n\nchi_missing = chicago.copy()\nchi_missing.loc[np.random.choice(chicago.index, 50), 'POP2010'] = np.nan\n\n(\n    ggplot(chi_missing, aes(fill=\"POP2010\"))\n    + geom_map()\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(chi_missing, aes(fill=\"POP2010\"))\n    + geom_map(color=\"none\")\n    + theme_void()\n    + scale_fill_continuous(na_value=\"lightgrey\")\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot()\n    + geom_map(data=chicago, fill=None)\n    + geom_map(data=groceries.to_crs(chicago.crs), color=\"green\")\n    + theme_void()\n    + coord_fixed()\n)",
    "crumbs": [
      "Guide",
      "Miscellaneous",
      "Maps"
    ]
  },
  {
    "objectID": "guide/introduction.html",
    "href": "guide/introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Plotnine is a Python package for data visualization, based on the grammar of graphics. It implements a wide range of plots—including barcharts, linegraphs, scatterplots, maps, and much more.\nThis guide goes from a basic overview of Plotnine code, to explaining each piece of its grammar in more detail. While getting started is quick, learning the full grammar takes time. But it’s worth it! The grammar of graphics shows how even plots that look very different share the same underlying structure.\nThe rest of this page provides brief instructions for installing and starting with Plotnine, followed by some example use cases.",
    "crumbs": [
      "Guide",
      "Introduction"
    ]
  },
  {
    "objectID": "guide/introduction.html#installing",
    "href": "guide/introduction.html#installing",
    "title": "Introduction",
    "section": "Installing",
    "text": "Installing\n\npipuvconda\n\n\n# simple install\npip install plotnine\n\n# with dependencies used in examples\npip install 'plotnine[extra]'\n\n\n# simple install\nuv add plotnine\n\n# with dependencies used in examples\nuv add 'plotnine[extra]'\n\n\n# simple install\nconda install -c conda-forge plotnine\n\n# with dependencies used in examples\nconda install -c conda-forge 'plotnine[extra]'",
    "crumbs": [
      "Guide",
      "Introduction"
    ]
  },
  {
    "objectID": "guide/introduction.html#quickstart",
    "href": "guide/introduction.html#quickstart",
    "title": "Introduction",
    "section": "Quickstart",
    "text": "Quickstart\n\nBasic plot\nPlotnine comes with over a dozen example datasets, in order to quickly illustrate a wide range of plots. For example, the Palmer’s Penguins dataset (plotnine.data.penguins) contains data on three different penguin species.\nThe scatterplot below shows the relationship between bill length and bill depth for each penguin species.\n\nfrom plotnine import ggplot, aes, geom_point, labs\nfrom plotnine.data import penguins\n\n(\n    ggplot(penguins, aes(\"bill_length_mm\", \"bill_depth_mm\", color=\"species\"))\n    + geom_point()\n)\n\n\n\n\n\n\n\n\n\n\nDataFrame support\nPlotnine supports both Pandas and Polars DataFrames. It also provides simple a &gt;&gt; operator to pipe data into a plot.\nThe example below shows a Polars DataFrame being filtered, then piped into a plot.\n\nimport polars as pl\n\npl_penguins = pl.from_pandas(penguins)\n\n(\n    # polars: subset rows  ----\n    pl_penguins.filter(pl.col(\"species\") == \"Adelie\")\n    #\n    # pipe to plotnine ----\n    &gt;&gt; ggplot(aes(\"bill_length_mm\", \"bill_depth_mm\", fill=\"species\"))\n    + geom_point()\n    + labs(title=\"Adelie penguins\")\n)\n\n\n\n\n\n\n\n\nNotice that the code above keeps the Polars filter code and plotting code together (inside the parentheses). This makes it easy to quickly create plots, without needing a bunch of intermediate variables.",
    "crumbs": [
      "Guide",
      "Introduction"
    ]
  },
  {
    "objectID": "guide/introduction.html#use-cases",
    "href": "guide/introduction.html#use-cases",
    "title": "Introduction",
    "section": "Use cases",
    "text": "Use cases\nSee the Plotnine gallery for more examples.\n\nPublication ready plots\n\n\nCode\nfrom plotnine import *\nfrom plotnine.data import anscombe_quartet\n\n(\n    ggplot(anscombe_quartet, aes(\"x\", \"y\"))\n    + geom_point(color=\"sienna\", fill=\"orange\", size=3)\n    + geom_smooth(method=\"lm\", se=False, fullrange=True, color=\"steelblue\", size=1)\n    + facet_wrap(\"dataset\")\n    + labs(title=\"Anscombe’s Quartet\")\n    + scale_y_continuous(breaks=(4, 8, 12))\n    + coord_fixed(xlim=(3, 22), ylim=(2, 14))\n    + theme_tufte(base_family=\"Futura\", base_size=16)\n    + theme(\n        axis_line=element_line(color=\"#4d4d4d\"),\n        axis_ticks_major=element_line(color=\"#00000000\"),\n        axis_title=element_blank(),\n        panel_spacing=0.09,\n    )\n)\n\n\n\n\n\n\n\n\n\n\n\nAnnotated charts\nThe plot below makes heavy use of annotation, in order to illustrate coal production over the past century. The chart is largely Plotnine code, with matplotlib for some of the fancier text annotations. Learn more on in this blog post by the author, Nicola Rennie.\n\n\n\nGeospatial plots\nSee maps page\n\n\nCode\nfrom plotnine import *\nimport geodatasets\nimport geopandas as gp\n\nchicago = gp.read_file(geodatasets.get_path(\"geoda.chicago_commpop\"))\n\n(\n    ggplot(chicago, aes(fill=\"POP2010\"))\n    + geom_map()\n    + coord_fixed()\n    + theme_minimal()\n    + labs(title=\"Chicago Population in 2010\")\n)\n\n\n\n\n\n\n\n\n\n\n\nGetting artsy\n\n\nCode\nimport polars as pl\nimport numpy as np\n\nfrom plotnine import *\nfrom mizani.palettes import brewer_pal, gradient_n_pal\n\nnp.random.seed(345678)\n\n# generate random areas for each group to fill per year ---------\n# Note that in the data the x-axis is called Year, and the\n# filled bands are called Group(s)\n\nopts = [0] * 100 + list(range(1, 31))\nvalues = []\nfor ii in range(30):\n    values.extend(np.random.choice(opts, 30, replace=False))\n\n\n# Put all the data together -------------------------------------\nyears = pl.DataFrame({\"Year\": list(range(30))})\ngroups = pl.DataFrame({\"Group\": [f\"grp_{ii}\" for ii in range(30)]})\n\ndf = (\n    years.join(groups, how=\"cross\")\n    .with_columns(Values=pl.Series(values))\n    .with_columns(prop=pl.col(\"Values\") / pl.col(\"Values\").sum().over(\"Year\"))\n)\n\ndf.write_csv(\"plot-data.csv\")\n\n# Generate color palette ----------------------------------------\n# this uses 12 colors interpolated to all 30 Groups\npal = brewer_pal(\"qual\", \"Paired\")\n\ncolors = pal(12)\nnp.random.shuffle(colors)\n\nall_colors = gradient_n_pal(colors)(np.linspace(0, 1, 30))\n\n\n# Plot ---------------------------------------------------------\n(\n    df\n    &gt;&gt; ggplot(aes(\"Year\", \"prop\", fill=\"Group\"))\n    + geom_area()\n    + scale_fill_manual(values=all_colors)\n    + theme(\n        axis_text=element_blank(),\n        line=element_blank(),\n        title=element_blank(),\n        legend_position=\"none\",\n        plot_margin=0,\n        panel_border=element_blank(),\n        panel_background=element_blank(),\n    )\n)",
    "crumbs": [
      "Guide",
      "Introduction"
    ]
  },
  {
    "objectID": "guide/introduction.html#next-steps",
    "href": "guide/introduction.html#next-steps",
    "title": "Introduction",
    "section": "Next steps",
    "text": "Next steps\nContinue to the Overview for a worked example breaking down each piece of Plotnine’s grammar of graphics.",
    "crumbs": [
      "Guide",
      "Introduction"
    ]
  },
  {
    "objectID": "guide/geometric-objects.html",
    "href": "guide/geometric-objects.html",
    "title": "Geometric objects",
    "section": "",
    "text": "Geometric objects (geoms) determine how to turn mapped data into visual elements–such as points, lines, or even boxplots. There are two kinds of geoms: individual and collective.",
    "crumbs": [
      "Guide",
      "Basics",
      "Geometric objects"
    ]
  },
  {
    "objectID": "guide/geometric-objects.html#setup",
    "href": "guide/geometric-objects.html#setup",
    "title": "Geometric objects",
    "section": "Setup",
    "text": "Setup\n\nfrom plotnine import *\nfrom plotnine.data import mpg",
    "crumbs": [
      "Guide",
      "Basics",
      "Geometric objects"
    ]
  },
  {
    "objectID": "guide/geometric-objects.html#basic-use",
    "href": "guide/geometric-objects.html#basic-use",
    "title": "Geometric objects",
    "section": "Basic use",
    "text": "Basic use\nGeom functions, like geom_point(), specify visual elements to draw on the plot. They’re rendered in the order they’re added to the plot.\nFor example, the plot below adds points will fill color corresponding to the class column, and then points with shape corresponding to the same column.\n(\n    ggplot(mpg, aes(\"displ\", \"hwy\"))\n    + geom_point(aes(fill=\"class\"), size=5)\n    + geom_point(aes(shape=\"class\"))\n)\n\n\n\n\n\n\n\nNotice that the legend includes a guide for both fill and shape, so it’s clear what each corresponds to in the chart.",
    "crumbs": [
      "Guide",
      "Basics",
      "Geometric objects"
    ]
  },
  {
    "objectID": "guide/geometric-objects.html#kinds-of-geoms",
    "href": "guide/geometric-objects.html#kinds-of-geoms",
    "title": "Geometric objects",
    "section": "Kinds of geoms",
    "text": "Kinds of geoms\nGeoms come in two varieties:\n\nIndividual geoms: draw each row of data independently on the chart.\nCollective geoms: draw based on groups of rows, or relationships between them.\n\nThis is shown below for points, boxplots, and lines.\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote that boxplots are collective because they draw the box based on all the data in a group. Lines are collective because they connect rows of data points.",
    "crumbs": [
      "Guide",
      "Basics",
      "Geometric objects"
    ]
  },
  {
    "objectID": "guide/geometric-objects.html#individual-points-bars-and-text",
    "href": "guide/geometric-objects.html#individual-points-bars-and-text",
    "title": "Geometric objects",
    "section": "Individual: points, bars, and text",
    "text": "Individual: points, bars, and text\nThis section illustrates individual geoms. These range from simple points, to text, to bars and rectangles.\n\nScatterplot with text\n\nhighest_mpg = mpg[(mpg[\"hwy\"] == mpg[\"hwy\"].max()) & (mpg[\"cty\"] == mpg[\"cty\"].max())]\n\n(\n    ggplot(mpg, aes(\"cty\", \"hwy\")) \n    + geom_point() \n    + geom_text(\n        aes(label=\"model\"),\n        nudge_y=-2,\n        nudge_x = -1,\n        data = highest_mpg\n    )\n)\n\n\n\n\n\n\n\n\n\n\nBarchart on counts\n\nttl_mpg_class = mpg.value_counts([\"class\", \"drv\"]).reset_index()\nttl_mpg_class.head(3)\n\n\n\n\n\n\n\n\nclass\ndrv\ncount\n\n\n\n\n0\nsuv\n4\n51\n\n\n1\nmidsize\nf\n38\n\n\n2\ncompact\nf\n35\n\n\n\n\n\n\n\n\nggplot(ttl_mpg_class, aes(\"class\", \"count\", fill = \"drv\")) + geom_col()\n\n\n\n\n\n\n\n\n\n\nRectangles\nUse geom_rect() to draw rectangles.\n\nimport pandas as pd\n\ndf_rect = pd.DataFrame(\n    {\n        \"xmin\": [1, 2, 3],\n        \"ymin\": [1, 2, 3],\n        \"xmax\": [2, 3, 4],\n        \"ymax\": [2, 3, 4],\n    }\n)\n\n(\n    ggplot(df_rect, aes(xmin=\"xmin\", ymin=\"ymin\", xmax=\"xmax\", ymax=\"ymax\"))\n    + geom_rect(fill=\"orange\")\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Geometric objects"
    ]
  },
  {
    "objectID": "guide/geometric-objects.html#collective-distributions",
    "href": "guide/geometric-objects.html#collective-distributions",
    "title": "Geometric objects",
    "section": "Collective: distributions",
    "text": "Collective: distributions\nCollective geoms like geom_boxplot() and geom_density() can communicate the general shape and distribution of data.\n\nBoxplots and violins\nUse geom_boxplot() and geom_violin() to create boxplots and violin plots, respectively.\n\nindx = mpg[\"class\"].isin([\"2seater\", \"compact\", \"midsize\"])\n\n\n(\n    ggplot(aes(\"class\", \"cty\"))\n    + geom_boxplot(data=mpg[indx], fill=\"orange\")\n    + geom_violin(data=mpg[~indx], fill=\"lightblue\")\n)\n\n\n\n\n\n\n\n\n\n\nHistograms and densities\np = ggplot(mpg, aes(\"cty\"))\np + geom_histogram()\np + geom_density(fill=\"lightblue\")\n\n\n\n\n\n\n\n\n\n\n\n\nSmoothing\n\n(\n    ggplot(mpg, aes(\"displ\", \"hwy\"))\n    + geom_point()\n    + geom_smooth(method=\"lm\", color=\"blue\", fill=\"orange\")\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Geometric objects"
    ]
  },
  {
    "objectID": "guide/geometric-objects.html#collective-lines-and-fills",
    "href": "guide/geometric-objects.html#collective-lines-and-fills",
    "title": "Geometric objects",
    "section": "Collective: lines and fills",
    "text": "Collective: lines and fills\nLines and fills are collective geoms because they connect or fill between data points.\nFor example, geom_line() connects points along the x-axis. This is especially useful when x is a time series.\n\nfrom plotnine import *\nfrom plotnine.data import huron\n\n(\n    ggplot(huron, aes(\"year\", \"level\"))\n    + geom_line()\n    + geom_point()\n)\n\n\n\n\n\n\n\n\nSimilarly, geom_ribbon() draws a ribbon along the x-axis, based on minimum and maximum values for the y-axis.\n\nfrom plotnine import *\nfrom plotnine.data import huron\n\n(\n    ggplot(huron, aes(\"year\", \"level\"))\n    + geom_ribbon(aes(ymax=\"level\"), ymin=0, fill=\"lightblue\")\n    + geom_point()\n)\n\n\n\n\n\n\n\n\n\ngeom_area(): a special case of geom_ribbon() that always sets ymin=0.\ngeom_path(): connects points with a line by connecting subsequent rows of data, rather than along the x-axis.",
    "crumbs": [
      "Guide",
      "Basics",
      "Geometric objects"
    ]
  },
  {
    "objectID": "guide/geometric-objects.html#position-for-placement-tweaks",
    "href": "guide/geometric-objects.html#position-for-placement-tweaks",
    "title": "Geometric objects",
    "section": "position= for placement tweaks",
    "text": "position= for placement tweaks\nUse the position= argument to geom functions to do things like apply a small amount of random jitter. This can be useful for avoiding overplotting, where elements cover each other. Position can also move stacked bars to be side-to-side, to make them easier to compare.\n\nJitter with random noise\nUse position_jitter() to apply a small amount of random noise on the x- and y-axis. For example, the plots below show the same data with and without jitter.\np = ggplot(mpg, aes(\"cty\", \"hwy\"))\n\np + geom_point(alpha=0.2)\np + geom_point(position=position_jitter())\n\n\n\n\n\n\n\n\n\n\nNotice that the first plot has points plotted on top of each other. It uses alpha=0.2 to make overlapping points more visible. The second plot uses jitter to spread points out.\n\n\nDodge to side-by-side\nUse position_fill() to make stacked bars all the same height (set at 1), and position_dodge() to move bars side-by-side.\nfrom plotnine.data import diamonds\n\np = ggplot(diamonds, aes(\"color\", fill=\"cut\")) + theme(legend_position=\"none\")\n\np + geom_bar()\np + geom_bar(position=position_fill())\np + geom_bar(position=position_dodge())\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotice that the middle plot (position fill) makes it easy to compare the proportion of each fill across groups, while the right plot (position dodge) makes it easy to compare individual bars.",
    "crumbs": [
      "Guide",
      "Basics",
      "Geometric objects"
    ]
  },
  {
    "objectID": "guide/geometric-objects.html#stat-for-statistical-calculations",
    "href": "guide/geometric-objects.html#stat-for-statistical-calculations",
    "title": "Geometric objects",
    "section": "stat= for statistical calculations",
    "text": "stat= for statistical calculations\nUse the stat= argument to geom functions to run calculations before plotting. For example, the plot below uses stat=\"summary\" with the fun_y= argument, to add a point for the mean of each group.\n\n(\n    ggplot(mpg, aes(\"trans\", \"cty\"))\n    + geom_point()\n    + geom_point(\n        color=\"red\",\n        size=3,\n        stat=\"summary\",\n        fun_y=lambda x: x.mean())\n)\n\n\n\n\n\n\n\n\nNote that in practice it’s often easier to just pass summarized data directly to a geom function. For example, the plot above could also be created with the following code.\n\nmean_mpg = mpg.groupby(\"trans\")[\"cty\"].mean().reset_index()\n\n(\n    ggplot(mpg, aes(\"trans\", \"cty\"))\n    + geom_point()\n    + geom_point(data=mean_mpg, color=\"red\", size=3)\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Geometric objects"
    ]
  },
  {
    "objectID": "guide/feature-coverage.html",
    "href": "guide/feature-coverage.html",
    "title": "Feature parity with ggplot2",
    "section": "",
    "text": "How to separate guides (e.g. linetype size and shape size?)\nShould people use scale_color_cmap or scale_color_continuous?"
  },
  {
    "objectID": "guide/feature-coverage.html#questions",
    "href": "guide/feature-coverage.html#questions",
    "title": "Feature parity with ggplot2",
    "section": "",
    "text": "How to separate guides (e.g. linetype size and shape size?)\nShould people use scale_color_cmap or scale_color_continuous?"
  },
  {
    "objectID": "guide/feature-coverage.html#missing",
    "href": "guide/feature-coverage.html#missing",
    "title": "Feature parity with ggplot2",
    "section": "Missing",
    "text": "Missing\n\ngeom_text:\n\nno manual hjust argument\nno fontweight, fontstyle mappings (fontweight is fontface in ggplot; TODO upgrade and check)\naes hjust, vjust don’t accept numbers (only strings like center, top, etc..)\n\ngeom_path no linewidth option (uses size)\nShape names not supported (see aes spec)\nNone for do nothing not always supported\n\nshape aesthetic\n\nNot all linetypes supported (and must be name)\n\nggplot’s dotdash is dashdot\n\ngeom_sf: would be geom_carto in plotnine. Handles crs conversions for you."
  },
  {
    "objectID": "guide/feature-coverage.html#differences",
    "href": "guide/feature-coverage.html#differences",
    "title": "Feature parity with ggplot2",
    "section": "Differences",
    "text": "Differences\nfrom plotnine import *\nfrom plotnine.data import huron\nggplot(huron, aes(\"year\", \"level\")) + geom_line(linetype=(0, (1, 5)),)"
  },
  {
    "objectID": "guide/feature-coverage.html#key-syntax-differences",
    "href": "guide/feature-coverage.html#key-syntax-differences",
    "title": "Feature parity with ggplot2",
    "section": "Key syntax differences",
    "text": "Key syntax differences\n\nreplace . with _\nfuns and fun_y, etc..?\nwhere clause\nuse quotes are mappings"
  },
  {
    "objectID": "guide/feature-coverage.html#mapping-differences",
    "href": "guide/feature-coverage.html#mapping-differences",
    "title": "Feature parity with ggplot2",
    "section": "Mapping differences",
    "text": "Mapping differences\n\nsans-serif vs sans, monospace vs mono"
  },
  {
    "objectID": "guide/export.html",
    "href": "guide/export.html",
    "title": "Save and display",
    "section": "",
    "text": "You will learn\n\n\n\n\nHow to display plots in Jupyter notebooks, Quarto documents, and the console.\nHow to save plots to different formats.\nHow to change plot size and resolution.\nHow to ensure fonts in SVGs are self-contained.",
    "crumbs": [
      "Guide",
      "Polishing",
      "Save and display"
    ]
  },
  {
    "objectID": "guide/export.html#setup",
    "href": "guide/export.html#setup",
    "title": "Save and display",
    "section": "Setup",
    "text": "Setup\n\nfrom plotnine import *\nfrom plotnine.data import penguins",
    "crumbs": [
      "Guide",
      "Polishing",
      "Save and display"
    ]
  },
  {
    "objectID": "guide/export.html#displaying-plots",
    "href": "guide/export.html#displaying-plots",
    "title": "Save and display",
    "section": "Displaying plots",
    "text": "Displaying plots\nBy default, plots in Jupyter and Quarto should be displayed automatically.\nFor example, this website is built with Quarto, but the code below should also cause a plot to appear in a Jupyter notebook.\n\np = (\n    ggplot(penguins, aes(\"bill_length_mm\", \"bill_depth_mm\", color=\"species\"))\n    + geom_point()\n    + labs(\n        title = \"Palmer Penguins Bill Depth vs Length\",\n        x = \"Bill length (mm)\",\n        y = \"Bill depth (mm)\",\n    )\n)\n\np\n\n\n\n\n\n\n\n\nIf you want to explicitly display a plot, use the .show() method.\n\np.show()\n\n\n\n\n\n\n\n\n\nCustomizing display\nSee the following documentation pages for customizing plot display:\n\nQuarto: documentation on computed figures and figure options page.\nJupyter notebooks: “Integrating your objects with IPython”.",
    "crumbs": [
      "Guide",
      "Polishing",
      "Save and display"
    ]
  },
  {
    "objectID": "guide/export.html#saving-plots",
    "href": "guide/export.html#saving-plots",
    "title": "Save and display",
    "section": "Saving plots",
    "text": "Saving plots\nUse the .save() method to save a plot to a file. It takes as its first argument the name of the file to save the plot to.\n\np.save(\"my_plot.png\")\n\nBy default, Plotnine tries to infer the file format from its name. For example, in the code above, Plotnine would save the plot in PNG format.",
    "crumbs": [
      "Guide",
      "Polishing",
      "Save and display"
    ]
  },
  {
    "objectID": "guide/export.html#setting-size-resolution-and-format",
    "href": "guide/export.html#setting-size-resolution-and-format",
    "title": "Save and display",
    "section": "Setting size, resolution, and format",
    "text": "Setting size, resolution, and format\nPlotnine supports customizing plot size, resolution, and format in three ways, in order of precedence:\n\n.save() method arguments.\ntheme() settings.\nplotnine.options.set_option() global options.\n\n\np = ggplot(penguins, aes(\"bill_length_mm\", \"bill_depth_mm\", color=\"species\"))\n\n\n# Customize in save method ---\np.save(\"my_plot.png\", width=6, height=4, dpi=100)\n\n\n# Display or save with custom theme ---\nmy_theme = theme(figure_size=(6, 4), dpi=100)\np + my_theme\n\n\n# Save using global option ---\nfrom plotnine.options import set_option\n\nset_option(\"figure_size\", (6, 4))\n\np.save()",
    "crumbs": [
      "Guide",
      "Polishing",
      "Save and display"
    ]
  },
  {
    "objectID": "guide/export.html#handling-fonts-in-svg",
    "href": "guide/export.html#handling-fonts-in-svg",
    "title": "Save and display",
    "section": "Handling fonts in svg",
    "text": "Handling fonts in svg\nWhen plots using custom fonts are saved as an SVG, it may not display correctly on computers that do not have the fonts installed. Use the svg_usefonts argument in the theme() function to ensure that fonts are self-contained in the SVG file.\n\np + theme(svg_usefonts=False)",
    "crumbs": [
      "Guide",
      "Polishing",
      "Save and display"
    ]
  },
  {
    "objectID": "guide/case-study3.html",
    "href": "guide/case-study3.html",
    "title": "Case study 3",
    "section": "",
    "text": "Something similar to https://github.com/machow/coffee-sales-data, designed to show something compelling, that is a good intro to some facet of using plotnine."
  },
  {
    "objectID": "guide/case-study1.html",
    "href": "guide/case-study1.html",
    "title": "Case study 1",
    "section": "",
    "text": "Something similar to https://github.com/machow/coffee-sales-data, designed to show something compelling, that is a good intro to using plotnine."
  },
  {
    "objectID": "guide/aesthetic-specification.html",
    "href": "guide/aesthetic-specification.html",
    "title": "Aesthetic specifications",
    "section": "",
    "text": "This document is a translation of the ggplot2 aesthetic specification.\nimport pandas as pd\nfrom plotnine import *",
    "crumbs": [
      "Guide",
      "Miscellaneous",
      "Aesthetic specifications"
    ]
  },
  {
    "objectID": "guide/aesthetic-specification.html#color-and-fill",
    "href": "guide/aesthetic-specification.html#color-and-fill",
    "title": "Aesthetic specifications",
    "section": "Color and fill",
    "text": "Color and fill\nAlmost every geom has either color, fill, or both. Colors and fills can be specified in the following ways:\n\nA name, e.g., \"red\". These can be any color name or value supported by matplotlib. See the matplotlib css colors documentation and the plot below for a list of colors.\nAn rgb specification, with a string of the form \"#RRGGBB\" where each of the pairs RR, GG, BB consists of two hexadecimal digits giving a value in the range 00 to FF\nYou can optionally make the color transparent by using the form \"#RRGGBBAA\".\nA missing value (e.g. None, np.nan, pd.NA), for a completely transparent colour.\n\nHere’s an example of listing CSS color names matplotlib supports:\n\nfrom matplotlib import colors as mcolors\n\nn_colors = len(mcolors.CSS4_COLORS)\ncolors = pd.DataFrame(\n    {\n        \"name\": [name for name in mcolors.CSS4_COLORS.keys()],\n        \"x\": [(x // 30) * 1.5 for x in range(n_colors)],\n        \"y\": [-(x % 30) for x in range(n_colors)],\n    }\n)\n\n(\n    ggplot(colors, aes(\"x\", \"y\"))\n    + geom_point(aes(color=\"name\"), size=5)\n    + geom_text(aes(label=\"name\"), nudge_x=0.14, size=7.5, ha=\"left\")\n    + scale_color_identity(guide=None)\n    + expand_limits(x=7)\n    + theme_void()\n    + labs(title=\"CSS4 colors\")\n)",
    "crumbs": [
      "Guide",
      "Miscellaneous",
      "Aesthetic specifications"
    ]
  },
  {
    "objectID": "guide/aesthetic-specification.html#lines",
    "href": "guide/aesthetic-specification.html#lines",
    "title": "Aesthetic specifications",
    "section": "Lines",
    "text": "Lines\nAs well as colour, the appearance of a line is affected by linewidth, linetype, linejoin and lineend.\n\nLine type\nLine types can be specified with:\n\nA name: solid, dashed, dotted, dashdot, as shown below:\n\nlty = [\n    \"solid\",\n    \"dashed\",\n    \"dotted\",\n    \"dashdot\",\n    ]\nlinetypes = pd.DataFrame({\n  \"y\": list(range(len(lty))),\n  \"lty\": lty\n}) \n\n(ggplot(linetypes, aes(0, \"y\")) + \n  geom_segment(aes(xend = 5, yend = \"y\", linetype = \"lty\")) + \n  scale_linetype_identity(guide=None) + \n  geom_text(aes(label = \"lty\"), nudge_y = 0.2, ha=\"left\") +\n  scale_x_continuous(name=None, breaks = None) + \n  scale_y_reverse(name=None, breaks = None)\n\n)\n\n\n\n\n\n\n\n\nThe lengths of on/off stretches of line. This is done with a tuple of the form (offset, (on, off, ...)).\n\nlty = [\n    (0, (1, 1)),\n    (0, (1, 8)),\n    (0, (1, 15)),\n    (0, (8, 1)),\n    (0, (8, 8)),\n    (0, (8, 15)),\n    (0, (15, 1)),\n    (0, (15, 8)),\n    (0, (15, 15)),\n    (0, (2, 2, 6, 2)),\n]\nlinetypes = pd.DataFrame({\"y\": list(range(len(lty))), \"lty\": lty})\n\n(\n    ggplot(linetypes, aes(0, \"y\"))\n    + geom_segment(aes(xend=5, yend=\"y\", linetype=\"lty\"))\n    + scale_linetype_identity(guide=None)\n    +\n    geom_text(aes(label=\"lty\"), nudge_y=0.2, ha=\"left\")\n    + scale_x_continuous(name=None, breaks=None)\n    + scale_y_reverse(name=None, breaks=None)\n)\n\n\n\n\n\n\n\n\n\nThe three standard dash-dot line types described above correspond to:\n\ndashed: (0, (4, 4))\ndotted: (0, (1, 3)\ndashdot: (0, (1, 3, 4, 3))\n\n\n\nLinewidth\nDue to a historical error, the unit of linewidth is roughly 0.75 mm. Making it exactly 1 mm would change a very large number of existing plots, so we’re stuck with this mistake.\n\n\nLine end/join parameters\n\nThe appearance of the line end is controlled by the lineend paramter, and can be one of “round”, “butt” (the default), or “square”.\ndf = pd.DataFrame({\"x\": [1,2,3], \"y\": [4, 1, 9]})\nbase = ggplot(df, aes(\"x\", \"y\")) + xlim(0.5, 3.5) + ylim(0, 10)\n(\n  base + \n  geom_path(size = 10) + \n  geom_path(size = 1, colour = \"red\")\n)\n\n(\n  base + \n  geom_path(size = 10, lineend = \"round\") + \n  geom_path(size = 1, colour = \"red\")\n)\n\n(\n  base + \n  geom_path(size = 10, lineend = \"square\") + \n  geom_path(size = 1, colour = \"red\")\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe appearance of line joins is controlled by linejoin and can be one of “round” (the default), “mitre”, or “bevel”.\ndf = pd.DataFrame({\"x\": [1,2,3], \"y\": [9, 1, 9]})\nbase = ggplot(df, aes(\"x\", \"y\")) + ylim(0, 10)\n(\n  base + \n  geom_path(size = 10) + \n  geom_path(size = 1, colour = \"red\")\n)\n\n\n(\n  base + \n  geom_path(size = 10, linejoin = \"mitre\") + \n  geom_path(size = 1, colour = \"red\")\n)\n\n(\n  base + \n  geom_path(size = 10, linejoin = \"bevel\") + \n  geom_path(size = 1, colour = \"red\")\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMitre joins are automatically converted to bevel joins whenever the angle is too small (which would create a very long bevel). This is controlled by the linemitre parameter which specifies the maximum ratio between the line width and the length of the mitre.",
    "crumbs": [
      "Guide",
      "Miscellaneous",
      "Aesthetic specifications"
    ]
  },
  {
    "objectID": "guide/aesthetic-specification.html#polygons",
    "href": "guide/aesthetic-specification.html#polygons",
    "title": "Aesthetic specifications",
    "section": "Polygons",
    "text": "Polygons\nThe border of the polygon is controlled by the colour, linetype, and linewidth aesthetics as described above. The inside is controlled by fill.",
    "crumbs": [
      "Guide",
      "Miscellaneous",
      "Aesthetic specifications"
    ]
  },
  {
    "objectID": "guide/aesthetic-specification.html#point",
    "href": "guide/aesthetic-specification.html#point",
    "title": "Aesthetic specifications",
    "section": "Point",
    "text": "Point\n\nShape\nShapes take five types of values:\n\nA string for a point type, as specified in matplotlib.markers:\n\n\n\n\n\n\n\n\n\n\n\nNone to draw nothing.\n\n\n\nColor and fill\nWhile color applies to all shapes, fill only applies to shapes with red fill in the plot above. The size of the filled part is controlled by size, the size of the stroke is controlled by stroke. Each is measured in mm, and the total size of the point is the sum of the two. Note that the size is constant along the diagonal in the following figure.\n\nsizes = (\n  pd.DataFrame({\"size\": [0, 2, 4, 6]})\n  .merge(\n    pd.DataFrame({\"stroke\": [0, 2, 4, 6]}), how=\"cross\"\n  )\n)\n\n(\n  ggplot(sizes, aes(\"size\", \"stroke\", size = \"size\", stroke = \"stroke\")) + \n  geom_abline(slope = -1, intercept = 6, colour = \"white\", size = 6) + \n  geom_point(shape = \"o\", fill = \"red\") +\n  scale_size_identity(guide=None)\n)",
    "crumbs": [
      "Guide",
      "Miscellaneous",
      "Aesthetic specifications"
    ]
  },
  {
    "objectID": "guide/aesthetic-specification.html#text",
    "href": "guide/aesthetic-specification.html#text",
    "title": "Aesthetic specifications",
    "section": "Text",
    "text": "Text\n\nFont family\nThere are only three fonts that are guaranteed to work everywhere: “sans” (the default), “serif”, or “mono”:\n\ndf = pd.DataFrame(\n    {\"x\": 1, \"y\": [3, 2, 1], \"family\": [\"sans-serif\", \"serif\", \"monospace\"]}\n)\n\n(ggplot(df, aes(\"x\", \"y\")) + geom_text(aes(label=\"family\", family=\"family\"), size=20))\n\n\n\n\n\n\n\n\n\n\nFont weight\nCurrently, font weight doesn’t seem to work in plotnine (see this issue). But once it does, code like this should work:\n\ndf = pd.DataFrame(\n    {\"x\": [1, 2, 3, 4], \"fontweight\": [\"light\", \"normal\", \"bold\", \"heavy\"]}\n)\n\n(ggplot(df, aes(1, \"x\")) + geom_text(aes(label=\"fontweight\"), fontweight=\"bold\"))\n\n\n\n\n\n\n\n\n\n\nFont style\nCurrently font style doesn’t seem to work in plotnine (see this issue). But once it does, code like this should work:\n\ndf = pd.DataFrame({\"x\": [1, 2, 3], \"fontstyle\": [\"normal\", \"italic\", \"oblique\"]})\n\n(ggplot(df, aes(1, \"x\")) + geom_text(aes(label=\"fontstyle\", fontstyle=\"fontstyle\")))\n\n\n\n\n\n\n\n\n\n\nFont size\nThe size of text is measured in mm by default. This is unusual, but makes the size of text consistent with the size of lines and points. Typically you specify font size using points (or pt for short), where 1 pt = 0.35mm. In geom_text() and geom_label(), you can set size.unit = \"pt\" to use points instead of millimeters. In addition, ggplot2 provides a conversion factor as the variable .pt, so if you want to draw 12pt text, you can also set size = 12 / .pt.\n\n\nJustification\nHorizontal and vertical justification have the same parameterisation, either a string (“top”, “middle”, “bottom”, “left”, “center”, “right”) or a number between 0 and 1:\n\ntop = 1, middle = 0.5, bottom = 0\nleft = 0, center = 0.5, right = 1\n\n\njust = pd.DataFrame({\"hjust\": [\"center\", \"right\", \"left\"], \"x\": [0, 1, 2]}).merge(pd.DataFrame({\"vjust\": [\"center\", \"top\", \"bottom\"], \"y\": [0, 1, 2]}), how=\"cross\")\n\njust[\"label\"] = just[\"hjust\"].astype(str).str.cat(just[\"vjust\"].astype(str), sep=\", \")\n\n(\n  ggplot(just, aes(\"x\", \"y\")) +\n  geom_point(colour = \"grey\", size = 5) + \n  geom_text(aes(label = \"label\", hjust = \"hjust\", vjust = \"vjust\"))\n  + expand_limits(x = [-.5, 2.5], y = [-.5, 2.5])\n)\n\n\n\n\n\n\n\n\nNote that you can use numbers outside the range (0, 1), but it’s not recommended.",
    "crumbs": [
      "Guide",
      "Miscellaneous",
      "Aesthetic specifications"
    ]
  },
  {
    "objectID": "gallery/westeros.html",
    "href": "gallery/westeros.html",
    "title": "The Territories of Westeros",
    "section": "",
    "text": "import geopandas as gp\nimport geodatasets\nfrom plotnine import (\n    ggplot,\n    aes,\n    coord_fixed,\n    facet_wrap,\n    geom_map,\n    geom_text,\n    labs,\n    scale_fill_brewer,\n    scale_fill_continuous,\n    scale_x_continuous,\n    scale_y_continuous,\n    scale_size_continuous,\n    stage,\n    coord_cartesian,\n    element_line,\n    element_rect,\n    element_text,\n    theme_void,\n    theme,\n)\n\nLayering different features on a Map\nRead data and select features in Westeros only.\n\ncontinents = gp.read_file(\"data/lands-of-ice-and-fire/continents.shp\")\nislands = gp.read_file(\"data/lands-of-ice-and-fire/islands.shp\")\nlakes = gp.read_file(\"data/lands-of-ice-and-fire/lakes.shp\")\nrivers = gp.read_file(\"data/lands-of-ice-and-fire/rivers.shp\")\npolitical = gp.read_file(\"data/lands-of-ice-and-fire/political.shp\")\nwall = gp.read_file(\"data/lands-of-ice-and-fire/wall.shp\")\nroads = gp.read_file(\"data/lands-of-ice-and-fire/roads.shp\")\nlocations = gp.read_file(\"data/lands-of-ice-and-fire/locations.shp\")\n\nwesteros = continents.query('name==\"Westeros\"')\nislands = islands.query('continent==\"Westeros\" and name!=\"Summer Islands\"')\nlakes = lakes.query('continent==\"Westeros\"')\nrivers = rivers.query('continent==\"Westeros\"')\nroads = roads.query('continent==\"Westeros\"')\n\nwg = westeros.geometry[0]\nbool_idx = [wg.contains(g) for g in locations.geometry]\nwesteros_locations = locations[bool_idx]\ncities = westeros_locations[westeros_locations[\"type\"] == \"City\"].copy()\n\nCreate map by placing the features in layers in an order that limits obstraction.\nThe GeoDataFrame.geometry.centroid property has the center coordinates of polygons, we use these to place the labels of the political regions.\n\n# colors\nwater_color = \"#a3ccff\"\nwall_color = \"white\"\nroad_color = \"brown\"\n\n\n# Create label text by merging the territory name and\n# the claimant to the territory\ndef fmt_labels(names, claimants):\n    labels = []\n    for name, claimant in zip(names, claimants):\n        if name:\n            labels.append(\"{} ({})\".format(name, claimant))\n        else:\n            labels.append(\"({})\".format(claimant))\n    return labels\n\n\ndef calculate_center(df):\n    \"\"\"\n    Calculate the centre of a geometry\n\n    This method first converts to a planar crs, gets the centroid\n    then converts back to the original crs. This gives a more\n    accurate\n    \"\"\"\n    original_crs = df.crs\n    planar_crs = \"EPSG:3857\"\n    return df[\"geometry\"].to_crs(planar_crs).centroid.to_crs(original_crs)\n\n\npolitical[\"center\"] = calculate_center(political)\ncities[\"center\"] = calculate_center(cities)\n\n(\n    ggplot()\n    + geom_map(westeros, fill=None)\n    + geom_map(islands, fill=None)\n    + geom_map(political, aes(fill=\"ClaimedBy\"), color=None, show_legend=False)\n    + geom_map(wall, color=wall_color, size=2)\n    + geom_map(lakes, fill=water_color, color=None)\n    + geom_map(rivers, aes(size=\"size\"), color=water_color, show_legend=False)\n    + geom_map(roads, aes(size=\"size\"), color=road_color, alpha=0.5, show_legend=False)\n    + geom_map(cities, size=1)\n    + geom_text(\n        political,\n        aes(\"center.x\", \"center.y\", label=\"fmt_labels(name, ClaimedBy)\"),\n        size=8,\n        fontweight=\"bold\",\n    )\n    + geom_text(\n        cities,\n        aes(\"center.x\", \"center.y\", label=\"name\"),\n        size=8,\n        ha=\"left\",\n        nudge_x=0.20,\n    )\n    + labs(title=\"The Political Territories of Westeros\")\n    + scale_fill_brewer(type=\"qual\", palette=8)\n    + scale_x_continuous(expand=(0, 0, 0, 1))\n    + scale_y_continuous(expand=(0, 1, 0, 0))\n    + scale_size_continuous(range=(0.4, 1))\n    + coord_cartesian()\n    + theme_void()\n    + theme(figure_size=(8, 12), panel_background=element_rect(fill=water_color))\n)\n\n\n\n\n\n\n\n\nCredit: cadaei of the cartographersguild website forum."
  },
  {
    "objectID": "gallery/using-letters-as-shapes.html",
    "href": "gallery/using-letters-as-shapes.html",
    "title": "Using Letters As Shapes",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    scale_shape_manual,\n)\nfrom plotnine.data import mtcars\n\nYou can create shape symbols using \\(\\TeX\\). For example\n\nmixed_shapes = (\n    r\"$\\mathrm{A}$\",\n    r\"$\\mathrm{B}$\",\n    r\"$\\mathrm{C}$\",\n    r\"$\\mathrm{D}$\",\n)\n\n\n(\n    ggplot(mtcars, aes(\"wt\", \"mpg\", shape=\"factor(gear)\", colour=\"factor(gear)\"))\n    + geom_point(size=6)\n    + scale_shape_manual(values=mixed_shapes)\n)\n\n\n\n\n\n\n\n\nSee matplotlib documentation for more."
  },
  {
    "objectID": "gallery/stage.html",
    "href": "gallery/stage.html",
    "title": "Stacked Bar Chart",
    "section": "",
    "text": "%load_ext autoreload\n%autoreload 2\n%aimport plotnine\n\nimport pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    after_stat,\n    stage,\n    geom_bar,\n    geom_text,\n    geom_bin_2d,\n    stat_bin_2d,\n)\ndf = pd.DataFrame({\n    \"var1\": list(\"abbcccddddeeeee\"),\n    \"cat\": list(\"RSRSRSRRRSRSSRS\")\n})\n\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar()\n)\nAdd the corresponding count on top of each bar.\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar()\n    + geom_text(aes(label=after_stat(\"count\")), stat=\"count\")\n)\nAdjust the y position so that the counts do not overlap the bars.\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"count\"), y=stage(after_stat=\"count\", after_scale=\"y+.1\")),\n        stat=\"count\",\n    )\n)\nNote that this will work even nicely for stacked bars where adjustig the position with nudge_y=0.1 would not.\n(\n    ggplot(df, aes(\"var1\", fill=\"cat\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"count\"), y=stage(after_stat=\"count\", after_scale=\"y+.1\")),\n        stat=\"count\",\n        position=\"stack\",\n    )\n)"
  },
  {
    "objectID": "gallery/stage.html#create-a-binned-2d-plot-with-counts",
    "href": "gallery/stage.html#create-a-binned-2d-plot-with-counts",
    "title": "Stacked Bar Chart",
    "section": "Create a binned 2d plot with counts",
    "text": "Create a binned 2d plot with counts\n\nnp.random.seed(123)\ndf = pd.DataFrame({\n    \"col_1\": np.random.rand(1000),\n    \"col_2\": np.random.rand(1000)\n})\n\n\n(\n    ggplot(df, aes(x=\"col_1\", y=\"col_2\"))\n    + geom_bin_2d(position=\"identity\", binwidth=0.1)\n)\n\n\n\n\n\n\n\n\nAdd counts to the bins. stat_bin_2d bins are specified using retangular minimum and maximum end-points for dimension; we use these values to compute the mid-points at which to place the counts.\nFirst x and y aesthetics are mapped to col_1 and col_2 variables, then after the statistic consumes them and creates xmin, xmax, ymin & ymax values for each bin along with associated count. After the statistic computation the x and y aesthetics do not exist, but we create meaningful values using the minimum and maximum end-points.\nNote that the binning parameters for the geom and stat combination must be the same. In this case it is the binwidth.\n\n(\n    ggplot(df, aes(x=\"col_1\", y=\"col_2\"))\n    + geom_bin_2d(position=\"identity\", binwidth=0.1)\n    + stat_bin_2d(\n        aes(\n            x=stage(start=\"col_1\", after_stat=\"(xmin+xmax)/2\"),\n            y=stage(start=\"col_2\", after_stat=\"(ymin+ymax)/2\"),\n            label=after_stat(\"count\"),\n        ),\n        binwidth=0.1,\n        geom=\"text\",\n        format_string=\"{:.0f}\",\n        size=10,\n    )\n)"
  },
  {
    "objectID": "gallery/shapes.html",
    "href": "gallery/shapes.html",
    "title": "Scatter Plot Shapes",
    "section": "",
    "text": "from plotnine import (\n    aes,\n    annotate,\n    coord_equal,\n    element_rect,\n    element_text,\n    facet_wrap,\n    geom_point,\n    geom_segment,\n    geom_text,\n    geom_tile,\n    ggplot,\n    lims,\n    scale_shape_identity,\n    theme,\n    theme_void,\n)\n\nimport polars as pl\nimport numpy as np\n\nList the shapes and prepare dataframe with what is required to display them.\n\nfilled_shapes = (\n    \"o\",  # circle\n    \"^\",  # triangle up\n    \"s\",  # square\n    \"D\",  # Diamond\n    \"v\",  # triangle down\n    \"*\",  # star\n    \"p\",  # pentagon\n    \"8\",  # octagon\n    \"&lt;\",  # triangle left\n    \"h\",  # hexagon1\n    \"&gt;\",  # triangle right\n    \"H\",  # hexagon1\n    \"d\",  # thin diamond\n)\n\nunfilled_shapes = (\n    \"+\",  # plus\n    \"x\",  # x\n    \".\",  # point\n    \"1\",  # tri_down\n    \"2\",  # tri_up\n    \"3\",  # tri_left\n    \"4\",  # tri_right\n    \",\",  # pixel\n    \"_\",  # hline\n    \"|\",  # vline\n    0,  # tickleft\n    1,  # tickright\n    2,  # tickup\n    3,  # tickdown\n    4,  # caretleft\n    5,  # caretright\n    6,  # caretup\n    7,  # caretdown\n)\n\nn1 = len(filled_shapes)\nn2 = len(unfilled_shapes)\nncols = 10\nshapes = filled_shapes + unfilled_shapes\n\ndf = pl.DataFrame({\n    \"x\": np.hstack([np.arange(n1) % ncols, np.arange(n2) % ncols]),\n    \"y\": 4 - 1.5 * np.hstack([np.arange(n1) // ncols, np.arange(n2) // ncols]),\n    \"shape\": pl.Series(shapes, dtype=object),\n    \"shape_kind\": np.repeat([\"Filled Shapes\", \"Unfilled Shapes\"], (n1, n2))\n})\n\ndf\n\n\nshape: (31, 4)\n\n\n\nx\ny\nshape\nshape_kind\n\n\ni64\nf64\nobject\nstr\n\n\n\n\n0\n4.0\no\n\"Filled Shapes\"\n\n\n1\n4.0\n^\n\"Filled Shapes\"\n\n\n2\n4.0\ns\n\"Filled Shapes\"\n\n\n3\n4.0\nD\n\"Filled Shapes\"\n\n\n4\n4.0\nv\n\"Filled Shapes\"\n\n\n…\n…\n…\n…\n\n\n3\n2.5\n3\n\"Unfilled Shapes\"\n\n\n4\n2.5\n4\n\"Unfilled Shapes\"\n\n\n5\n2.5\n5\n\"Unfilled Shapes\"\n\n\n6\n2.5\n6\n\"Unfilled Shapes\"\n\n\n7\n2.5\n7\n\"Unfilled Shapes\"\n\n\n\n\n\n\n\ndef double_quote_strings(series):\n    return [\n        '\"{}\"'.format(s) if isinstance(s, str) else \"{}\".format(s)\n        for s in series\n    ]\n\n(\n    ggplot(df, aes(\"x\", \"y\"))\n    \n    # Background\n    + geom_tile(aes(width=0.9, height=0.9), fill=\"#F8F8F8\")\n    \n    # Cross-grid to help see the centering of the shapes\n    + geom_segment(aes(x=\"x-0.45\", xend=\"x+0.45\", yend=\"y\"), color=\"Crimson\", alpha=0.05)\n    + geom_segment(aes(xend=\"x\", y=\"y-0.45\", yend=\"y+0.45\"), color=\"Crimson\", alpha=0.05)\n    \n    # The shape\n    + geom_point(aes(shape=\"shape\"), fill=\"#E5C8D6\", size=8)\n\n    # Specification value for the shape\n    + geom_text(\n        aes(y=\"y+.5\", label=\"double_quote_strings(shape)\"),\n        color=\"darkblue\",\n        va=\"bottom\",\n    )\n\n    # Separate the shapes by their kind\n    + facet_wrap(\"shape_kind\", ncol=1)\n\n    # Make things pretty\n    + lims(y=(2, 5))\n    + scale_shape_identity()\n    + coord_equal()\n    + theme_void()\n    + theme(\n        plot_background=element_rect(fill=\"white\"),\n        strip_text=element_text(size=12)\n    )\n)"
  },
  {
    "objectID": "gallery/ranked.html",
    "href": "gallery/ranked.html",
    "title": "Rank Plot",
    "section": "",
    "text": "# NOTE: This notebook uses the polars package\nimport numpy as np\n\nfrom plotnine import *\nimport polars as pl\nfrom polars import col\n\nComparing a group of ranked items at two different times\nRead the data.\nSource: World Bank - Infanct Mortality Rate (per 1,000 live births)b\n\ndata = pl.read_csv(\n    \"data/API_SP.DYN.IMRT.IN_DS2_en_csv_v2/API_SP.DYN.IMRT.IN_DS2_en_csv_v2.csv\",\n    skip_rows=4,\n    null_values=\"\",\n    truncate_ragged_lines=True,\n)\n\n# Columns as valid python variables\nyear_columns = {c: f\"y{c}\" for c in data.columns if c[:2] in {\"19\", \"20\"}}\ndata = data.rename(\n    {\"Country Name\": \"country\", \"Country Code\": \"code\", **year_columns}\n).drop([\"Indicator Name\", \"Indicator Code\"])\ndata.head()\n\n\nshape: (5, 60)\n\n\n\ncountry\ncode\ny1960\ny1961\ny1962\ny1963\ny1964\ny1965\ny1966\ny1967\ny1968\ny1969\ny1970\ny1971\ny1972\ny1973\ny1974\ny1975\ny1976\ny1977\ny1978\ny1979\ny1980\ny1981\ny1982\ny1983\ny1984\ny1985\ny1986\ny1987\ny1988\ny1989\ny1990\ny1991\ny1992\ny1993\ny1994\ny1995\ny1996\ny1997\ny1998\ny1999\ny2000\ny2001\ny2002\ny2003\ny2004\ny2005\ny2006\ny2007\ny2008\ny2009\ny2010\ny2011\ny2012\ny2013\ny2014\ny2015\ny2016\n\n\n\nstr\nstr\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nstr\nstr\n\n\n\n\n\"Aruba\"\n\"ABW\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n\n\n\"Afghanistan\"\n\"AFG\"\nnull\n240.5\n236.3\n232.3\n228.5\n224.6\n220.7\n217.0\n213.3\n209.8\n206.1\n202.2\n198.2\n194.3\n190.3\n186.6\n182.6\n178.7\n174.5\n170.4\n166.1\n161.8\n157.5\n153.2\n148.7\n144.5\n140.2\n135.7\n131.3\n126.8\n122.5\n118.3\n114.4\n110.9\n107.7\n105.0\n102.7\n100.7\n98.9\n97.2\n95.4\n93.4\n91.2\n89.0\n86.7\n84.4\n82.3\n80.4\n78.6\n76.8\n75.1\n73.4\n71.7\n69.9\n68.1\n66.3\nnull\nnull\n\n\n\"Angola\"\n\"AGO\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n138.3\n137.5\n136.8\n136.0\n135.3\n134.9\n134.4\n134.1\n133.8\n133.6\n133.5\n133.5\n133.5\n133.4\n133.2\n132.8\n132.3\n131.5\n130.6\n129.5\n128.3\n126.9\n125.5\n124.1\n122.8\n121.2\n119.4\n117.1\n114.7\n112.2\n109.6\n106.8\n104.1\n101.4\n98.8\n96.0\nnull\nnull\n\n\n\"Albania\"\n\"ALB\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n73.0\n68.4\n64.0\n59.9\n56.1\n52.4\n49.1\n45.9\n43.2\n40.8\n38.6\n36.7\n35.1\n33.7\n32.5\n31.4\n30.3\n29.1\n27.9\n26.8\n25.5\n24.4\n23.2\n22.1\n21.0\n20.0\n19.1\n18.3\n17.4\n16.7\n16.0\n15.4\n14.8\n14.3\n13.8\n13.3\n12.9\n12.5\nnull\nnull\n\n\n\"Andorra\"\n\"AND\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n7.5\n7.0\n6.5\n6.1\n5.6\n5.2\n5.0\n4.6\n4.3\n4.1\n3.9\n3.7\n3.5\n3.3\n3.2\n3.1\n2.9\n2.8\n2.7\n2.6\n2.5\n2.4\n2.3\n2.2\n2.1\n2.1\nnull\nnull\n\n\n\n\n\n\nThe data includes regional aggregates. To tell apart the regional aggregates we need the metadata. Every row in the data table has a corresponding row in the metadata table. Where the row has regional aggregate data, the Region column in the metadata table is NaN.\n\ndef ordered_categorical(s, categories=None):\n    \"\"\"\n    Create a categorical ordered according to the categories\n    \"\"\"\n    name = getattr(s, \"name\", \"\")\n    if categories is None:\n        return pl.Series(name, s).cast(pl.Categorical)\n\n    with pl.StringCache():\n        pl.Series(categories).cast(pl.Categorical)\n        return pl.Series(name, s).cast(pl.Categorical)\n\n\ncolumns = {\"Country Code\": \"code\", \"Region\": \"region\", \"IncomeGroup\": \"income_group\"}\n\nmetadata = (\n    pl.scan_csv(\n        \"data/API_SP.DYN.IMRT.IN_DS2_en_csv_v2/Metadata_Country_API_SP.DYN.IMRT.IN_DS2_en_csv_v2.csv\"\n    )\n    .rename(columns)\n    .select(list(columns.values()))\n    .filter(\n        # Drop the regional aggregate information\n        (col(\"region\") != \"\") & (col(\"income_group\") != \"\")\n    )\n    .collect()\n)\n\ncat_order = [\"High income\", \"Upper middle income\", \"Lower middle income\", \"Low income\"]\nmetadata = metadata.with_columns(\n    ordered_categorical(metadata[\"income_group\"], cat_order)\n)\n\nmetadata.head(10)\n\n\nshape: (10, 3)\n\n\n\ncode\nregion\nincome_group\n\n\nstr\nstr\ncat\n\n\n\n\n\"ABW\"\n\"Latin America & Caribbean\"\n\"High income\"\n\n\n\"AFG\"\n\"South Asia\"\n\"Low income\"\n\n\n\"AGO\"\n\"Sub-Saharan Africa\"\n\"Lower middle income\"\n\n\n\"ALB\"\n\"Europe & Central Asia\"\n\"Upper middle income\"\n\n\n\"AND\"\n\"Europe & Central Asia\"\n\"High income\"\n\n\n\"ARE\"\n\"Middle East & North Africa\"\n\"High income\"\n\n\n\"ARG\"\n\"Latin America & Caribbean\"\n\"Upper middle income\"\n\n\n\"ARM\"\n\"Europe & Central Asia\"\n\"Lower middle income\"\n\n\n\"ASM\"\n\"East Asia & Pacific\"\n\"Upper middle income\"\n\n\n\"ATG\"\n\"Latin America & Caribbean\"\n\"High income\"\n\n\n\n\n\n\nRemove the regional aggregates, to create a table with only country data\n\ncountry_data = data.join(metadata, on=\"code\")\ncountry_data.head()\n\n\nshape: (5, 62)\n\n\n\ncountry\ncode\ny1960\ny1961\ny1962\ny1963\ny1964\ny1965\ny1966\ny1967\ny1968\ny1969\ny1970\ny1971\ny1972\ny1973\ny1974\ny1975\ny1976\ny1977\ny1978\ny1979\ny1980\ny1981\ny1982\ny1983\ny1984\ny1985\ny1986\ny1987\ny1988\ny1989\ny1990\ny1991\ny1992\ny1993\ny1994\ny1995\ny1996\ny1997\ny1998\ny1999\ny2000\ny2001\ny2002\ny2003\ny2004\ny2005\ny2006\ny2007\ny2008\ny2009\ny2010\ny2011\ny2012\ny2013\ny2014\ny2015\ny2016\n\nregion\nincome_group\n\n\nstr\nstr\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nstr\nstr\nstr\ncat\n\n\n\n\n\"Aruba\"\n\"ABW\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n\"Latin America & Caribbean\"\n\"High income\"\n\n\n\"Afghanistan\"\n\"AFG\"\nnull\n240.5\n236.3\n232.3\n228.5\n224.6\n220.7\n217.0\n213.3\n209.8\n206.1\n202.2\n198.2\n194.3\n190.3\n186.6\n182.6\n178.7\n174.5\n170.4\n166.1\n161.8\n157.5\n153.2\n148.7\n144.5\n140.2\n135.7\n131.3\n126.8\n122.5\n118.3\n114.4\n110.9\n107.7\n105.0\n102.7\n100.7\n98.9\n97.2\n95.4\n93.4\n91.2\n89.0\n86.7\n84.4\n82.3\n80.4\n78.6\n76.8\n75.1\n73.4\n71.7\n69.9\n68.1\n66.3\nnull\nnull\n\"South Asia\"\n\"Low income\"\n\n\n\"Angola\"\n\"AGO\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n138.3\n137.5\n136.8\n136.0\n135.3\n134.9\n134.4\n134.1\n133.8\n133.6\n133.5\n133.5\n133.5\n133.4\n133.2\n132.8\n132.3\n131.5\n130.6\n129.5\n128.3\n126.9\n125.5\n124.1\n122.8\n121.2\n119.4\n117.1\n114.7\n112.2\n109.6\n106.8\n104.1\n101.4\n98.8\n96.0\nnull\nnull\n\"Sub-Saharan Africa\"\n\"Lower middle income\"\n\n\n\"Albania\"\n\"ALB\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n73.0\n68.4\n64.0\n59.9\n56.1\n52.4\n49.1\n45.9\n43.2\n40.8\n38.6\n36.7\n35.1\n33.7\n32.5\n31.4\n30.3\n29.1\n27.9\n26.8\n25.5\n24.4\n23.2\n22.1\n21.0\n20.0\n19.1\n18.3\n17.4\n16.7\n16.0\n15.4\n14.8\n14.3\n13.8\n13.3\n12.9\n12.5\nnull\nnull\n\"Europe & Central Asia\"\n\"Upper middle income\"\n\n\n\"Andorra\"\n\"AND\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n7.5\n7.0\n6.5\n6.1\n5.6\n5.2\n5.0\n4.6\n4.3\n4.1\n3.9\n3.7\n3.5\n3.3\n3.2\n3.1\n2.9\n2.8\n2.7\n2.6\n2.5\n2.4\n2.3\n2.2\n2.1\n2.1\nnull\nnull\n\"Europe & Central Asia\"\n\"High income\"\n\n\n\n\n\n\nWe are interested in the changes in rank between 1960 and 2015. To plot a reasonable sized graph, we randomly sample 35 countries.\n\nsampled_data = (\n    country_data.drop_nulls(subset=[\"y1960\", \"y2015\"])\n    .sample(n=35, seed=123)\n    .with_columns(\n        y1960_rank=col(\"y1960\").rank(method=\"ordinal\").cast(pl.Int64),\n        y2015_rank=col(\"y2015\").rank(method=\"ordinal\").cast(pl.Int64),\n    )\n    .sort(\"y2015_rank\", descending=True)\n)\n\nsampled_data.head()\n\n\nshape: (5, 64)\n\n\n\ncountry\ncode\ny1960\ny1961\ny1962\ny1963\ny1964\ny1965\ny1966\ny1967\ny1968\ny1969\ny1970\ny1971\ny1972\ny1973\ny1974\ny1975\ny1976\ny1977\ny1978\ny1979\ny1980\ny1981\ny1982\ny1983\ny1984\ny1985\ny1986\ny1987\ny1988\ny1989\ny1990\ny1991\ny1992\ny1993\ny1994\ny1995\ny1996\ny1997\ny1998\ny1999\ny2000\ny2001\ny2002\ny2003\ny2004\ny2005\ny2006\ny2007\ny2008\ny2009\ny2010\ny2011\ny2012\ny2013\ny2014\ny2015\ny2016\n\nregion\nincome_group\ny1960_rank\ny2015_rank\n\n\nstr\nstr\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nstr\nstr\nstr\ncat\ni64\ni64\n\n\n\n\n\"Sierra Leone\"\n\"SLE\"\n223.6\n220.5\n217.5\n214.2\n211.0\n207.6\n204.2\n200.8\n197.3\n194.1\n191.0\n188.0\n185.2\n182.6\n180.0\n177.5\n175.3\n173.2\n171.2\n169.2\n167.3\n165.6\n164.1\n162.8\n161.5\n160.4\n159.4\n158.3\n157.6\n157.0\n156.5\n156.1\n155.7\n155.2\n154.5\n153.4\n152.0\n150.1\n148.1\n145.8\n143.3\n140.5\n137.7\n134.6\n131.4\n128.1\n124.5\n120.5\n116.2\n111.7\n107.0\n102.3\n97.9\n93.8\n90.2\n87.1\nnull\nnull\n\"Sub-Saharan Africa\"\n\"Low income\"\n35\n35\n\n\n\"Cote d'Ivoire\"\n\"CIV\"\n208.4\n203.0\n197.7\n192.8\n188.0\n183.3\n178.7\n174.2\n169.9\n165.4\n161.0\n156.4\n151.3\n146.1\n140.7\n135.1\n129.7\n124.7\n120.2\n116.6\n113.7\n111.4\n109.5\n108.0\n106.9\n106.1\n105.5\n105.2\n104.9\n104.9\n104.9\n104.8\n104.7\n104.7\n104.6\n104.4\n104.0\n103.3\n102.3\n101.0\n99.5\n97.7\n95.7\n93.6\n91.4\n88.9\n86.7\n84.1\n81.3\n79.0\n76.9\n75.0\n72.8\n70.6\n68.5\n66.6\nnull\nnull\n\"Sub-Saharan Africa\"\n\"Lower middle income\"\n33\n34\n\n\n\"Benin\"\n\"BEN\"\n186.9\n183.9\n180.6\n177.1\n173.6\n170.2\n166.8\n164.0\n161.5\n159.2\n157.1\n154.9\n152.5\n149.8\n146.8\n143.5\n140.1\n136.7\n133.6\n130.9\n128.7\n126.6\n124.7\n122.8\n120.9\n118.9\n116.9\n114.8\n112.6\n110.4\n108.0\n105.6\n103.2\n100.9\n98.9\n97.2\n95.6\n94.2\n92.7\n91.1\n89.3\n87.4\n85.2\n83.0\n80.8\n78.8\n76.9\n75.2\n73.7\n72.3\n71.0\n69.8\n68.5\n67.2\n65.7\n64.2\nnull\nnull\n\"Sub-Saharan Africa\"\n\"Low income\"\n32\n33\n\n\n\"Burkina Faso\"\n\"BFA\"\n161.3\n159.4\n157.5\n155.8\n154.3\n153.0\n151.8\n150.9\n150.2\n149.7\n149.3\n148.5\n147.1\n144.6\n141.0\n136.6\n131.9\n127.4\n123.4\n120.2\n117.6\n115.6\n113.9\n112.4\n110.8\n109.0\n107.1\n105.3\n103.8\n102.9\n102.5\n102.3\n102.4\n102.4\n102.1\n101.4\n100.5\n99.4\n98.3\n97.3\n96.2\n95.0\n93.4\n91.4\n88.9\n86.0\n82.7\n79.2\n75.8\n72.5\n69.7\n67.3\n65.4\n63.7\n62.2\n60.9\nnull\nnull\n\"Sub-Saharan Africa\"\n\"Low income\"\n30\n32\n\n\n\"Ghana\"\n\"GHA\"\n125.1\n123.8\n122.7\n121.8\n121.2\n120.8\n120.7\n120.6\n120.6\n120.5\n120.1\n119.5\n118.2\n116.5\n114.2\n111.5\n108.7\n106.0\n103.8\n102.1\n100.9\n100.1\n99.3\n98.4\n96.8\n94.7\n92.1\n89.0\n85.8\n82.7\n79.8\n77.5\n75.6\n74.1\n73.0\n72.0\n71.0\n69.8\n68.4\n66.7\n64.9\n63.0\n61.2\n59.6\n58.1\n56.8\n55.6\n54.4\n53.1\n51.7\n50.2\n48.6\n47.0\n45.5\n44.2\n42.8\nnull\nnull\n\"Sub-Saharan Africa\"\n\"Lower middle income\"\n25\n31\n\n\n\n\n\n\nFirst graph\n\n(\n    ggplot(sampled_data)\n    + geom_text(aes(1, \"y1960_rank\", label=\"country\"), ha=\"right\", size=9)\n    + geom_text(aes(2, \"y2015_rank\", label=\"country\"), ha=\"left\", size=9)\n    + geom_point(aes(1, \"y1960_rank\", color=\"income_group\"), size=2.5)\n    + geom_point(aes(2, \"y2015_rank\", color=\"income_group\"), size=2.5)\n    + geom_segment(\n        aes(x=1, y=\"y1960_rank\", xend=2, yend=\"y2015_rank\", color=\"income_group\")\n    )\n    + scale_y_reverse()\n)\n\n\n\n\n\n\n\n\nIt has the form we want, but we need to tweak it.\n\n# Text colors\nblack1 = \"#252525\"\nblack2 = \"#222222\"\n\n\n(\n    ggplot(sampled_data)\n    # Slight modifications for the original lines,\n    # 1. Nudge the text to either sides of the points\n    # 2. Alter the color and alpha values\n    + geom_text(\n        aes(1, \"y1960_rank\", label=\"country\"),\n        nudge_x=-0.05,\n        ha=\"right\",\n        size=9,\n        color=black1,\n    )\n    + geom_text(\n        aes(2, \"y2015_rank\", label=\"country\"),\n        nudge_x=0.05,\n        ha=\"left\",\n        size=9,\n        color=black1,\n    )\n    + geom_point(aes(1, \"y1960_rank\", color=\"income_group\"), size=2.5, alpha=0.7)\n    + geom_point(aes(2, \"y2015_rank\", color=\"income_group\"), size=2.5, alpha=0.7)\n    + geom_segment(\n        aes(x=1, y=\"y1960_rank\", xend=2, yend=\"y2015_rank\", color=\"income_group\"),\n        alpha=0.7,\n    )\n    # Text Annotations\n    + annotate(\n        \"text\",\n        x=1,\n        y=0,\n        label=\"Rank in 1960\",\n        fontweight=\"bold\",\n        ha=\"right\",\n        size=10,\n        color=black2,\n    )\n    + annotate(\n        \"text\",\n        x=2,\n        y=0,\n        label=\"Rank in 2015\",\n        fontweight=\"bold\",\n        ha=\"left\",\n        size=10,\n        color=black2,\n    )\n    + annotate(\n        \"text\", x=1.5, y=0, label=\"Lines show change in rank\", size=9, color=black1\n    )\n    + annotate(\n        \"label\",\n        x=1.5,\n        y=3,\n        label=\"Lower infant\\ndeath rates\",\n        size=9,\n        color=black1,\n        label_size=0,\n        fontstyle=\"italic\",\n    )\n    + annotate(\n        \"label\",\n        x=1.5,\n        y=33,\n        label=\"Higher infant\\ndeath rates\",\n        size=9,\n        color=black1,\n        label_size=0,\n        fontstyle=\"italic\",\n    )\n    # Prevent country names from being chopped off\n    + lims(x=(0.35, 2.65))\n    + labs(color=\"Income Group\")\n    # Countries with lower rates on top\n    + scale_y_reverse()\n    # Change colors\n    + scale_color_brewer(type=\"qual\", palette=2)\n    # Removes all decorations\n    + theme_void()\n    # Changing the figure size prevents the country names from squishing up\n    + theme(figure_size=(8, 11))\n)"
  },
  {
    "objectID": "gallery/mondrian.html",
    "href": "gallery/mondrian.html",
    "title": "Mondrian",
    "section": "",
    "text": "import polars as pl\nimport numpy as np\nfrom plotnine import ggplot, aes, geom_rect, theme_minimal, scale_fill_manual, theme, element_blank\nfrom typing import List, Tuple\nfrom enum import Enum\n\nclass MondrianColour(Enum):\n    BLACK = \"#000000\"\n    YELLOW = \"#FDDE06\"\n    BLUE = \"#0300AD\"\n    RED = \"#E70503\"\n    WHITE = \"#ffffff\"\n\nclass Node:\n    def __init__(self, depth: int, x_range: Tuple[float, float], y_range: Tuple[float, float]):\n        self.depth = depth\n        self.x_range = x_range\n        self.y_range = y_range\n        self.left = None\n        self.right = None\n        self.split_value = None\n        self.is_vertical = np.random.choice([True, False])\n\ndef generate_tree(node: Node, max_depth: int, min_size: float, force_split: bool = False) -&gt; None:\n    width = node.x_range[1] - node.x_range[0]\n    height = node.y_range[1] - node.y_range[0]\n\n    if not force_split:\n        if node.depth &gt;= max_depth or (np.random.random() &lt; 0.1 and node.depth &gt; 1):\n            return\n\n        if width &lt; min_size and height &lt; min_size:\n            return\n\n    if node.is_vertical and width &gt;= min_size:\n        node.split_value = np.random.uniform(node.x_range[0] + min_size, node.x_range[1] - min_size)\n        node.left = Node(node.depth + 1, (node.x_range[0], node.split_value), node.y_range)\n        node.right = Node(node.depth + 1, (node.split_value, node.x_range[1]), node.y_range)\n    elif not node.is_vertical and height &gt;= min_size:\n        node.split_value = np.random.uniform(node.y_range[0] + min_size, node.y_range[1] - min_size)\n        node.left = Node(node.depth + 1, node.x_range, (node.y_range[0], node.split_value))\n        node.right = Node(node.depth + 1, node.x_range, (node.split_value, node.y_range[1]))\n    else:\n        return\n\n    generate_tree(node.left, max_depth, min_size)\n    generate_tree(node.right, max_depth, min_size)\n\ndef initial_splits(root: Node, min_size: float) -&gt; None:\n    # Vertical split\n    root.is_vertical = True\n    root.split_value = np.random.uniform(root.x_range[0] + min_size, root.x_range[1] - min_size)\n    root.left = Node(1, (root.x_range[0], root.split_value), root.y_range)\n    root.right = Node(1, (root.split_value, root.x_range[1]), root.y_range)\n\n    # Horizontal splits\n    root.left.is_vertical = False\n    root.left.split_value = np.random.uniform(root.left.y_range[0] + min_size, root.left.y_range[1] - min_size)\n    root.left.left = Node(2, root.left.x_range, (root.left.y_range[0], root.left.split_value))\n    root.left.right = Node(2, root.left.x_range, (root.left.split_value, root.left.y_range[1]))\n\n    root.right.is_vertical = False\n    root.right.split_value = np.random.uniform(root.right.y_range[0] + min_size, root.right.y_range[1] - min_size)\n    root.right.left = Node(2, root.right.x_range, (root.right.y_range[0], root.right.split_value))\n    root.right.right = Node(2, root.right.x_range, (root.right.split_value, root.right.y_range[1]))\n\ndef tree_to_rectangles(node: Node, rectangles: List[dict]) -&gt; None:\n    if node.left is None and node.right is None:\n        rectangles.append({\n            'xmin': node.x_range[0],\n            'xmax': node.x_range[1],\n            'ymin': node.y_range[0],\n            'ymax': node.y_range[1],\n            'depth': node.depth\n        })\n    else:\n        tree_to_rectangles(node.left, rectangles)\n        tree_to_rectangles(node.right, rectangles)\n\ndef draw(seed: int):\n    np.random.seed(seed)\n\n    root = Node(0, (0, 1), (0, 1))\n    min_size = 0.05\n    max_depth = 12\n\n    # Perform initial splits\n    initial_splits(root, min_size)\n\n    # Continue generating the tree\n    generate_tree(root.left.left, max_depth, min_size)\n    generate_tree(root.left.right, max_depth, min_size)\n    generate_tree(root.right.left, max_depth, min_size)\n    generate_tree(root.right.right, max_depth, min_size)\n\n    rectangles = []\n    tree_to_rectangles(root, rectangles)\n\n    colours = pl.Series(name=\"colour\",values=np.random.choice([colour.value for colour in MondrianColour], size= len(rectangles)))\n\n    df = pl.DataFrame(rectangles).with_columns(colours)\n\n    plot = (ggplot(df, aes(xmin='xmin', xmax='xmax', ymin='ymin', ymax='ymax', fill='colour'))\n            + geom_rect(color='black', size=2)\n            + scale_fill_manual(values=[colour.value for colour in MondrianColour])\n            + theme_minimal()\n            + theme(legend_position = \"none\",\n                    aspect_ratio=1,\n                    axis_text=element_blank(),\n                    axis_ticks=element_blank(),\n                    panel_grid=element_blank(),\n                    figure_size=(10,10))\n    )\n\n    return plot\n\ndraw(seed=42)"
  },
  {
    "objectID": "gallery/labs.html",
    "href": "gallery/labs.html",
    "title": "Text Outside Panel",
    "section": "",
    "text": "from plotnine import ggplot, aes, labs, geom_point, theme, theme_538, theme_set\nfrom plotnine.data import mtcars\n\ntheme_set(theme_538())\n\n\ncaption = \"\"\"\\\nThis graphic illustrates the inverse relationship between vehicle weight\nand fuel efficiency (MPG). It aims to highlight how heavier vehicles generally\nconsume more fuel, and how the complexity of an engine's cylinder count and\ntransmission system can affect its fuel economy.\n\"\"\"\n\nfrom plotnine import *\n(\n    ggplot(mtcars, aes(\"mpg\", \"wt\", colour=\"factor(cyl)\", size=\"gear\"))\n    + geom_point()\n    + labs(\n        x=\"Miles per Gallon\",\n        y=\"Weight\",\n        colour=\"Cylinders\",\n        size=\"Gears\",\n        title=\"Fuel Efficiency vs. Vehicle Weight\",\n        subtitle =\"Exploring Factors that Affect the Fuel Effeciency of a Car\",\n        caption=caption,\n    )\n\n    + theme(\n        # left justify the caption and have one line of space between it and\n        # the x-axis label\n        plot_caption=element_text(ha=\"left\", margin={\"t\": 1, \"units\": \"lines\"})\n    )\n    \n)"
  },
  {
    "objectID": "gallery/geom_violin.html",
    "href": "gallery/geom_violin.html",
    "title": "Violins, Boxes, Points & Lines",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nimport pandas.api.types as pdtypes\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    stage,\n    geom_violin,\n    geom_point,\n    geom_line,\n    geom_boxplot,\n    guides,\n    scale_fill_manual,\n    theme,\n    theme_classic,\n)\n\nComparing repeated measurements and their summaries\nSuppose you have two sets of related data and each point in the first set maps onto a point in the second set. e.g. they could represent a transition from one state to another for example two measurements of the height of pupils in different years.\nFor demonstration we shall generate data with a before measurement and an after measurement.\n\nnp.random.seed(123)\nn = 20\nmu = (1, 2.3)\nsigma = (1, 1.6)\n\nbefore = np.random.normal(loc=mu[0], scale=sigma[0], size=n)\nafter = np.random.normal(loc=mu[1], scale=sigma[1], size=n)\n\ndf = pd.DataFrame(\n    {\n        \"value\": np.hstack([before, after]),\n        \"when\": np.repeat([\"before\", \"after\"], n),\n        \"id\": np.hstack([range(n), range(n)]),\n    }\n)\n\ndf[\"when\"] = df[\"when\"].astype(pdtypes.CategoricalDtype(categories=[\"before\", \"after\"]))\ndf.head()\n\n\n\n\n\n\n\n\nvalue\nwhen\nid\n\n\n\n\n0\n-0.085631\nbefore\n0\n\n\n1\n1.997345\nbefore\n1\n\n\n2\n1.282978\nbefore\n2\n\n\n3\n-0.506295\nbefore\n3\n\n\n4\n0.421400\nbefore\n4\n\n\n\n\n\n\n\nA basic violin plot shows distributions of the two sets of data.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(df)\n)\n\n\n\n\n\n\n\n\nAdd the original data in form of points.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(df)\n    + geom_point()\n)\n\n\n\n\n\n\n\n\nThe violins are symmetrical about the vertical axis and half a violin has the same information as the full violin. We cut (style) the violins in half and choose to alternate with the left half for the first one and the right half for the second.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(df, style=\"left-right\")  # changed\n    + geom_point()\n)\n\n\n\n\n\n\n\n\nLink up the points to get a sense of how the data the moves.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(df, style=\"left-right\")  # changed\n    + geom_point()\n    + geom_line(aes(group=\"id\"))  # new\n)\n\n\n\n\n\n\n\n\nMake gap between the points and the violions. i.e. shift the violins outward and the points & lines inward. We used stage mapping to get it done. For example\nx=stage('when', after_scale='x+shift*alt_sign(x)')\nsays, map the xaesthetic to the ‘when’ column/variable and after the scale computed the x locations add a shift to them. The calculated x locations of a discrete scale are consecutive numbers 1, 2, 3, ..., so we use that move objects of adjacent groups in opposite directions i.e $(-1)^1, (-1)^2, (-1)^3 … = -1, 1, -1… $\n\n# How much to shift the violin, points and lines\n# 0.1 is 10% of the allocated space for the category\nshift = 0.1\n\n\ndef alt_sign(x):\n    \"Alternate +1/-1 if x is even/odd\"\n    return (-1) ** x\n\n\nm1 = aes(x=stage(\"when\", after_scale=\"x+shift*alt_sign(x)\"))  # shift outward\nm2 = aes(x=stage(\"when\", after_scale=\"x-shift*alt_sign(x)\"), group=\"id\")  # shift inward\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(m1, style=\"left-right\")  # changed\n    + geom_point(m2)  # changed\n    + geom_line(m2)  # changed\n)\n\n\n\n\n\n\n\n\nAdd a boxplot in the gap. The space between the flat edge of the violin and the center of the points is 2 * shift, so we can use the shift to control the width of the boxplot.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(m1, style=\"left-right\")\n    + geom_point(m2)\n    + geom_line(m2)\n    + geom_boxplot(width=shift)\n)\n\n\n\n\n\n\n\n\nFinall, style it up.\n\nlsize = 0.65\nfill_alpha = 0.7\n\n(\n    ggplot(df, aes(\"when\", \"value\", fill=\"when\"))\n    + geom_violin(m1, style=\"left-right\", alpha=fill_alpha, size=lsize)\n    + geom_point(m2, color=\"none\", alpha=fill_alpha, size=2)\n    + geom_line(m2, color=\"gray\", size=lsize, alpha=0.6)\n    + geom_boxplot(width=shift, alpha=fill_alpha, size=lsize)\n    + scale_fill_manual(values=[\"dodgerblue\", \"darkorange\"])\n    + guides(fill=False)  # Turn off the fill legend\n    + theme_classic()\n    + theme(figure_size=(8, 6))\n)\n\n\n\n\n\n\n\n\nCredit: This is example is motivated by the work of Jordy van Langen (@jorvlan) at https://github.com/jorvlan/open-visualizations."
  },
  {
    "objectID": "gallery/geom_segment.html",
    "href": "gallery/geom_segment.html",
    "title": "An Elaborate Range Plot",
    "section": "",
    "text": "# NOTE: This notebook uses the polars package\nimport numpy as np\n\nfrom plotnine import *\nimport polars as pl\nfrom polars import col\n\nComparing the point to point difference of many similar variables\nRead the data.\nSource: Pew Research Global Attitudes Spring 2015\n\n!head -n 20 \"data/survey-social-media.csv\"\n\nPSRAID,COUNTRY,Q145,Q146,Q70,Q74\n100000,Ethiopia,Female,35,No, \n100001,Ethiopia,Female,25,No, \n100002,Ethiopia,Male,40,Don’t know, \n100003,Ethiopia,Female,30,Don’t know, \n100004,Ethiopia,Male,22,No, \n100005,Ethiopia,Male,40,No, \n100006,Ethiopia,Female,20,No, \n100007,Ethiopia,Female,18,No,No\n100008,Ethiopia,Male,50,No, \n100009,Ethiopia,Male,35,No, \n100010,Ethiopia,Female,20,No, \n100011,Ethiopia,Female,30,Don’t know, \n100012,Ethiopia,Male,60,No, \n100013,Ethiopia,Male,18,No, \n100014,Ethiopia,Male,40,No, \n100015,Ethiopia,Male,28,Don’t know, \n100016,Ethiopia,Female,55,Don’t know, \n100017,Ethiopia,Male,30,Don’t know, \n100018,Ethiopia,Female,22,No, \n\n\n\ncolumns = dict(\n    COUNTRY=\"country\",\n    Q145=\"gender\",\n    Q146=\"age\",\n    Q70=\"use_internet\",\n    Q74=\"use_social_media\",\n)\n\ndata = (\n    pl.scan_csv(\n        \"data/survey-social-media.csv\",\n        dtypes=dict(Q146=pl.Utf8),\n    )\n    .rename(columns)\n    .select([\"country\", \"age\", \"use_social_media\"])\n    .collect()\n)\n\ndata.sample(10, seed=123)\n\n\nshape: (10, 3)\n\n\n\ncountry\nage\nuse_social_media\n\n\nstr\nstr\nstr\n\n\n\n\n\"India\"\n\"23\"\n\" \"\n\n\n\"Pakistan\"\n\"18\"\n\" \"\n\n\n\"Peru\"\n\"39\"\n\"Yes\"\n\n\n\"Jordan\"\n\"56\"\n\" \"\n\n\n\"United Kingdom\"\n\"35\"\n\"Yes\"\n\n\n\"Chile\"\n\"24\"\n\"Yes\"\n\n\n\"Israel\"\n\"32\"\n\"No\"\n\n\n\"Pakistan\"\n\"39\"\n\"No\"\n\n\n\"Chile\"\n\"26\"\n\"Yes\"\n\n\n\"Nigeria\"\n\"43\"\n\"Yes\"\n\n\n\n\n\n\nCreate age groups for users of social media\n\nyes_no = [\"Yes\", \"No\"]\nvalid_age_groups = [\"18-34\", \"35-49\", \"50+\"]\n\nrdata = (\n    data.with_columns(\n        age_group=pl.when(col(\"age\") &lt;= \"34\")\n        .then(pl.lit(\"18-34\"))\n        .when(col(\"age\") &lt;= \"49\")\n        .then(pl.lit(\"35-49\"))\n        .when(col(\"age\") &lt; \"98\")\n        .then(pl.lit(\"50+\"))\n        .otherwise(pl.lit(\"\")),\n        country_count=pl.count().over(\"country\"),\n    )\n    .filter(\n        col(\"age_group\").is_in(valid_age_groups) & col(\"use_social_media\").is_in(yes_no)\n    )\n    .group_by([\"country\", \"age_group\"])\n    .agg(\n        # social media use percentage\n        sm_use_percent=(col(\"use_social_media\") == \"Yes\").sum() * 100 / pl.count(),\n        # social media question response rate\n        smq_response_rate=col(\"use_social_media\").is_in(yes_no).sum()\n        * 100\n        / col(\"country_count\").first(),\n    )\n    .sort([\"country\", \"age_group\"])\n)\n\nrdata.head()\n\n\nshape: (5, 4)\n\n\n\ncountry\nage_group\nsm_use_percent\nsmq_response_rate\n\n\nstr\nstr\nf64\nf64\n\n\n\n\n\"Argentina\"\n\"18-34\"\n90.883191\n35.1\n\n\n\"Argentina\"\n\"35-49\"\n84.40367\n21.8\n\n\n\"Argentina\"\n\"50+\"\n67.333333\n15.0\n\n\n\"Australia\"\n\"18-34\"\n90.862944\n19.621514\n\n\n\"Australia\"\n\"35-49\"\n78.04878\n20.418327\n\n\n\n\n\n\nTop 14 countries by response rate to the social media question.\n\ndef col_format(name, fmt):\n    # Format useing python formating\n    # for more control over\n    return col(name).map_elements(lambda x: fmt.format(x=x))\n\n\ndef float_to_str_round(name):\n    return col_format(name, \"{x:.0f}\")\n\n\nn = 14\n\ntop = (\n    rdata.group_by(\"country\")\n    .agg(r=col(\"smq_response_rate\").sum())\n    .sort(\"r\", descending=True)\n    .head(n)\n)\ntop_countries = top[\"country\"]\n\nexpr = float_to_str_round(\"sm_use_percent\")\nexpr_pct = expr + \"%\"\n\npoint_data = rdata.filter(col(\"country\").is_in(top_countries)).with_columns(\n    col(\"country\").cast(pl.Categorical),\n    sm_use_percent_str=pl.when(col(\"country\") == \"France\")\n    .then(expr_pct)\n    .otherwise(expr),\n)\n\npoint_data.head()\n\n\nshape: (5, 5)\n\n\n\ncountry\nage_group\nsm_use_percent\nsmq_response_rate\nsm_use_percent_str\n\n\ncat\nstr\nf64\nf64\nstr\n\n\n\n\n\"Australia\"\n\"18-34\"\n90.862944\n19.621514\n\"91\"\n\n\n\"Australia\"\n\"35-49\"\n78.04878\n20.418327\n\"78\"\n\n\n\"Australia\"\n\"50+\"\n48.479087\n52.390438\n\"48\"\n\n\n\"Canada\"\n\"18-34\"\n92.063492\n25.099602\n\"92\"\n\n\n\"Canada\"\n\"35-49\"\n75.925926\n21.513944\n\"76\"\n\n\n\n\n\n\n\nsegment_data = (\n    point_data.group_by(\"country\")\n    .agg(\n        min=col(\"sm_use_percent\").min(),\n        max=col(\"sm_use_percent\").max(),\n    )\n    .with_columns(gap=(col(\"max\") - col(\"min\")))\n    .sort(\n        \"gap\",\n    )\n    .with_columns(\n        min_str=float_to_str_round(\"min\"),\n        max_str=float_to_str_round(\"max\"),\n        gap_str=float_to_str_round(\"gap\"),\n    )\n)\n\nsegment_data.head()\n\n\nshape: (5, 7)\n\n\n\ncountry\nmin\nmax\ngap\nmin_str\nmax_str\ngap_str\n\n\ncat\nf64\nf64\nf64\nstr\nstr\nstr\n\n\n\n\n\"Russia\"\n76.07362\n95.151515\n19.077896\n\"76\"\n\"95\"\n\"19\"\n\n\n\"Israel\"\n55.405405\n88.311688\n32.906283\n\"55\"\n\"88\"\n\"33\"\n\n\n\"United Kingdom\"\n52.74463\n86.096257\n33.351627\n\"53\"\n\"86\"\n\"33\"\n\n\n\"United States\"\n52.597403\n88.669951\n36.072548\n\"53\"\n\"89\"\n\"36\"\n\n\n\"Canada\"\n53.986333\n92.063492\n38.077159\n\"54\"\n\"92\"\n\"38\"\n\n\n\n\n\n\nFormat the floating point data that will be plotted into strings\nFirst plot\n\n# The right column (youngest-oldest gap) location\nxgap = 112\n\n(\n    ggplot()\n    # Range strip\n    + geom_segment(\n        segment_data,\n        aes(x=\"min\", xend=\"max\", y=\"country\", yend=\"country\"),\n        size=6,\n        color=\"#a7a9ac\",\n    )\n    # Age group markers\n    + geom_point(\n        point_data,\n        aes(\"sm_use_percent\", \"country\", color=\"age_group\", fill=\"age_group\"),\n        size=5,\n        stroke=0.7,\n    )\n    # Age group percentages\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"50+\"),\n        aes(\n            x=\"sm_use_percent-2\",\n            y=\"country\",\n            label=\"sm_use_percent_str\",\n            color=\"age_group\",\n        ),\n        size=8,\n        ha=\"right\",\n    )\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"35-49\"),\n        aes(x=\"sm_use_percent+2\", y=\"country\", label=\"sm_use_percent_str\"),\n        size=8,\n        ha=\"left\",\n        va=\"center\",\n        color=\"white\",\n    )\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"18-34\"),\n        aes(\n            x=\"sm_use_percent+2\",\n            y=\"country\",\n            label=\"sm_use_percent_str\",\n            color=\"age_group\",\n        ),\n        size=8,\n        ha=\"left\",\n    )\n    # gap difference\n    + geom_text(\n        segment_data,\n        aes(x=xgap, y=\"country\", label=\"gap_str\"),\n        size=9,\n        fontweight=\"bold\",\n        format_string=\"+{}\",\n    )\n)\n\n\n\n\n\n\n\n\nTweak it\n\n# The right column (youngest-oldest gap) location\nxgap = 115\n\n(\n    ggplot()\n    # Background Strips                                     # new\n    + geom_segment(\n        segment_data,\n        aes(y=\"country\", yend=\"country\"),\n        x=0,\n        xend=101,\n        size=8.5,\n        color=\"#edece3\",\n    )\n    # vertical grid lines along the strips                  # new\n    + annotate(\n        \"segment\",\n        x=list(range(10, 100, 10)) * n,\n        xend=list(range(10, 100, 10)) * n,\n        y=np.tile(np.arange(1, n + 1), 9) - 0.25,\n        yend=np.tile(np.arange(1, n + 1), 9) + 0.25,\n        color=\"#CCCCCC\",\n    )\n    # Range strip\n    + geom_segment(\n        segment_data,\n        aes(x=\"min\", xend=\"max\", y=\"country\", yend=\"country\"),\n        size=6,\n        color=\"#a7a9ac\",\n    )\n    # Age group markers\n    + geom_point(\n        point_data,\n        aes(\"sm_use_percent\", \"country\", color=\"age_group\", fill=\"age_group\"),\n        size=5,\n        stroke=0.7,\n    )\n    # Age group percentages\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"50+\"),\n        aes(\n            x=\"sm_use_percent-2\",\n            y=\"country\",\n            label=\"sm_use_percent_str\",\n            color=\"age_group\",\n        ),\n        size=8,\n        ha=\"right\",\n    )\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"35-49\"),\n        aes(x=\"sm_use_percent+2\", y=\"country\", label=\"sm_use_percent_str\"),\n        size=8,\n        ha=\"left\",\n        va=\"center\",\n        color=\"white\",\n    )\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"18-34\"),\n        aes(\n            x=\"sm_use_percent+2\",\n            y=\"country\",\n            label=\"sm_use_percent_str\",\n            color=\"age_group\",\n        ),\n        size=8,\n        ha=\"left\",\n    )\n    # countries right-hand-size (instead of y-axis)         # new\n    + geom_text(\n        segment_data,\n        aes(y=\"country\", label=\"country\"),\n        x=-1,\n        size=8,\n        ha=\"right\",\n        fontweight=\"bold\",\n        color=\"#222222\",\n    )\n    # gap difference\n    + geom_vline(xintercept=xgap, color=\"#edece3\", size=32)  # new\n    + geom_text(\n        segment_data,\n        aes(x=xgap, y=\"country\", label=\"gap_str\"),\n        size=9,\n        fontweight=\"bold\",\n        format_string=\"+{}\",\n    )\n    # Annotations                                            # new\n    + annotate(\"text\", x=31, y=n + 1.1, label=\"50+\", size=9, color=\"#ea9f2f\", va=\"top\")\n    + annotate(\n        \"text\", x=56, y=n + 1.1, label=\"35-49\", size=9, color=\"#6d6e71\", va=\"top\"\n    )\n    + annotate(\n        \"text\", x=85, y=n + 1.1, label=\"18-34\", size=9, color=\"#939c49\", va=\"top\"\n    )\n    + annotate(\n        \"text\",\n        x=xgap,\n        y=n + 0.5,\n        label=\"Youngest-\\nOldest Gap\",\n        size=9,\n        color=\"#444444\",\n        va=\"bottom\",\n        ha=\"center\",\n    )\n    + annotate(\"point\", x=[31, 56, 85], y=n + 0.3, alpha=0.85, stroke=0)\n    + annotate(\n        \"segment\",\n        x=[31, 56, 85],\n        xend=[31, 56, 85],\n        y=n + 0.3,\n        yend=n + 0.8,\n        alpha=0.85,\n    )\n    + annotate(\n        \"hline\",\n        yintercept=[x + 0.5 for x in range(2, n, 2)],\n        alpha=0.5,\n        linetype=\"dotted\",\n        size=0.7,\n    )\n    # Better spacing and color                              # new\n    + scale_x_continuous(limits=(-18, xgap + 2))\n    + scale_y_discrete(expand=(0, 0.25, 0.1, 0))\n    + scale_fill_manual(values=[\"#c3ca8c\", \"#d1d3d4\", \"#f2c480\"])\n    + scale_color_manual(values=[\"#939c49\", \"#6d6e71\", \"#ea9f2f\"])\n    + guides(color=None, fill=None)\n    + theme_void()\n    + theme(figure_size=(8, 8.5))\n)\n\n\n\n\n\n\n\n\nInstead of looking at this plot as having a country variable on the y-axis and a percentage variable on the x-axis, we can view it as having vertically stacked up many indepedent variables, the values of which have a similar scale."
  },
  {
    "objectID": "gallery/geom_map.html",
    "href": "gallery/geom_map.html",
    "title": "North Carolina",
    "section": "",
    "text": "import geopandas as gp\nimport geodatasets\nfrom plotnine import (\n    ggplot,\n    aes,\n    coord_fixed,\n    facet_wrap,\n    geom_map,\n    geom_text,\n    labs,\n    scale_fill_brewer,\n    scale_fill_continuous,\n    scale_x_continuous,\n    scale_y_continuous,\n    scale_size_continuous,\n    stage,\n    coord_cartesian,\n    element_line,\n    element_rect,\n    element_text,\n    theme_void,\n    theme,\n)\n\nDefine some useful functions\n\ndef good_centroid(geometry):\n    \"\"\"\n    Calculate \"good\" centroids for polygons in the geometry\n\n    The polygon is projected onto the Equal Area Cylindrical projection,\n    the centroids are computed, then mapped back onto the original\n    coordinate system.\n    \"\"\"\n    return geometry.to_crs(\"+proj=cea\").centroid.to_crs(geometry.crs)\n\n\ndef overlay_color(rgb_hex_colors, light=\"white\", dark=\"black\", threshold=0.5):\n    \"\"\"\n    Decide which color is suitable to write onto the given colors\n    \"\"\"\n    def luminance(rgb_hex):\n        \"\"\"\n        Calculate the Luminance ([0, 1]) of a hex color\n        \"\"\"\n        r = int(rgb_hex[1:3], 16)\n        g = int(rgb_hex[3:5], 16)\n        b = int(rgb_hex[5:], 16)\n        luma = (r*0.299 + g*0.587 + b*0.0722) / 256\n        return luma\n    return [light if luminance(x) &lt; threshold  else dark for x in rgb_hex_colors]\n\n\nA Map from geodatasets\nWe are going to use a dataset from the geodatasets package. We can explore the dataset providers at geodatasets.data, each of which has one or more datasets:\nWe choose the dataset of Sudden Infant Death (SIDS) counts from counties in North Carolina. We can see some meta information about that dataset. You can view the details with geodatasets.data.geoda.sids.\nDownload the dataset we want (it is automatically cached).\n\ngeodatasets.fetch(\"geoda sids\")\n\nRead data\n\nsids = gp.read_file(geodatasets.get_path(\"geoda.sids\"))\nsids.head()\n\n\n\n\n\n\n\n\nAREA\nPERIMETER\nCNTY_\nCNTY_ID\nNAME\nFIPS\nFIPSNO\nCRESS_ID\nBIR74\nSID74\nNWBIR74\nBIR79\nSID79\nNWBIR79\ngeometry\n\n\n\n\n0\n0.114\n1.442\n1825\n1825\nAshe\n37009\n37009\n5\n1091.0\n1.0\n10.0\n1364.0\n0.0\n19.0\nPOLYGON ((-81.47276 36.23436, -81.54084 36.272...\n\n\n1\n0.061\n1.231\n1827\n1827\nAlleghany\n37005\n37005\n3\n487.0\n0.0\n10.0\n542.0\n3.0\n12.0\nPOLYGON ((-81.23989 36.36536, -81.24069 36.379...\n\n\n2\n0.143\n1.630\n1828\n1828\nSurry\n37171\n37171\n86\n3188.0\n5.0\n208.0\n3616.0\n6.0\n260.0\nPOLYGON ((-80.45634 36.24256, -80.47639 36.254...\n\n\n3\n0.070\n2.968\n1831\n1831\nCurrituck\n37053\n37053\n27\n508.0\n1.0\n123.0\n830.0\n2.0\n145.0\nMULTIPOLYGON (((-76.00897 36.3196, -76.01735 3...\n\n\n4\n0.153\n2.206\n1832\n1832\nNorthampton\n37131\n37131\n66\n1421.0\n9.0\n1066.0\n1606.0\n3.0\n1197.0\nPOLYGON ((-77.21767 36.24098, -77.23461 36.214...\n\n\n\n\n\n\n\nThe sids data has two periods 1974 - 1978 and 1979 - 1985. For each period there is a number of births and a number of deaths. We want to visually compare the deaths per 1000 in each county for the two periods.\n\ndata = sids.copy()\n\n# Calculate the death per 1000\ndata[\"1974 - 1978\"] = (data[\"SID74\"] / data[\"BIR74\"]) * 1000\ndata[\"1979 - 1984\"] = (data[\"SID79\"] / data[\"BIR79\"]) * 1000\n\n# Calculate center coordinates for the counties\ndata[\"center_lon\"] = good_centroid(data.geometry).x\ndata[\"center_lat\"] = good_centroid(data.geometry).y\n\n# Make the data\ndata = data.melt(\n    id_vars=[\"NAME\", \"geometry\", \"center_lon\", \"center_lat\"],\n    value_vars=[\"1974 - 1978\", \"1979 - 1984\"],\n    var_name=\"period\",\n    value_name=\"deaths_per_1k\",\n).rename(\n    {\"NAME\": \"county\"},\n    axis=1\n)\n\ndata.head()\n\n\n\n\n\n\n\n\ncounty\ngeometry\ncenter_lon\ncenter_lat\nperiod\ndeaths_per_1k\n\n\n\n\n0\nAshe\nPOLYGON ((-81.47276 36.23436, -81.54084 36.272...\n-81.498245\n36.431263\n1974 - 1978\n0.916590\n\n\n1\nAlleghany\nPOLYGON ((-81.23989 36.36536, -81.24069 36.379...\n-81.125138\n36.490963\n1974 - 1978\n0.000000\n\n\n2\nSurry\nPOLYGON ((-80.45634 36.24256, -80.47639 36.254...\n-80.685736\n36.412381\n1974 - 1978\n1.568381\n\n\n3\nCurrituck\nMULTIPOLYGON (((-76.00897 36.3196, -76.01735 3...\n-76.027392\n36.407026\n1974 - 1978\n1.968504\n\n\n4\nNorthampton\nPOLYGON ((-77.21767 36.24098, -77.23461 36.214...\n-77.410484\n36.422110\n1974 - 1978\n6.333568\n\n\n\n\n\n\n\nPlot the data\n\n(\n    ggplot(data)\n    + geom_map(aes(fill=\"deaths_per_1k\"))\n    + geom_text(\n        aes(\n            \"center_lon\",\n            \"center_lat\",\n            label=\"county\",\n            color=stage(\"deaths_per_1k\", after_scale=\"overlay_color(color)\")\n        ),\n        size=6,\n        show_legend=False\n    )\n    + scale_fill_continuous(\n        name=\"Deaths Per 1000\",\n        cmap_name=\"plasma\",\n        breaks=[0, 2.5, 5, 7.5, 10],\n        labels=[\"0\", \"2.5\", \"5\", \"7.5\", \"10\"],\n        limits=[0, 10],\n    )\n    + facet_wrap(\n        \"period\",\n        ncol=1,\n        labeller=lambda s: f\"Sudden Infant Deaths in the Period {s}\"\n    )\n    + coord_fixed(expand=False)\n    + theme_void()\n    + theme(\n        figure_size=(12, 8),\n        legend_position=(0, 0),\n        legend_direction=\"horizontal\",\n        legend_title_position=\"top\",\n        plot_margin=0.01,\n        plot_background=element_rect(fill=\"white\"),\n        panel_spacing=0.025,\n        legend_frame=element_rect(color=\"black\"),\n        legend_ticks=element_line(color=\"black\"),\n        strip_text=element_text(size=12),\n    )\n)"
  },
  {
    "objectID": "gallery/geom_histogram.html",
    "href": "gallery/geom_histogram.html",
    "title": "Histogram",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    after_stat,\n    geom_histogram,\n    facet_wrap,\n    facet_grid,\n    coord_flip,\n    scale_y_continuous,\n    scale_y_sqrt,\n    scale_y_log10,\n    scale_fill_manual,\n    theme_bw,\n    theme_xkcd,\n)\nfrom plotnine.data import diamonds\nfrom mizani.formatters import percent_format\n\nVisualise the distribution of a variable by dividing the x-axis into bins and counting the number of observations in each bin. Histograms display the counts with bars.\nYou can define the number of bins (e.g. divide the data five bins) or define the binwidth (e.g. each bin is size 10).\nDistributions can be visualised as: * count, * normalised count, * density, * normalised density, * scaled density as a percentage.\n\ndiamonds.head(5)\n\n\n\n\n\n\n\n\ncarat\ncut\ncolor\nclarity\ndepth\ntable\nprice\nx\ny\nz\n\n\n\n\n0\n0.23\nIdeal\nE\nSI2\n61.5\n55.0\n326\n3.95\n3.98\n2.43\n\n\n1\n0.21\nPremium\nE\nSI1\n59.8\n61.0\n326\n3.89\n3.84\n2.31\n\n\n2\n0.23\nGood\nE\nVS1\n56.9\n65.0\n327\n4.05\n4.07\n2.31\n\n\n3\n0.29\nPremium\nI\nVS2\n62.4\n58.0\n334\n4.20\n4.23\n2.63\n\n\n4\n0.31\nGood\nJ\nSI2\n63.3\n58.0\n335\n4.34\n4.35\n2.75\n\n\n\n\n\n\n\n\nBasic Histogram\nIf you create a basic histogram, you will be prompted to define the binwidth or number of bins.\n\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram()\n)\n\n\n\n\n\n\n\n\nYou can define the width of the bins, by specifying the binwidth inside geom_histogram().\n\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram(binwidth=0.5)  # specify the binwidth\n)\n\n\n\n\n\n\n\n\nOr you can define the number of bins by specifying bins inside geom_histogram(). Note, the example below uses 10 bins, however you can’t see them all because some of the bins are too small to be noticeable.\n\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram(bins=10)  # specify the number of bins\n)\n\n\n\n\n\n\n\n\nThere are different ways to visualise the distribution, you can specify this using the y argument within aes(). In the example below I’m using the default setting: raw count with after_stat('count').\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"count\"),  # specify each bin is a count\n        ),\n    )\n    + geom_histogram(binwidth=0.50)\n)\n\n\n\n\n\n\n\n\nYou can normalise the raw count to 1 by using after_stat('ncount'):\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"ncount\"),  # normalise the count to 1\n        ),\n    )\n    + geom_histogram(binwidth=0.50)\n)\n\n\n\n\n\n\n\n\nYou can display the density of points in a bin, (this is scaled to integrate to 1) by using after_stat('density'):\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"density\"),  # density\n        ),\n    )\n    + geom_histogram(binwidth=0.50)\n)\n\n\n\n\n\n\n\n\nThe proportion of bins can be shown, in the example below the bin=0.5 accounts for about ~55% of the data:\n\n(\n    ggplot(\n        diamonds,\n        aes(x=\"carat\", y=after_stat(\"width*density\")),  # show proportion\n    )\n    + geom_histogram(binwidth=0.5)\n)\n\n\n\n\n\n\n\n\nWe can also display counts as percentages by using the percent_format() which requires the mizani.formatters library:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"width*density\")))\n    + geom_histogram(binwidth=0.5)\n    + scale_y_continuous(labels=percent_format())  # display labels as a percentage\n)\n\n\n\n\n\n\n\n\nInstead of using stat you can use stat_bin defined within geom_histogram(), this is useful if you want to layer a few different plots in the one figure.\n\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram(binwidth=0.5, alpha=0.5)\n    + geom_histogram(binwidth=0.2, alpha=0.5, fill=\"green\")\n)\n\n\n\n\n\n\n\n\nYou can also flip the x-y coordinates:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"density\")))\n    + geom_histogram(binwidth=0.5)\n    + coord_flip()\n)\n\n\n\n\n\n\n\n\nYou can visualise counts by other variables using fill within aes():\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"count\"), fill=\"cut\"))\n    + geom_histogram(binwidth=0.5)\n)\n\n\n\n\n\n\n\n\nYou can visualise too-small-to-see bars by transforming the y-axis scaling by using scale_y_sqrt() square-root scale or scale_y_log10() for a log-scale (similarly use scale_x_sqrt() and scale_x_log10() to transform the x-axis).\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"count\")))\n    + geom_histogram(binwidth=0.5)\n    + scale_y_sqrt()  # square root scale\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"count\")))\n    + geom_histogram(binwidth=0.5)\n    + scale_y_log10()  # log scale\n)\n\n\n\n\n\n\n\n\nChange the look of your plot:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"density\")))\n    + geom_histogram(\n        binwidth=0.5,\n        fill=\"green\",  # change the fill colour (one colour)\n        colour=\"pink\",  # change the outline\n        size=2,  # change the thickness of the outline\n        alpha=0.7,  # change the transparency\n    )\n    + theme_xkcd()  # play with themes (look/arrangement)\n)\n\n\n\n\n\n\n\n\nAnother change, this time changing the fill colours manually:\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"density\"),\n            fill=\"cut\",  # change the fill colour using another variable\n        ),\n    )\n    + scale_fill_manual(\n        values=[\"#000000\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\"]\n    )  # change the fill colour\n    + geom_histogram(\n        binwidth=0.5,\n        colour=\"#D55E00\",  # change the outline\n        size=1,  # change the thickness of the outline\n        alpha=0.7,  # change the transparency\n    )\n    + theme_bw()  # play with themes (look/arrangement)\n)\n\n\n\n\n\n\n\n\nWhen faceting histograms with scaled counts/densities, they are normalised by each facet, and not overall. Here’s an example of a facet wrap:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"ncount\")))\n    + geom_histogram(binwidth=0.5)\n    + facet_wrap(\"color\")  # facet wrap\n)\n\n\n\n\n\n\n\n\nHere’s an example of a facet grid with the count normalised in each grid:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"ncount\")))\n    + geom_histogram(binwidth=0.5)\n    + facet_grid(\"cut\", \"color\")\n)"
  },
  {
    "objectID": "gallery/geom_col.html",
    "href": "gallery/geom_col.html",
    "title": "Two Variable Bar Plot",
    "section": "",
    "text": "import pandas as pd\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_col,\n    geom_text,\n    position_dodge,\n    lims,\n    theme,\n    element_text,\n    element_blank,\n    element_rect,\n    element_line,\n)\n\nVisualising on a single plot the values of a variable that has nested (and independent) variables\nCreate the data\n\ndf = pd.DataFrame(\n    {\n        \"variable\": [\n            \"gender\",\n            \"gender\",\n            \"age\",\n            \"age\",\n            \"age\",\n            \"income\",\n            \"income\",\n            \"income\",\n            \"income\",\n        ],\n        \"category\": [\n            \"Female\",\n            \"Male\",\n            \"1-24\",\n            \"25-54\",\n            \"55+\",\n            \"Lo\",\n            \"Lo-Med\",\n            \"Med\",\n            \"High\",\n        ],\n        \"value\": [60, 40, 50, 30, 20, 10, 25, 25, 40],\n    }\n)\ndf[\"variable\"] = pd.Categorical(df[\"variable\"], categories=[\"gender\", \"age\", \"income\"])\ndf[\"category\"] = pd.Categorical(df[\"category\"], categories=df[\"category\"])\n\ndf\n\n\n\n\n\n\n\n\nvariable\ncategory\nvalue\n\n\n\n\n0\ngender\nFemale\n60\n\n\n1\ngender\nMale\n40\n\n\n2\nage\n1-24\n50\n\n\n3\nage\n25-54\n30\n\n\n4\nage\n55+\n20\n\n\n5\nincome\nLo\n10\n\n\n6\nincome\nLo-Med\n25\n\n\n7\nincome\nMed\n25\n\n\n8\nincome\nHigh\n40\n\n\n\n\n\n\n\nWe want to visualise this data and at a galance get an idea to how the value breaks down along the categorys for the different variable. Note that each variable has different categorys.\nFirst we make a simple plot with all this information and see what to draw from it.\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col()\n)\n\n\n\n\n\n\n\n\nAll the values along each variable add up to 100, but stacked together the difference within and without the groups is not clear. The solution is to dodge the bars.\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col(stat=\"identity\", position=\"dodge\")  # modified\n)  \n\n\n\n\n\n\n\n\nThis is good, it gives us the plot we want but the legend is not great. Each variable has a different set of categorys, but the legend has them all clamped together. We cannot easily change the legend, but we can replicate it’s purpose by labelling the individual bars.\nTo do this, we create a geom_text with position_dodge(width=0.9) to match the ratio of the space taken up by each variable. If there was no spacing between the bars of different variables, we would have width=1.\nA minor quack, when text extends beyond the limits we have to manually make space or it would get clipped. Therefore we adjust the bottom y limits.\n\ndodge_text = position_dodge(width=0.9)  # new\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col(stat=\"identity\", position=\"dodge\", show_legend=False)  # modified\n    + geom_text(\n        aes(y=-0.5, label=\"category\"),  # new\n        position=dodge_text,\n        color=\"gray\",\n        size=8,\n        angle=45,\n        va=\"top\",\n    )\n    + lims(y=(-5, 60))  # new\n)\n\n\n\n\n\n\n\n\nWould it look too crowded if we add value labels on top of the bars?\n\ndodge_text = position_dodge(width=0.9)\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col(stat=\"identity\", position=\"dodge\", show_legend=False)\n    + geom_text(\n        aes(y=-0.5, label=\"category\"),\n        position=dodge_text,\n        color=\"gray\",\n        size=8,\n        angle=45,\n        va=\"top\",\n    )\n    + geom_text(\n        aes(label=\"value\"),  # new\n        position=dodge_text,\n        size=8,\n        va=\"bottom\",\n        format_string=\"{}%\",\n    )\n    + lims(y=(-5, 60))\n)\n\n\n\n\n\n\n\n\nThat looks okay. The values line up with the categorys because we used the same dodge parameters. For the final polish, we remove the y-axis, clear out the panel and make the variable and category labels have the same color.\n\ndodge_text = position_dodge(width=0.9)\nccolor = \"#555555\"\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col(stat=\"identity\", position=\"dodge\", show_legend=False)\n    + geom_text(\n        aes(y=-0.5, label=\"category\"),\n        position=dodge_text,\n        color=ccolor,\n        size=8,\n        angle=45,\n        va=\"top\",\n    )  # modified\n    + geom_text(\n        aes(label=\"value\"),\n        position=dodge_text,\n        size=8,\n        va=\"bottom\",\n        format_string=\"{}%\",\n    )\n    + lims(y=(-5, 60))\n    + theme(\n        panel_background=element_rect(fill=\"white\"),  # new\n        axis_title_y=element_blank(),\n        axis_line_x=element_line(color=\"black\"),\n        axis_line_y=element_blank(),\n        axis_text_y=element_blank(),\n        axis_text_x=element_text(color=ccolor),\n        axis_ticks_major_y=element_blank(),\n        panel_grid=element_blank(),\n        panel_border=element_blank(),\n    )\n)\n\n\n\n\n\n\n\n\nCredit: I saved a plot this example is based on a while ago and forgot/misplaced the link to the source. The user considered it a minor coup."
  },
  {
    "objectID": "gallery/geom_bar.html",
    "href": "gallery/geom_bar.html",
    "title": "Horizontal Bar Chart",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_bar, coord_flip, theme_classic\nfrom plotnine.data import mpg\n\ngeom_bar() makes the height of the bar proportional to the number of cases in each group\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\n\nBar Plot with Counts\n\nggplot(mpg) + geom_bar(aes(x=\"class\"))\n\n\n\n\n\n\n\n\n\n(\n    ggplot(mpg)\n    + geom_bar(aes(x=\"class\", fill=\"drv\"))\n)\n\n\n\n\n\n\n\n\n\n\nHorizontal Bar Plot with Counts\n\n(\n    ggplot(mpg) \n    + geom_bar(aes(x=\"class\", fill=\"drv\"))\n    + coord_flip()\n    + theme_classic()\n)"
  },
  {
    "objectID": "gallery/geom_abline.html",
    "href": "gallery/geom_abline.html",
    "title": "Trend Line",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_point, labs, geom_abline, facet_grid\nfrom plotnine.data import mpg\n\ngeom_abline() draws a line when the yintercept and gradient is supplied, and is useful as a guide.\n\n# inspect the data\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nIt’s useful to use geom_abline() with some data, so we start with a basic scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nNow layer a line over the scatter plot using geom_abline(). geom_abline() requires inputs for the slope (default slope is 1) and y-intercept (default value is [0,0]).\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_abline(\n        intercept=45,  # set the y-intercept value\n        slope=-5,  # set the slope value\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can plot two lines on one plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_abline(\n        intercept=[45, 45],  # add many lines to a plot using a list for the y-intercepts...\n        slope=[-5, -7],  # ... and for the slopes\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can change the look of the line:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_abline(\n        intercept=45,\n        slope=-5,\n        color=\"blue\",  # set line colour\n        size=2,  # set line thickness\n        linetype=\"dashed\",  # set line type\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\ngeom_abline() can be used with a facet plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_abline(intercept=45, slope=-5)  # add a line ...\n    + facet_grid(\"drv\")  # ... to a facet plot.\n    + labs(x=\"displacement\", y=\"horsepower\")\n)"
  },
  {
    "objectID": "gallery/anscombes-quartet.html",
    "href": "gallery/anscombes-quartet.html",
    "title": "Anscombe’s Quartet",
    "section": "",
    "text": "In 1973, statistician Francis Anscombe challenged the commonly held belief that “numerical calculations are exact, but graphs are rough” (Anscombe, 1973). His strategy was to manually construct four small datasets—now known as Anscombe’s Quartet—that have different distributions but nearly identical descriptive statistics. It’s perhaps the best argument for visualizing data.\nIn this notebook we replicate his paper by using Plotnine to visualize those datasets and Polars to verify their descriptive statistics. More specifically, we:\nimport polars as pl\nfrom plotnine import *"
  },
  {
    "objectID": "gallery/anscombes-quartet.html#create-a-long-dataframe",
    "href": "gallery/anscombes-quartet.html#create-a-long-dataframe",
    "title": "Anscombe’s Quartet",
    "section": "Create a Long DataFrame",
    "text": "Create a Long DataFrame\nFirst, we turn the original four datasets into one Polars DataFrame. With 3 columns and 44 rows, the DataFrame is in long format, making it convenient for Polars to compute descriptive statistics and for Plotnine to visualize each row as a point. The column dataset indicates which rows belong to which dataset using the Roman numerals I through IV. (The Roman numerals are purely for visualization purposes.)\n\nanscombe_datasets = [\n    {\"x\": [10.0, 8.0, 13.0, 9.0, 11.0, 14.0, 6.0, 4.0, 12.0, 7.0, 5.0],\n     \"y\": [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68]},\n    {\"x\": [10.0, 8.0, 13.0, 9.0, 11.0, 14.0, 6.0, 4.0, 12.0, 7.0, 5.0],\n     \"y\": [9.14, 8.14, 8.74, 8.77, 9.26, 8.1, 6.13, 3.1, 9.13, 7.26, 4.74]},\n    {\"x\": [10.0, 8.0, 13.0, 9.0, 11.0, 14.0, 6.0, 4.0, 12.0, 7.0, 5.0],\n     \"y\": [7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73]},\n    {\"x\": [8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 19.0, 8.0, 8.0, 8.0],\n     \"y\": [6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.5, 5.56, 7.91, 6.89]}\n]\n\nanscombe_quartet = pl.concat([\n    pl.DataFrame(xy).select(pl.lit(d).alias(\"dataset\"), \"x\", \"y\")\n    for d, xy in zip([\"I\", \"II\", \"III\", \"IV\"], anscombe_datasets)\n])\n\nanscombe_quartet\n\n\nshape: (44, 3)\n\n\n\ndataset\nx\ny\n\n\nstr\nf64\nf64\n\n\n\n\n\"I\"\n10.0\n8.04\n\n\n\"I\"\n8.0\n6.95\n\n\n\"I\"\n13.0\n7.58\n\n\n\"I\"\n9.0\n8.81\n\n\n\"I\"\n11.0\n8.33\n\n\n…\n…\n…\n\n\n\"IV\"\n8.0\n5.25\n\n\n\"IV\"\n19.0\n12.5\n\n\n\"IV\"\n8.0\n5.56\n\n\n\"IV\"\n8.0\n7.91\n\n\n\"IV\"\n8.0\n6.89"
  },
  {
    "objectID": "gallery/anscombes-quartet.html#compute-descriptive-statistics",
    "href": "gallery/anscombes-quartet.html#compute-descriptive-statistics",
    "title": "Anscombe’s Quartet",
    "section": "Compute Descriptive Statistics",
    "text": "Compute Descriptive Statistics\nTo verify that the four datasets have identical descriptive statistics, we use Polars to compute the mean and the variance of both x and y. We also compute the correlation between x and y:\n\npl.Config.set_float_precision(2)\n\nanscombe_quartet.group_by(\"dataset\", maintain_order=True).agg(\n    pl.col(\"x\", \"y\").mean().name.prefix(\"mean_\"),\n    pl.col(\"x\", \"y\").var().name.prefix(\"variance_\"),\n    pl.corr(\"x\", \"y\").alias(\"correlation_xy\"),\n)\n\n\nshape: (4, 6)\n\n\n\ndataset\nmean_x\nmean_y\nvariance_x\nvariance_y\ncorrelation_xy\n\n\nstr\nf64\nf64\nf64\nf64\nf64\n\n\n\n\n\"I\"\n9.00\n7.50\n11.00\n4.13\n0.82\n\n\n\"II\"\n9.00\n7.50\n11.00\n4.13\n0.82\n\n\n\"III\"\n9.00\n7.50\n11.00\n4.12\n0.82\n\n\n\"IV\"\n9.00\n7.50\n11.00\n4.12\n0.82\n\n\n\n\n\n\nAs you can see, the descriptive statistics are nearly identical. At the end of this notebook there’s a bonus section where we use scikit-learn to fit a linear regression line to each dataset and verify that the intercept, slope, and \\(R^2\\) are also identical. (Spoiler alert: they are!)"
  },
  {
    "objectID": "gallery/anscombes-quartet.html#exploratory-data-visualization",
    "href": "gallery/anscombes-quartet.html#exploratory-data-visualization",
    "title": "Anscombe’s Quartet",
    "section": "Exploratory Data Visualization",
    "text": "Exploratory Data Visualization\nLet’s create a few basic data visualizations to get a better feeling for the data. What’s great about Plotnine is that you can get a first plot with relatively little code. We have two continuous variables x and y, so a scatter plot might work:\n\nggplot(anscombe_quartet, aes(\"x\", \"y\")) + geom_point()\n\n\n\n\n\n\n\n\nThat doesn’t make much sense yet. We need a way to distinguish between the datasets. Let’s color each point according to the dataset it belongs to:\n\nggplot(anscombe_quartet, aes(\"x\", \"y\", color=\"dataset\")) + geom_point()\n\n\n\n\n\n\n\n\nWell, that’s rather messy. Let’s create a panel for each dataset using the facet_wrap() function instead. To make the code easier to read and to edit, we’ll put each function on its own line:\n\n(\n    ggplot(anscombe_quartet, aes(\"x\", \"y\", color=\"dataset\")) +\n    facet_wrap(\"dataset\") +\n    geom_point()\n)\n\n\n\n\n\n\n\n\nThat’s better. The panels make the use of color redundant, so we’ll make each point black again. Let’s also add a regression line using the geom_smooth() function, to visualize that the four datasets have identical descriptive statistics.\n\n(\n    ggplot(anscombe_quartet, aes(\"x\", \"y\")) +\n    geom_point() +\n    geom_smooth(method=\"lm\", se=False, fullrange=True, color=\"blue\") +\n    facet_wrap(\"dataset\")\n)\n\n\n\n\n\n\n\n\nThis data visualization clearly supports Anscombe’s point: that datasets with different distributions can have the same descriptive statistics."
  },
  {
    "objectID": "gallery/anscombes-quartet.html#a-fine-tuned-data-visualization",
    "href": "gallery/anscombes-quartet.html#a-fine-tuned-data-visualization",
    "title": "Anscombe’s Quartet",
    "section": "A Fine-Tuned Data Visualization",
    "text": "A Fine-Tuned Data Visualization\nOur final exploratory data visualization gets the job done, but it doesn’t hurt to make it more visually appealing. In the following code snippet, we:\n\nRemove many elements, including grid lines, tick marks, and axis labels. They’re not needed to bring the point across.\nAdd a title.\nChange the colors and the font.\n\nAs you can see, there’s quite some code needed for this fine-tuning. Luckily, because of its composable API, Plotnine allows you to gradually move from a exploratory data visualization to a fine-tuned explanatory one.\n\n(\n    ggplot(anscombe_quartet, aes(\"x\", \"y\")) +\n    geom_point(color=\"sienna\", fill=\"darkorange\", size=3) +\n    geom_smooth(method=\"lm\", se=False, fullrange=True, color=\"steelblue\", size=1) +\n    facet_wrap(\"dataset\") +\n    scale_y_continuous(breaks=(4, 8, 12)) +\n    coord_fixed(xlim=(3, 22), ylim=(2, 14)) +\n    labs(title=\"Anscombe’s Quartet\") +\n    theme_tufte(base_family=\"Futura\") +\n    theme(\n        axis_line=element_line(color=\"#4d4d4d\"),\n        axis_ticks_major=element_line(color=\"#00000000\"),\n        axis_title=element_blank(),\n        plot_background=element_rect(fill=\"#ffffff\", color=\"#ffffff\"),\n        dpi=144,\n        panel_spacing=0.09,\n        strip_text=element_text(size=12),\n        title=element_text(size=16, margin={\"b\": 20})\n    )\n)"
  },
  {
    "objectID": "gallery/anscombes-quartet.html#bonus-apply-linear-regression",
    "href": "gallery/anscombes-quartet.html#bonus-apply-linear-regression",
    "title": "Anscombe’s Quartet",
    "section": "Bonus: Apply Linear Regression",
    "text": "Bonus: Apply Linear Regression\nIn this bonus section, we use scikit-learn to fit a linear regression line to each dataset and confirm that the intercept, slope, and \\(R^2\\) are also identical. The geom_smooth() function added regression lines to our scatter plots, but now we get to see the raw values as well.\n\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import r2_score\n\ndef fit_lr(s):\n    lr = LinearRegression()\n    X = s.struct.field(\"x\").to_numpy().reshape(-1, 1)\n    y = s.struct.field(\"y\").to_numpy()\n\n    # Compute intercept and coefficient\n    lr.fit(X, y)\n    intercept = lr.intercept_\n    slope = lr.coef_[0]\n\n    # Compute R^2\n    r2 = r2_score(y, intercept + slope * X)\n    \n    return {\"intercept\": intercept, \"slope\": slope, \"r2\": r2}\n\nanscombe_quartet.group_by(\"dataset\", maintain_order=True).agg(\n    pl.col(\"x\", \"y\").mean().name.prefix(\"mean_\"),\n    pl.col(\"x\", \"y\").var().name.prefix(\"variance_\"),\n    pl.corr(\"x\", \"y\").alias(\"correlation_xy\"),\n    (\n        pl.struct(\"x\", \"y\")\n        .map_elements(fit_lr, return_dtype=pl.Struct({\"intercept\": pl.Float64,\n                                                      \"slope\": pl.Float64,\n                                                      \"r2\": pl.Float64}))\n        .alias(\"lr\")\n    )\n).unnest(\"lr\")\n\n\nshape: (4, 9)\n\n\n\ndataset\nmean_x\nmean_y\nvariance_x\nvariance_y\ncorrelation_xy\nintercept\nslope\nr2\n\n\nstr\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\n\n\n\n\n\"I\"\n9.00\n7.50\n11.00\n4.13\n0.82\n3.00\n0.50\n0.67\n\n\n\"II\"\n9.00\n7.50\n11.00\n4.13\n0.82\n3.00\n0.50\n0.67\n\n\n\"III\"\n9.00\n7.50\n11.00\n4.12\n0.82\n3.00\n0.50\n0.67\n\n\n\"IV\"\n9.00\n7.50\n11.00\n4.12\n0.82\n3.00\n0.50\n0.67"
  },
  {
    "objectID": "gallery/anscombes-quartet.html#references",
    "href": "gallery/anscombes-quartet.html#references",
    "title": "Anscombe’s Quartet",
    "section": "References",
    "text": "References\n\nAnscombe, F. J. (1973). “Graphs in Statistical Analysis”. American Statistician. 27 (1): 17–21."
  },
  {
    "objectID": "gallery/after_scale.html",
    "href": "gallery/after_scale.html",
    "title": "Using after_scale()",
    "section": "",
    "text": "import pandas as pd\n\nfrom plotnine import ggplot, aes, after_scale, geom_bar, theme_classic\n\nThe bars in geom_bar have two aesthetics that control the coloring; fill for the interior and color for the boundary/edge. Using after_scale we can create a matching combination of these two.\nStart off with a mapping to the color.\n\ndf = pd.DataFrame({\"var1\": [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]})\n\n(\n    ggplot(df, aes(\"var1\", color=\"factor(var1)\"))\n    + geom_bar(size=1)\n)\n\n\n\n\n\n\n\n\nWe can match the color with the fill.\n\n(\n    ggplot(df, aes(\"var1\", color=\"factor(var1)\"))\n    + geom_bar(aes(fill=after_scale(\"color\")), size=1)\n)\n\n\n\n\n\n\n\n\nAs after_scale takes an expression, for the fill aesthetic we can modify the color by adding to it an alpha channel i.e. '#AABBCC' to '#AABBCC66'.\n\n(\n    ggplot(df, aes(\"var1\", color=\"factor(var1)\"))\n    + geom_bar(aes(fill=after_scale('color + \"66\"')), size=1)\n)\n\n\n\n\n\n\n\n\nWe rely on the fact that you can append a string to all elements of a pandas series\npd.Series(['#AABBCC', '#112233']) + '66' == pd.Series(['#AABBCC66', '#11223366'])\nWith a fitting theme.\n\n(\n    ggplot(df, aes(\"var1\", color=\"factor(var1)\"))\n    + geom_bar(aes(fill=after_scale('color + \"66\"')), size=1)\n    + theme_classic()\n)"
  },
  {
    "objectID": "gallery/PlotnineAnimation.html",
    "href": "gallery/PlotnineAnimation.html",
    "title": "Spiral Animation",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nfrom plotnine import ggplot, aes, geom_path, theme, theme_void, lims\nfrom plotnine.animation import PlotnineAnimation\n\n# for animation in the notebook\nfrom matplotlib import rc\n\nrc(\"animation\", html=\"html5\")\n\nThe PlotnineAnimation methods takes a sequence of plots and animates them. The best way to create the sequence is to use a function that generates plots.\nNOTE: When creating the plots make sure all the plots have scales with the same limits for each aesthetic, including the x and y aesthetics.\n\n# Parameters used to control the spiral\nn = 100\ntightness = 1.3\nkmin = 1\nkmax = 25\nnum_frames = 25\ntheta = np.linspace(-np.pi, np.pi, n)\n\n\ndef plot(k):\n    # For every plot we change the theta\n    _theta = theta * k\n\n    # Polar Equation of each spiral\n    r = tightness * _theta\n\n    df = pd.DataFrame({\n        \"theta\": _theta,\n        \"r\": r,\n        \"x\": r * np.sin(_theta),\n        \"y\": r * np.cos(_theta)\n    })\n\n    p = (\n        ggplot(df)\n        + geom_path(aes(\"x\", \"y\", color=\"theta\"), size=1)\n        + lims(\n            # All the plots have scales with the same limits\n            x=(-130, 130),\n            y=(-130, 130),\n            color=(-kmax * np.pi, kmax * np.pi),\n        )\n        + theme_void()\n        + theme(\n            aspect_ratio=1,\n            # Make room on the right for the legend\n            subplots_adjust={\"right\": 0.85},\n        )\n    )\n    return p\n\n\n# It is better to use a generator instead of a list\nplots = (plot(k) for k in np.linspace(kmin, kmax, num_frames))\nani = PlotnineAnimation(plots, interval=100, repeat_delay=500)\n# ani.save('/tmp/animation.mp4')\nani\n\n\n  \n  Your browser does not support the video tag.\n\n\n\nThe final image of the spiral\n\nplot(kmax)"
  },
  {
    "objectID": "changelog.html",
    "href": "changelog.html",
    "title": "Changelog",
    "section": "",
    "text": "(not-yet-released)\n\n\n\nThemeables axis_ticks_pad, axis_ticks_pad_minor, axis_ticks_pad_major, axis_ticks_pad_minor_x, axis_ticks_pad_minor_y, axis_ticks_pad_major_x and axis_ticks_pad_major_y have been deprecated. Use the margin parameter of element_text with axis_text, axis_text_x or axis_text_y to control the spacing between the axis text and the ticks. (#843)\n\n\n\n\n\nPlot Composition is here. Using an intuitive algebra, you can now put combine multiple plots into a single graphic. e.g.\np1 = ggplot(...)\np2 = ggplot(...)\np3 = ggplot(...)\n\n(p1 | p2) / p3\nUsing plot_title_position and plot_caption_position e.g.\ntheme(\n   plot_title_position=\"plot\",\n   plot_caption_position=\"plot\",\n)\nYou can now position the plot_title, plot_subtitle and plot_caption by alignment them with respect to the plot. (#838)\nGained new label tag to create a tag for a plot. You can set it with labs e.g.\nlabs(tag=\"A\")\nand customise it using these themeables\nplot_tag and plot_tag_position and plot_tag_location\ne.g.\ntheme(\n   plot_tag=\"plot\",\n   plot_tag_location=\"plot\",\n   plot_tag_position=\"topright\",\n)\nGeoms geom_bar and geom_col have gained new parameter just that controls how the bars align with the axis break point.\ngeom_sina has gained new parameter style just like geom_violin, which make one-sided (half) sina plots.\nGained the Anscombe Quartet dataset, anscombe_quartet.\nGained new module plotnine.helpers to be a place for some helper functions.\nGained new helper function get_aesthetic_limits.\n\n\n\n\n\nIncluded datasets mpg, msleep and midwest no longer have any of their columns as categoricals. This matches the respective datasets in R. #913\nWhen the width of the violins in geom_violin is wider than their normal area, they now overlap with those closest to the origin on top. This makes it possible to create overlapping ridge plots using half violins.\nlegend_key now inherits from panel_background and the default themes have been adjusted to rely on this inheritance. So when using the default themes, altering fill parameter of the panel_background will also affect the background of the legend_key.\nThe default value for the guide parameter for the identity scales (scale_*_identity) has been reverted to None. This means by default using these scales will not generate a legend.\n\n\n\n\n\nFixed bug in with the legend_key_height themeable where it wasn’t applied. #921\nFixed bug where justifying axis_text_x and axis_text_y using horizontal and vertical alignment did not work as expected. #927\nFixed justifying strip_text within the strip_background. #867\nFixed bug where facetting along a column with unused categories could raise an error. #930\nFixed bug where computed aesthetic from after_scale are were not applied to the legend. #926\nFixed theming of minor x axis ticks.\nFixed theming of axis_text, axis_text_x and axis_text_y so when they can be overriden if previously set to element_blank().\nFixed strip_text_x_backgrounds to always have equal heights and strip_text_y_backgrounds to have equal widths. This applies to cases where the texts have unequal number of lines or they are rotated but have different lengths.\nFixed the empty space below the plot title (or subtitle) when strip_text_x_backgrounds are partly or fully aligned within the panel. This space (hole), was not accounted for by any of the themeables. This affected theme_xkcd and any theme settings that tried to slide the text / background into the panel.\nFixed the empty space to the left the right margin when the strip_text_y_backgrounds are partly or fully aligned within the panel. This space (hole), was not accounted for by any of the themeables. This affected theme_xkcd and any theme settings that tried to slide the text / background into the panel.\nFixed bug in geom_histogram where mapping to the weight aesthetic lead to an error. #936"
  },
  {
    "objectID": "changelog.html#v0.15.0",
    "href": "changelog.html#v0.15.0",
    "title": "Changelog",
    "section": "",
    "text": "(not-yet-released)\n\n\n\nThemeables axis_ticks_pad, axis_ticks_pad_minor, axis_ticks_pad_major, axis_ticks_pad_minor_x, axis_ticks_pad_minor_y, axis_ticks_pad_major_x and axis_ticks_pad_major_y have been deprecated. Use the margin parameter of element_text with axis_text, axis_text_x or axis_text_y to control the spacing between the axis text and the ticks. (#843)\n\n\n\n\n\nPlot Composition is here. Using an intuitive algebra, you can now put combine multiple plots into a single graphic. e.g.\np1 = ggplot(...)\np2 = ggplot(...)\np3 = ggplot(...)\n\n(p1 | p2) / p3\nUsing plot_title_position and plot_caption_position e.g.\ntheme(\n   plot_title_position=\"plot\",\n   plot_caption_position=\"plot\",\n)\nYou can now position the plot_title, plot_subtitle and plot_caption by alignment them with respect to the plot. (#838)\nGained new label tag to create a tag for a plot. You can set it with labs e.g.\nlabs(tag=\"A\")\nand customise it using these themeables\nplot_tag and plot_tag_position and plot_tag_location\ne.g.\ntheme(\n   plot_tag=\"plot\",\n   plot_tag_location=\"plot\",\n   plot_tag_position=\"topright\",\n)\nGeoms geom_bar and geom_col have gained new parameter just that controls how the bars align with the axis break point.\ngeom_sina has gained new parameter style just like geom_violin, which make one-sided (half) sina plots.\nGained the Anscombe Quartet dataset, anscombe_quartet.\nGained new module plotnine.helpers to be a place for some helper functions.\nGained new helper function get_aesthetic_limits.\n\n\n\n\n\nIncluded datasets mpg, msleep and midwest no longer have any of their columns as categoricals. This matches the respective datasets in R. #913\nWhen the width of the violins in geom_violin is wider than their normal area, they now overlap with those closest to the origin on top. This makes it possible to create overlapping ridge plots using half violins.\nlegend_key now inherits from panel_background and the default themes have been adjusted to rely on this inheritance. So when using the default themes, altering fill parameter of the panel_background will also affect the background of the legend_key.\nThe default value for the guide parameter for the identity scales (scale_*_identity) has been reverted to None. This means by default using these scales will not generate a legend.\n\n\n\n\n\nFixed bug in with the legend_key_height themeable where it wasn’t applied. #921\nFixed bug where justifying axis_text_x and axis_text_y using horizontal and vertical alignment did not work as expected. #927\nFixed justifying strip_text within the strip_background. #867\nFixed bug where facetting along a column with unused categories could raise an error. #930\nFixed bug where computed aesthetic from after_scale are were not applied to the legend. #926\nFixed theming of minor x axis ticks.\nFixed theming of axis_text, axis_text_x and axis_text_y so when they can be overriden if previously set to element_blank().\nFixed strip_text_x_backgrounds to always have equal heights and strip_text_y_backgrounds to have equal widths. This applies to cases where the texts have unequal number of lines or they are rotated but have different lengths.\nFixed the empty space below the plot title (or subtitle) when strip_text_x_backgrounds are partly or fully aligned within the panel. This space (hole), was not accounted for by any of the themeables. This affected theme_xkcd and any theme settings that tried to slide the text / background into the panel.\nFixed the empty space to the left the right margin when the strip_text_y_backgrounds are partly or fully aligned within the panel. This space (hole), was not accounted for by any of the themeables. This affected theme_xkcd and any theme settings that tried to slide the text / background into the panel.\nFixed bug in geom_histogram where mapping to the weight aesthetic lead to an error. #936"
  },
  {
    "objectID": "changelog.html#v0.14.5",
    "href": "changelog.html#v0.14.5",
    "title": "Changelog",
    "section": "v0.14.5",
    "text": "v0.14.5\n(2025-01-02) \n\nFixed geom_text with adjust_text so that the the arrows are drawn between layers with the text/label on top."
  },
  {
    "objectID": "changelog.html#v0.14.4",
    "href": "changelog.html#v0.14.4",
    "title": "Changelog",
    "section": "v0.14.4",
    "text": "v0.14.4\n(2024-12-16) \n\nBug Fixes\n\nFixed geom_text with adjust_text so that the the arrows are drawn at the same layer (zorder) as the text.\nFixed geom_text with adjust_text for some cases where the text are placed outside the panels. #899\nThe default aesthetics and aesthetic parameters of geoms (and stats) are now transformed. So you can now set date values as aesthetic parameters. e.g.\ngeom_point(y=datetime(2024, 12, 11))\nif the y aesthetic is mapped to datetime column in another layer.\nFixed bug for matplotlib&gt;3.10 where the axis_ticks_length for the x-axis had no effect."
  },
  {
    "objectID": "changelog.html#v0.14.3",
    "href": "changelog.html#v0.14.3",
    "title": "Changelog",
    "section": "v0.14.3",
    "text": "v0.14.3\n(2024-11-26) \n\nEnhancements\n\nGot rid of a logging information about the fontsize that is recorded for all plots that have a legend. (#889)\nWhen using geom_text with adjust_text, some sensible default arrow properties will be applied.\nChanged the threshold number of keys for when the legend is split into multiple columns from 20 to 15. This only applies in the default case when the user does not set the number of rows or columns i.e. guide_legend(nrow=None, ncol=None). (#757)"
  },
  {
    "objectID": "changelog.html#v0.14.2",
    "href": "changelog.html#v0.14.2",
    "title": "Changelog",
    "section": "v0.14.2",
    "text": "v0.14.2\n(2024-11-21)\n\n\nBug Fixes\n\nFixed bugs that affected geom_dotplot and geom_sina where data with an index that did not include 0 led to a crash. (#888)\nFixed v0.14.0 regression that made scale_color_cmap_d unusable. (#890)"
  },
  {
    "objectID": "changelog.html#v0.14.1",
    "href": "changelog.html#v0.14.1",
    "title": "Changelog",
    "section": "v0.14.1",
    "text": "v0.14.1\n(2024-11-05)\n\n\nBug Fixes\n\nFix expansion of datetime and timedelta scales when using both the lower and upper addition constants.\nIn quarto documents make the output retina even if the fig-format is png.\nFixed bug where you could not save as pdf if also specifying the aspect_ratio. (#885)"
  },
  {
    "objectID": "changelog.html#v0.14.0",
    "href": "changelog.html#v0.14.0",
    "title": "Changelog",
    "section": "v0.14.0",
    "text": "v0.14.0\n(2024-10-28)\n\n\nAPI Changes\n\nYou cannot call print on a ggplot object to show it. This was deprecated in v0.13.0 and it has now been removed. Use ggplot.show()\nThe color_space parameter of scale_color_hue now accepts the value \"hlsuv\" instead of \"husl\". The meaning of has not changed, and \"husl\" is silently accepted.\nThemeables axis_ticks_direction, axis_ticks_direction_x and axis_ticks_direction_y have be deprecated. In their place, the direction of the ticks can be controlled by using +ve, -ve or complex values for the axis_ticks_length, axis_ticks_length_major, axis_ticks_length_major_x, axis_ticks_length_major_y, axis_ticks_length_minor, axis_ticks_length_minor_x, or axis_ticks_length_minor_y.\n\n\n\nEnhancements\n\nThe family, fontstyle and fontweight parameters of geom_text are now aesthetics (#790).\nplotnine now responds to the fig-width, fig-height and fig-format settings in the meta section of a quarto document.\nggtitle now accepts title and subtitle as keyword arguments. (#804)\nGained the option limitsize that makes it possible to display plots of any size.\nfrom plotnine.options import set_option\n\nset_option(\"figure_format\", False)\nFor geom_boxplot when the outliers are made invisible by giving them no shape, now they do not affect the limits of the plot. (#814)\nMade it possile to map an aesthetic value to None. (#791)\nThe signatures for the scale classes now list all the allowed parameters.\n\n\n\nNew Features\n\ngeom_text has gained new aesthetics fontvariant and fontstretch.\n\n\n\nBug Fixes\n\nFix layers 3 and above not to overlap the axis lines if there are any (#798).\nFixed bug in geom_segment where the lineend parameter was ignored. (#727)\nFixed stat_summary_bin to work with continuous x aesthetic when specifying the binwidth or breaks. (#824)\nFixed PlotnineAnimation not to draw a second legend at the bottom-left corner. (#816)\nFixed bug where setting theme(text=element_blank()) would raise and exception.\nFixed datetime and timedelta scales so they can be expanded by adding constant timedelta values."
  },
  {
    "objectID": "changelog.html#v0.13.6",
    "href": "changelog.html#v0.13.6",
    "title": "Changelog",
    "section": "v0.13.6",
    "text": "v0.13.6\n(2024-05-09)\n\n\nBug Fixes\n\nFixed geom_label to work with a boxstyle of any following square, circle, darrow, larrow, rarrow, roundtooth or sawtooth.(#779)\n\n\n\nEnhancements\n\nStopped spurious warnings of the form PlotnineWarning: Failed to apply   `after_scale` modifications to the legend. when the after_scale mapping is for another aestetic.\nAdded width and height as default aesthetics of geom_tile."
  },
  {
    "objectID": "changelog.html#v0.13.5",
    "href": "changelog.html#v0.13.5",
    "title": "Changelog",
    "section": "v0.13.5",
    "text": "v0.13.5\n(2024-04-26)\n\n\nBug Fixes\n\nFixed bug in stat_smooth where you could not set the family when using a glm. (#769)\nFixed bug in position_dodge2 the widths of the dodged objects were mixed up. (#772)\nFixed geom_text to work better with adjustText v1.0.0 and above.\nFixed images generated in quarto so that they have the dimensions (taking the dpi into account) that are specified in theme. (#773)\n\n\n\nNew\n\nAdded themeable svg_usefonts. (#756)\n\n\n\nEnhancements\n\nAdded palmerpenguins dataset."
  },
  {
    "objectID": "changelog.html#v0.13.4",
    "href": "changelog.html#v0.13.4",
    "title": "Changelog",
    "section": "v0.13.4",
    "text": "v0.13.4\n(2024-04-03)\n\n\nBug Fixes\n\nFixed regression in v0.13.3 where setting some text elements element_blank led to an error. (#764)"
  },
  {
    "objectID": "changelog.html#v0.13.3",
    "href": "changelog.html#v0.13.3",
    "title": "Changelog",
    "section": "v0.13.3",
    "text": "v0.13.3\n(2024-03-27) \n\nBug Fixes\n\nFixed layout manager to make space for the strip_text when there is no strip_background. (#760)\nMade the default position of guide_legend text to be right. (#761)\nFixed aligning (ha & va) of plot_title, plot_subtitle, plot_caption, axis_title_x, axis_title_y to work with float values in the range [0, 1]."
  },
  {
    "objectID": "changelog.html#v0.13.2",
    "href": "changelog.html#v0.13.2",
    "title": "Changelog",
    "section": "v0.13.2",
    "text": "v0.13.2\n(2024-03-14)\n\n\nEnhancements\n\nDrawing the plot ensures that pandas Copy-on-Write is turned off. Plotnine is not yet compatible with Copy-on-Write so this prevents errors for users who have turned on the option."
  },
  {
    "objectID": "changelog.html#v0.13.1",
    "href": "changelog.html#v0.13.1",
    "title": "Changelog",
    "section": "v0.13.1",
    "text": "v0.13.1\n(2024-03-06)\n\n\nBug Fixes\n\nFixed a bug where a legend with blank title or text could result in a wrong justification.\nFixed a bug where setting legend justification to a string i.e one of left, right, top, bottom, center had no effect."
  },
  {
    "objectID": "changelog.html#v0.13.0",
    "href": "changelog.html#v0.13.0",
    "title": "Changelog",
    "section": "v0.13.0",
    "text": "v0.13.0\n(2024-02-20)\n\n\nAPI Changes\n\nRequires python &gt;= 3.9\nUsing the print or repr functions to draw and show the plot has been deprecated. Use ggplot.show().\nThe name of the calculated aesthetic of stat_function changed from y to fx.\nstat_ecdf has gained the pad parameter. The default is set to True, which pads the domain with -inf and inf so that the ECDF does not have discontinuities at the extremes. To get the behaviour, set pad to False. (#725)\nRemoved the environment parameter from ggplot.\nWhen a ggplot object is the last in a jupyter cell, the output image will not be followed by string meta information about the figure/image.\nThis will happen even if the backend is set to an interactive one.\nIf you set the backend to an interactive one, use show to draw the plot.\nThe default horizontal alignment for the plot title is center if it there is no subtitle. When there is a subtitle, the default is to have both aligned to the left.\nSome parameters that control the look and feel of guide_colorbar and guide_legend have been removed. For their place, the theme parameter has been introduced and it gives better control of the look and feel.\nThemeables legend_entry_spacing, legend_entry_spacing_x and legend_entry_spacing_y have been renamed to legend_key_spacing, legend_key_spacing_x and legend_key_spacing_y respectively\nfacet_grid now accepts two parameters, rows and cols, to specify the variables along the two dimensions of the panels.\nThe previous way of using a single parameter will still work if it is a string. For cases where the value was a list, e.g.\nfacet_grid(facets=[\"col1\", \"col2\"])\ncan be rewritten as any one of;\nfacet_grid(\"col1\", \"col2\")\nfacet_grid([\"col1\"], [\"col2\"])\nfacet_grid(rows=\"col1\", cols=\"col2\")\nfacet_grid(rows=[\"col1\"], cols=[\"col2\"])\nThe facets parameter in facet_wrap has also changed to a more straight forward specification for the column variables. It expects a single string or a list/tuple of strings. (#545)\nHowever, the R-style formula strings are still silently accepted.\n\n\n\nNew\n\nAdded symmetric logarithm transformation scales scale_x_symlog and scale_y_symlog\nGained themeables\n\nplot_margin_left\nplot_margin_right\nplot_margin_top\nplot_margin_bottom\n\nto set the plot margin on each side independently.\nGained themeables\n\naxis_ticks_length_major_x\naxis_ticks_length_major_y\naxis_ticks_length_minor_x\naxis_ticks_length_minor_y\n\nto control the x & y axis ticks length.\nGained themeables\n\naxis_ticks_pad_major_x\naxis_ticks_pad_minor_y\n\nto control the x & y tick padding.\nSome parameters in element_text can now accept lists/tuples to set the values on individual text objects. (#724)\nGained the option figure_format to set the format of the inline figures in an interactive session. e.g.\nfrom plotnine.options import set_option\n\nset_option(\"figure_format\", \"svg\")\nwill output all subsequent figures in svg format.\nImproved support for customizing guides/legends.\n\nYou can now add a frame to the colobar\nYou can now apply themes to individual guides, e.g.\n+ guides(color=guide_colorbar(theme=theme_xkcd()))\nor\n+ guides(color=guide_legend(theme=theme_minimal())\nYou can now place legends at more than one position around the panels. e.g.\n+ guides(\n    color=guide_colorbar(position=\"left\"),\n    fill=guide_legend(position=\"bottom\"),\n    size=guide_legend(position=\"bottom\")\n)\nPuts the fill and size guides at the bottom, and the color guide on the left.\nYou can easily justify the legend along the four edges of the space around the panel area.\nYou can now place the legend inside the panels with easily control its location.\n\nThe space parameter of facet_grid now responds to the values free, free_x and free_y to have panels whose relative width and/or height depends on the data range. (#545)\n\n\n\nBug Fixes\n\nFixed handling of minor breaks in scale_continuous to accept numpy arrays and when the scale has a transform, that the minor breaks are supplied in user space and not transform space. Just like the major breaks. (#685)\nFixed theming of axis_ticks with the size parameter. (#703)\nFixed space handling around axis_label, axis_text and axis_ticks when the ticks are turned off.\nFixed bug in geom_path where the lineend parameter was ignored. (#727)\nFixed bug where theme(legend_background=element_blank()) messed up the position of the legend, instead of only removing the background.\nFixed using facet_grid with a column named key. (#734)\nFixed using legend when using an identity scale and reordering the breaks. (#735)\nFixed drawing the upper outline of geom_ribbon. (#728)\nFixed issue where the gridlines overlap the panel border. (#638)\n\n\n\nEnhancements\n\nAll __all__ variables are explicitly assigned to help static typecheckers infer module attributes. (#685)\nYou can now pickle the drawn matplotlib figures. (#729)\nThe facet titles in the strip_text are now better aligned are appear more centered within the strip_background."
  },
  {
    "objectID": "changelog.html#v0.12.4",
    "href": "changelog.html#v0.12.4",
    "title": "Changelog",
    "section": "v0.12.4",
    "text": "v0.12.4\n(2023-11-06)\n\n\nBug Fixes\n\nFixed position_dodge to work with to work for geom_segment.\nFixed the x limits when plotting geom_sina.\nFixed stat_boxplot and stat_ydensity when there is no x aesthetic.\n\n\n\nEnhancements\n\nReturn group counts for stat_summary."
  },
  {
    "objectID": "changelog.html#v0.12.3",
    "href": "changelog.html#v0.12.3",
    "title": "Changelog",
    "section": "v0.12.3",
    "text": "v0.12.3\n(2023-09-01)\n\n\nEnhancements\n\nResolved Future Warnings from pandas-2.1.0"
  },
  {
    "objectID": "changelog.html#v0.12.2",
    "href": "changelog.html#v0.12.2",
    "title": "Changelog",
    "section": "v0.12.2",
    "text": "v0.12.2\n(2023-07-21)\n\n\nThis is a maintenance release that prevents newer versions of mizani from breaking plotnine. This version depends on mizani&lt;0.10.0."
  },
  {
    "objectID": "changelog.html#v0.12.1",
    "href": "changelog.html#v0.12.1",
    "title": "Changelog",
    "section": "v0.12.1",
    "text": "v0.12.1\n(2023-05-09)\n\n\nNew Features\n\nA layout manager. Now you do not have to adjust spacing parameters to prevent objects around the panels from overlapping. Specifically, you can:\n\nSet the legend position to “top”, “left” or “bottom”\nUse a large or multiline plot title\nUse a large or multiline plot caption\nUse facet_wrap with scales=\"free\" scales=\"free_x\" or scales=\"free_y\"\n\nYou can now also align the plot_title, axis_title_x, axis_title_y and plot_caption with respect to the panels. Set these to “left”, “right” & “center” for the horizontal flowing text. And “top”, “right” & “center” for the vertical flowing text.\nAlso, the size of the figure is exactly determined by the theme setting. For example, this:\ntheme(figure_size=(8, 6), dpi=100)\nwill create an 800px x 600px image.\nYou can create a subtitle using labs and style it using the plot_subtitle parameter to theme.\n```py theme(plot_subtitle=element_text(size=8))\n\n\n\nEnhancements\n\nggplot object gained a new method save_helper. It gives you access to the matplotlib figure that will be saved to file.\nWhen plotting with an ipython interactive backend (e.g. in a jupyter notebook). The default image output is retina. You do not need to run this command.\n%config InlineBackend.figure_format = \"retina\"\nPlotnine still respects any values set the user.\nIn an interactive setting, after drawing an image. The size of the figure (in pixels) is printed e.g. &lt;Figure Size: (640 x 480)&gt;. Previously, something like &lt;ggplot: (336175301)&gt; was printed.\n\n\n\nAPI Changes\n\n__add__ and __iadd__ now accept the same types of objects. In this change __iadd__ has gained the ability to accept a list of objects.\ndraw no longer accepts the argument return_ggplot and the return value is always a matplolib figure.\nThemeables strip_margin, strip_margin_x and strip_margin_y) have been renamed to strip_align, strip_align_x strip_align_y respectively.\nsubplots_adjust has been deprecated. You no longer need to use theme(subplots_adjust={\"right\": 0.85}) and the like to make space for the legend or text around the panels. In the future, this will through an error.\nChanged default font-family (san-serif) from DejaVu Sans to Helvetica.\n\n\n\nBug Fixes\n\nFixed bug where a discrete position scale failed when mapping an empty variable. (#647)\nFixed bug where facet_grid with a datetime column run into an exception. (#629)\nFixed bug where geom_violin with facetting and \"scales = free\" did not work. (#655)\nFixed bug in position_dodge2 to work with preserve=\"single\" for geom_rect and any other geoms that accept a min-max range along the x-axis.\nFixed legend for geom_point to accurately display transparent fill colors that have been manually set. (#665)\nFix issue where infinite limits for the x or y scales lead to an exception. (#664)\nFixed geom_text and geom_label when used with string formatting so that missing values are removed. (#651)"
  },
  {
    "objectID": "changelog.html#v0.10.1",
    "href": "changelog.html#v0.10.1",
    "title": "Changelog",
    "section": "v0.10.1",
    "text": "v0.10.1\n(2022-09-10)\n\nThis is a re-release of v0.10.0.\nIn the previous release the project description fileformat changed and not all references to it were corrected. PYPI read file that did not exist, got no description. This release is fixes error."
  },
  {
    "objectID": "changelog.html#v0.10.0",
    "href": "changelog.html#v0.10.0",
    "title": "Changelog",
    "section": "v0.10.0",
    "text": "v0.10.0\n(2022-09-10)\n\n\nBug Fixes\n\nFixed bug in stat_bin_2d where bins whose edges are zero or negative would yield the wrong plot. (#604)\nFixed bug stat_density_2d which had been broken by Matplotlib 1.6.0. (#619)\nFixed geom_text when using adjust_text for the arrows to have the same color as the text.\n\n\n\nNew Features\n\ngeom_ribbon acquired new parameter where which can be used shade within given limits .\nAdded support for objects with a to_pandas method to convert them to a pandas dataframe. You can now pass in polars dataframes.\ngeom_ribbon acquired new parameter outline_type which controls how to stroke the boundaries of the shaded area. This parameter is also available to geom_area and geom_density. (#605)\n\n\n\nAPI Changes\n\nThe automatic groups generated by the system and depending on the aesthetic mappings now only depend those aesthetics that have scales. This is more strict than has been, should affect very few cases of code that has been written and it should be less surprising to the users.\ngeom_area and geom_density now default to showing only the upper outline/boundary of the area. Use outline_type=\"full\" for the old behaviour."
  },
  {
    "objectID": "changelog.html#v0.9.0",
    "href": "changelog.html#v0.9.0",
    "title": "Changelog",
    "section": "v0.9.0",
    "text": "v0.9.0\n(2022-07-01)\n\n\nAPI Changes\n\nFor the calls to ggplot, the order of the positional arguments is (data, mapping) and for calls geoms and stats the order is (mapping, data). In practice, you can still provide one/two positional arguments in any order. However, the are a few cases where old code will breaks due to duplicate parameters.\n\n\n\nNew Features\n\nAdded geom_pointdensity, a 2D density plot that does not hide the distribution of the individual data points.\nposition_dodge2 gained the ability to reverse the order of the plotted groups. (#515)\nAdded theme_tufte, a theme that reduces the distractions around plot data.\nlabs can now be used to create a caption. This caption can be styled using the plot_caption parameter to theme.\ntheme(plot_caption=element_text(size=13))\nYou can now align the plot_title horizontally to the left or right.\ntheme(plot_title=element_text(ha=\"left\"))\nBefore, the title was always centered.\n\n\n\nBug Fixes\n\nFixed bug in facet_grid and facet_wrap where the drop parameter was ignored. (#510)\nFixed issue with annotation_logticks where the wrong range was used for the x|y axis. (#525)\nFixed bug in geom_smooth where using a coordinate transformation without computing the standard error led to a crash. (#526)\nFixed bug where you could not specific the cap/end of a dashed line when styling a plot with element_line.\nFixed legend for geom_map so that the entries have the same stroke and points on the map. (#534)\nFixed geom_histogram for some cases when it fails to automatically determine the number of bins. (#543)\nFixed facet_grid and facet_wrap when mapping to lists/arrays/series so that the rows mapped this way are not mixed up. (#548)\nFixed stat_bin_2d not to error for matplotlib &gt;= 3.5.0 so that it does not throw a Numpy error. (#567)\nFixed geom_map to be able to draw Polygons with holes in them.\nFixed geom_map to be able to draw MultiPolygons.\nFixed scale_x_discrete and scale_x_discrete to work properly with None values. (#523)\nFixed geom_point to respect not to use the fill mapping on unfilled shapes. (#100)\nFixed position_stack to work with scales that have non-linear transformations. e.g. scale_y_log10. (#580)\nFixed scales to work with limits passed as a function.\nFixed axis_ticks so you can change the colour of the axis ticks. This was probably a regression due to changes in Matplotlib.\nFixed panel_ontop so that if is set to False, then the data visualised below the grid-lines. (#585)\nFixed geom_ribbon, geom_area and geom_density to work with coord_flip. (#596)\n\n\n\nEnhancements\n\nstat_summary now has a default summary function. (#528)\nstat_density now uses a fast computation path for gaussian densities with no weights. This was probably a regression.\ngeom_map can now draw MultiPoints, MultiLineStrings and MultiPolygons.\ngeom_text with adjust_text can now be used in more than one layer with good enough results."
  },
  {
    "objectID": "changelog.html#v0.8.0",
    "href": "changelog.html#v0.8.0",
    "title": "Changelog",
    "section": "v0.8.0",
    "text": "v0.8.0\n(2021-03-24)\n\n\nAPI Changes\n\nHow you map to calculated aesthetics has changed. Use the after_stat function. The old methods 'stat(name)' and '..name..' have been deprecated.\n\n\n\nNew Features\n\nYou can now map to aesthetics at three different stages. See aes, after_stat, after_scale and stage.\ngeom_violin gained the a new parameter style with which you can draw half violin (density curve on one side and flat on the other).\nAdded geom_raster.\ngeoms gained new parameter raster for the layer. You can use it to rasterize any layer when the resulting plot is of vector format e.g. pdf.\nUsing the space parameter, facet_grid gained the ability to have rows and columns of panels of different sizes.\n\n\n\nBug Fixes\n\nFixed issue where some plots with a colorbar would fail for specific themes. (#424)\nFixed geom_map to plot MultiLineString geom types.\nFixed geom_text to allow any order of mapping and data positional arguments.\nFixed bug were the plotted image may have ignored theming that relied on some Matplotlib rcParams. (#451)\nFixed the weight aesthetic in geom_boxplot, previously ignored it is now recognised. (#438)\nFixed annotation_logticks and annotation_stripes to work without global data and aesthetics. (#469)\nFix scale_shape_discrete when printing many unfilled shapes not to assign the same shapes to more than one group. (#473)\nFixed bug in stat_ellipse where the center of the ellipse assuming a multivariate t-distribution was incorrectly calculated. (#493)\nFixed calculation of ndensity in stat_bin. (#494)\n\n\n\nEnhancements\n\nManual scales now match the values of the breaks if the breaks are given. (#445)\nUsing print to show a ggplot object will not show the hash (&lt;ggplot: ...&gt;) anymore. There is now a difference between repr(p) and str(p). (#453)\nAdded option to for the base_family of a theme, now you can set it once with and have it be applied to all themes. (#436)\nfrom plotnine.options import set_option\nset_option('base_family', 'Comic Sans MS')\nYou can now add None to a ggplot, doing so returns a copy of the the ggplot object. (#474)\nBetter handling of multiline facet labels. (#484)"
  },
  {
    "objectID": "changelog.html#v0.7.1",
    "href": "changelog.html#v0.7.1",
    "title": "Changelog",
    "section": "v0.7.1",
    "text": "v0.7.1\n(2020-08-05)\n\n\nBug Fixes\n\nFixed issue where a plot has no data and the geoms have no data, but the mappings are valid. (#404)\nFixed preserve=\"single\" in position_dodge and position_dodge2 to work for geoms that only have x aesthetic and not xmin and xmax e.g geom_text.\nFix regression in v0.7.0 where plots with a colorbar would fail if using theme_matplotlib."
  },
  {
    "objectID": "changelog.html#v0.7.0",
    "href": "changelog.html#v0.7.0",
    "title": "Changelog",
    "section": "v0.7.0",
    "text": "v0.7.0\n(2020-06-05)\n\n\nAPI Changes\n\nChanged the default method of calculating bandwidth for all stats that use kernel density estimation. The affected stats are stat_density, stat_ydensity, and stat_sina. These stats can now work with groups that have a single unique value.\nChanged scale_colour_continuous to refer to the same scale as scale_color_continuous.\nChanged scale_color_cmap so the parameter cmap_name refers to the name of the color palette and name refers to the name of the scale. (#371)\n\n\n\nNew Features\n\naes got an internal function reorder which makes it easy to change the ordering of a discrete variable according to some other variable/column.\nstat_smooth can now use formulae for linear models.\n\n\n\nBug Fixes\n\nFixed issue where a wrong warning could be issued about changing the transform of a specialised scale. It mostly affected the timedelta scale.\nFixed geom_violin and other geoms when used with position=\"dodge\" not to crash when if a layer has an empty group of data.\nFixed bug in geom_path for some cases when groups had less than 2 points. (#319)\nFixed all stats that compute kernel density estimates to work when all the data points are the same. (#317)\nFixed issue where setting the group to a string value i.e. group=\"string\" outside aes() failed due to an error.\nFixed issue where discrete position scales could not deal with fewer limits than those present in the data. (#342)\nFixed issue with using custom tuple linetypes~ with scale_linetype_manual. (#352)\nFixed geom_map to work with facets. (#359)\nFixed position_jitterdodge to work when color is used as an aesthetic. (#372)\nFixed geom_qq to work with facets. (#379)\nFixed skewed head in arrow when drawn on facetted plot. (#388)\nFixed issue with stat_density where weights could not be used with a gaussian model. (#392)\nFixed bug where guide_colorbar width and height could not be controlled by legend_key_width and legend_key_height. (#360)\n\n\n\nEnhancements\n\nYou can now set the bandwidth parameter bw of stat_ydensity.\nParameters ha and va of geom_text have been converted to aesthetics. You can now map to them. (#325)\nAll themes (except theme_matplotlib) now do not show minor ticks. (#348)"
  },
  {
    "objectID": "changelog.html#v0.6.0",
    "href": "changelog.html#v0.6.0",
    "title": "Changelog",
    "section": "v0.6.0",
    "text": "v0.6.0\n(2019-08-21)\n\n\nAPI Changes\n\nThe draw parameter of geom_map has been removed. Shapefiles should contain only one type of geometry and that is the geometry that is drawn.\nOrdinal (Ordered categorical) columns are now mapped to ordinal scales. This creates different plots.\nThe default mapping for the computed aesthetic size of stat_sum has changed to 'stat(n)'. This also changes the default plot for geom_count.\n\n\n\nNew Features\n\ngeom_text gained the adjust_text parameter, and can now repel text.\nAdded annotation_logticks.\nAdded geom_sina\nAdded scales for ordinal (ordered categorical) columns.\ngeom_step gained the option mid for the direction parameter. The steps are taken mid-way between adjacent x values.\nAdded annotation_stripes.\n\n\n\nBug Fixes\n\nFixed bug where facetting would fail if done on a plot with annotation(s) and one of the facetting columns was also a variable in the environment.\nFixed bug where coord_flip would not flip geoms created by geom_rug. (#216)\nFixed bug where plots with theme_xkcd cannot be saved twice. (#199)\nFixed bug that made it impossible to map to columns with the same name as a calculated columns of the stat. (#234)\nFixed bug in geom_smooth that made it difficult to use it with stats other than stat_smooth. (#242)\nFixed bug in position_dodge where by bar plot could get thinner when facetting and using preserve = 'single'. (#224)\nFixed bug in coord_trans where if the transformation reversed the original limits, the order in which the data was laid out remained unchanged. (#253)\nFixed bug in stat_count where float weights were rounded and lead to a wrong plot. (#260)\nFixed bug where one could not use the British spelling colour to rename a color scale. (#264)\nFixed bug in lims, xlim, and ylim where datetime and timedelta limits resulted in an error.\nFixed bug where geom_rect could not be used with coord_trans. (#256)\nFixed bug where using free scales with facetting and flipping the coordinate axes could give unexpected results. (#286)\nFixed unwanted tick along the axis for versions of Matplotlib &gt;= 3.1.0.\nFixed geom_text not to error when using hjust and vjust. (#287)\nFixed bug where geom_abline geom_hline and geom_vline could give wrong results when used with coord_trans.\nFixed bug where layers with only infinite values would lead to an exception if they were the first layer encountered when choosing a scale.\n\n\n\nEnhancements\n\nLegends are now plotted in a predictable order which dedends on how the plot is constructed.\nThe spokes drawn by geom_spoke can now have a fixed angle.\nAesthetics that share a scale (e.g. color and fill can have the same scale) get different guides if mapped to different columns.\nWhen the transform of a specialised (one that is not and identity scale) continuous scale is altered, the user is warned about a possible error in what they expect. (#254, #255)\nThe method_args parameter in stat_smooth can now differentiate between arguments for initialising and those for fitting the smoothing model.\nposition_nudge can now deal with more geoms e.g. geom_boxplot.\nThe limits parameter of scale_x_discrete and scale_y_discrete can now be a function.\nThe width of the boxplot can now be set irrespective of the stat.\nThe mid-point color of scale_color_distiller now matches that of the trained data.\nThe way in which layers are created has been refactored to give packages that that extend plotnine more flexibility in manipulating the layers.\nYou can now specify one sided limits for coordinates. e.g. coord_cartesian(limits=(None, 10)).\nAll the themeables have been lifted into the definition of theme so they can be suggested autocomplete."
  },
  {
    "objectID": "changelog.html#v0.5.1",
    "href": "changelog.html#v0.5.1",
    "title": "Changelog",
    "section": "v0.5.1",
    "text": "v0.5.1\n(2018-10-17)\n\n\nBug Fixes\n\nChanged the dependency for mizani to v0.5.2. This fixes an issue where facetting may create plots with missing items. (#210)"
  },
  {
    "objectID": "changelog.html#v0.5.0",
    "href": "changelog.html#v0.5.0",
    "title": "Changelog",
    "section": "v0.5.0",
    "text": "v0.5.0\n(2018-10-16)\n\n\nAPI Changes\n\nPlotnine 0.5.0 only supports Python 3.5 and higher\ngeopandas has been removed as a requirement for installation. Users of geom_map will have to install it separately. (#178)\n\n\n\nBug Fixes\n\nFixed issue where with the subplots_adjust themeable could not be used to set the wspace and hspace Matplotlib subplot parameters. (#185)\nFixed in stat_bin where setting custom limits for the scale leads to an error. (#189)\nFixed issue interactive plots where the x & y coordinates of the mouse do not show. (#187)\nFixed bug in geom_abline where passing the mapping as a keyword parameter lead to a wrong plot. (#196)\nFixed issue where minor_breaks for transformed scaled would have to be given in the transformed coordinates. Know they are given the data coordinates just like the major breaks.\n\n\n\nEnhancements\n\nFor all geoms, with coord_cartesian float('inf') or np.inf are interpreted as the boundary of the plot panel.\nDiscrete scales now show missing data (None and nan). This behaviour is controlled by the new na_translate option.\nThe minor_breaks parameter for continuous scales can now be given as an integer. An integer is taken to control the number of minor breaks between any set of major breaks."
  },
  {
    "objectID": "changelog.html#v0.4.0",
    "href": "changelog.html#v0.4.0",
    "title": "Changelog",
    "section": "v0.4.0",
    "text": "v0.4.0\n2018-01-08\n\n\nAPI Changes\n\nCalculated aesthetics are accessed using the plotnine.aes.stat function. The old method (double dots ..name..) still works.\nstat_qq calculates slightly different points for the theoretical quantiles.\nThe scales (when set to free, free_x or free_y) parameter of facet_grid and facet_wrap assigns the same scale across the rows and columns.\n\n\n\nNew Features\n\nAdded geom_qq_line and stat_qq_line, for lines through Q-Q plots.\nAdded geom_density_2d and stat_density_2d.\nAdded stat_ellipse.\nAdded geom_map.\nPlotnine learned to respect plydata groups.\nAdded stat_hull.\nAdded save_as_pdf_pages.\n\n\n\nBug Fixes\n\nFixed issue where colorbars may chop off the colors at the limits of a scale.\nFixed issue with creating fixed mappings to datetime and timedelta type values. (#88)\nFixed scale_x_datetime and scale_y_datetime to handle the intercepts along the axes. (#97)\nFixed stat_bin and stat_bin_2d to properly handle the breaks parameter when used with a transforming scale.\nFixed issue with x and y scales where the name of the scale was ignored when determining the axis titles. Now, the name parameter is specified, it is used as the title. (#105)\nFixed bug in discrete scales where a column could not be mapped to integer values. (#108)\nMake it possible to hide the legend with theme(legend_position=\"none\"). (#119)\nFixed issue in stat_summary_bin where some input values gave an error. (#123)\nFixed geom_ribbon to sort data before plotting. (#127)\nFixed IndexError in facet_grid when row/column variable has 1 unique value. (#129)\nFixed facet_grid when scale=\"free\", scale=\"free_x\" or scale=\"free_y\", the panels share axes along the row or column.\nFixed geom_boxplot so that user can create a boxplot by specifying all required aesthetics. (#136)\nFixed geom_violin to work when some groups are empty. (#131)\nFixed continuous scales to accept minor=None. (#120)\nFixed bug for discrete position scales, where drop=False did not drop unused categories. (#139)\nFixed bug in stat_ydensity that caused an exception when a panel had no data. (#147)\nFixed bug in coord_trans where coordinate transformation and facetting could fail with a KeyError. (#151)\nFixed bug that lead to a TypeError when aesthetic mappings to could be recognised as being groupable. It was easy to stumble on this bug when using geom_density. (#165)\nFixed bug in facet_wrap where some combination of parameters lead to unexpected panel arrangements. (#163)\nFixed bug where the legend text of colorbars could not be themed. (#171)"
  },
  {
    "objectID": "changelog.html#v0.3.0",
    "href": "changelog.html#v0.3.0",
    "title": "Changelog",
    "section": "v0.3.0",
    "text": "v0.3.0\n(2017-11-08)\n\nAPI Changes\n\ngeom_smooth gained an extra parameter legend_fill_ratio that control the area of the legend that is filled to indicate confidence intervals. (#32)\nsave gained an extra parameter verbose. It no longer guesses when to print information and when not to.\ndraw gained an extra parameter return_ggplot.\nIf the minor_breaks parameter of scales is a callable, it now expects one argument, the limits. Previously it accepted breaks and limits.\n\n\n\nNew Features\n\nAdded PlotnineAnimation for animations.\nAdded watermark for watermarks.\nAdded datetime scales for alpha, colour, fill and size aesthetics\n\n\n\nEnhancements\n\nChanged parameter settings for stat_smooth.\n\nDefault span=0.75 instead of 2/3\nWhen using loess smoothing, the control parameter surface is only set to the value 'direct' if predictions will be made outside the data range.\n\nBetter control of scale limits. You can now specify individual limits of a scale.\nscale_y_continuous(limits=(0, None))\nxlim(None, 100)\nYou can also use expand_limits\nLow and high scale limits can now be expanded separately with different factors multiplicative and additive factors.\nThe layer parameter show_legend can now accept a dict for finer grained control of which aesthetics to exclude in the legend.\nInfinite values are removed before statistical computations stats. (#40).\nstats also gained new parameter na_rm, that controls whether missing values are removed before statistical computations.\nqplot can now use the name and a Pandas series to label the scales of the aesthetics.\nYou can now put stuff to add to a ggplot object into a list and add that that instead. No need to wrap the list around the internal class Layers.\nlst = [geom_point(), geom_line()]\ng = ggplot(df, aes('x', 'y'))\nprint(g + lst)\nUsing a list allows you to bundle up objects. It can be convenient when creating some complicated plots. See the Periodic Table Example.\nYou can now use a dict (with manual scales) to map data values to aesthetics. (#169)\nYou can now specify infinite coordinates with geom_rect. (#166)\n\n\n\nBug Fixes\n\nFixed bug where facetting led to a reordering of the data. This would manifest as a bug for geoms where order was important. (#26)\nFix bug where facetting by a column whose name (eg. class) is a python keyword resulted in an exception. (#28)\nFix bug where y-axis scaling was calculated from the xlim argument.\nFix bug where initialising geoms from stats, and positions from geoms, when passed as classes (e.g. stat_smooth(geom=geom_point), would fail.\nFixed bug in save where specifying the width and height would mess up the strip_text and spacing for the facetted plots. (#44).\nFixed bug in geom_abline, geom_hline and geom_vline where facetting on a column that is not mapped to an aesthetic fails. (#48)\nFixed bug in geom_text, the fontstyle parameter was being ignored.\nFixed bug where boolean data was mapped to the same value on the coordinate axis. (#57)\nFixed bug in facet_grid where the scales sometimes has no effect. (#58)\nFixed bug in stat_boxplot where setting the width parameter caused an exception."
  },
  {
    "objectID": "changelog.html#v0.2.1",
    "href": "changelog.html#v0.2.1",
    "title": "Changelog",
    "section": "v0.2.1",
    "text": "v0.2.1\n(2017-06-22)\n\nFixed bug where manually setting the aesthetic fill=None or fill=\"None\" could lead to a black fill instead of an empty fill.\nFixed bug where computed aesthetics could not be used in larger statements. (#7)\nFixed bug in stat_summary where the you got an exception for some types of the x aesthetic values.\nFixed bug where ggplot(data=df) resulted in an exception.\nFixed missing axis ticks and labels for facet_wrap when the scales are allowed to vary (e.g scales=\"free\") between the panels.\nFixed bug in stat_density where changing the x limits lead to an exception. (#22)"
  },
  {
    "objectID": "changelog.html#v0.2.0",
    "href": "changelog.html#v0.2.0",
    "title": "Changelog",
    "section": "v0.2.0",
    "text": "v0.2.0\n(2017-05-18)\n\nFixed bug in scale_x_discrete and scale_y_discrete where if they were instantiated with parameter limits that is either a numpy array or a pandas series, plotting would fail with a ValueError.\nFixed exceptions when using pandas.pivot_table for Pandas v0.20.0. The API was fixed.\nFixed issues where lines/paths with segments that all belonged in the same group had joins that in some cases were “butted”.\n\n\nAPI Changes\n\ngeom_text now uses ha and va as parameter names for the horizontal and vertical alignment. This is what matplotlib users expect. The previous names hjust and vjust are silently accepted.\nplotnine.layer.Layers can now be used to bundle up geoms and stats. This makes it easy to reuse geoms and stats or organise them in sensible bundles when making complex plots."
  },
  {
    "objectID": "changelog.html#v0.1.0",
    "href": "changelog.html#v0.1.0",
    "title": "Changelog",
    "section": "v0.1.0",
    "text": "v0.1.0\n(2017-04-25)\nFirst public release"
  },
  {
    "objectID": "blog/2024/07/2024-contest-last-call/index.html",
    "href": "blog/2024/07/2024-contest-last-call/index.html",
    "title": "2024 Plotnine Contest - Last Call",
    "section": "",
    "text": "The 2024 Plotnine Contest will close in 5 days on 26th July 2024, this is after a two week extension.\nWe have many submissions already but we could have move in these two categories."
  },
  {
    "objectID": "blog/2024/07/2024-contest-last-call/index.html#visualisation-of-distributions",
    "href": "blog/2024/07/2024-contest-last-call/index.html#visualisation-of-distributions",
    "title": "2024 Plotnine Contest - Last Call",
    "section": "1. Visualisation of Distributions",
    "text": "1. Visualisation of Distributions\nMost of the time, the main plot of statistical graphics is to get a sense of how the data is distributed. I would love to see more submissions of this type. This resource from the University of Iowa is a good introduction to the kinds of ways you can visualise distributions. I think there is plenty of room for otherwise simple visualisations of data distributions made more compelling by the choice of dataset, colors, annotations and overall polish."
  },
  {
    "objectID": "blog/2024/07/2024-contest-last-call/index.html#visualisation-art",
    "href": "blog/2024/07/2024-contest-last-call/index.html#visualisation-art",
    "title": "2024 Plotnine Contest - Last Call",
    "section": "2. Visualisation Art",
    "text": "2. Visualisation Art\nPlotnine implements The Grammar of Graphics, which moulds Drawing and Painting Art into a system suitable for statistical graphics. Constrained within, the Art says “I want to break free” and a contest is the party at which to break free. We got all week.\nA contest can trigger you into action on tasks you’ve long procrastinated or avoided due to concerns about developing an unhealthy addiction. This one may have got me. Inspired by a Yan Holtz piece, Michael Chow has deeped into generative art for this contest. In turn, I have given it a go.\nFrom Yan and through Michael, I get an abstract form and first I unpaint it to reveal its spiky nature.\n\nThe Spiky World\n\n\nCode\nfrom plotnine import (\n    aes,\n    coord_cartesian,\n    element_rect,\n    geom_area,\n    ggplot,\n    scale_color_manual,\n    theme_void,\n    theme,\n)\nimport pandas as pd\nimport numpy as np\n\n\nnum_groups = 30\n\ndef get_colors(cmap_name, start=0, stop=1, n=10):\n    \"\"\"Return colors from a colormap\"\"\"\n    from mizani.palettes import get_colormap\n    x = np.linspace(start, stop, n)\n    return get_colormap(cmap_name).continuous_palette(x)\n\ndef combine(colors: list[str]):\n    from mizani.palettes import gradient_n_pal\n    x = np.linspace(0, 1, num_groups)\n    return gradient_n_pal(colors)(x)\n\ndef make_data(seed=123):\n    names = [f\"G{i}\" for i in range(num_groups)]\n    population = [0] * 100 + list(range(1, num_groups+1))\n    rs = np.random.RandomState(seed)\n    frames = []\n    for i in range(30):\n        arr = rs.choice(population, num_groups)\n        _data = pd.DataFrame({\n            \"x\": i,\n            \"y\": arr / np.sum(arr),\n            \"g\": rs.choice(names, num_groups, replace=False),\n        })\n        frames.append(_data)\n    return pd.concat(frames).sort_values([\"x\", \"g\"])\n\ndef blink(colors: list[str] | list[list[str]], seed=123):\n    data = make_data(seed)\n    p = (\n        ggplot(data, aes(x=\"x\", y=\"y\", fill=\"g\", color=\"g\"))\n        + geom_area(show_legend=False)\n        + coord_cartesian(expand=False)\n        + scale_color_manual(values=combine(colors), aesthetics=[\"fill\", \"color\"])\n        + theme_void()\n    )\n    return p\n\n(\n    ggplot(make_data(), aes(x=\"x\", y=\"y\", group=\"g\"))\n    + geom_area(fill=\"white\", color=\"black\", show_legend=False)\n    + coord_cartesian(expand=False)\n    + theme_void()\n    + theme(plot_background=element_rect(fill=\"white\"))\n)\n\n\n\n\n\n\n\n\n\nThen with each blink of the eye, The Spiky World reveals one of her infinite faces.\nBlink.\n\n\nSpiky Desert Dunes\n\n\nCode\nblink(get_colors(\"inferno\", .5, 1)[::-1])\n\n\n\n\n\n\n\n\n\nBlink.\n\n\nA Spiky Volcano\n\n\nCode\nblink(get_colors(\"magma\", .3, .95))\n\n\n\n\n\n\n\n\n\nBlink.\n\n\nA Morning in a Spiky Forest\n\n\nCode\nblink(get_colors(\"Greens\"))\n\n\n\n\n\n\n\n\n\nBlink.\n\n\nA Spiky Sunset at the Beach\n\n\nCode\nblink([\n    *reversed(get_colors(\"YlOrBr\", 0.4, 0.7)),\n    *reversed(get_colors(\"Blues\", 0.25, 0.7)),\n    *reversed(get_colors(\"Oranges\", 0.05, 0.3)),\n])\n\n\n\n\n\n\n\n\n\nThis is generative art, the art that never ends. I did not know. I started blinking. I must continue blinking forever.\nCreate your world, blink and share what you see."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Plotnine",
    "section": "",
    "text": "plotnine started as an effort to improve the scaling functionality in ggpy_ formally known as “ggplot for python”. It was part of a larger goal to evolve the package into one that supported a full plotting grammar. It turned out that to have a grammar of graphics system we had to just about start anew.\nThe complete guide to what constitutes a “Grammar of Graphics” is Leland Wilkinson’s book The Grammar of Graphics. To create ggplot2_ Hadley Wickham came up with an interpretation termed A layered grammar of graphics 1. Core to the interpretation is a crucial plot building pipeline 2 in ggplot2 that we adopted 3 for plotnine.\nThe R programming language has a rich statistical ecosystem that ggplot2 taps into with ease. In plotnine we have done our best to integrate with the rest of the scientific python ecosystem. Though we feel we could do more on that integration, notwithstanding language differences, users familiar with ggplot2 should be comfortable and productive with plotnine."
  },
  {
    "objectID": "about.html#history-and-objective",
    "href": "about.html#history-and-objective",
    "title": "About Plotnine",
    "section": "",
    "text": "plotnine started as an effort to improve the scaling functionality in ggpy_ formally known as “ggplot for python”. It was part of a larger goal to evolve the package into one that supported a full plotting grammar. It turned out that to have a grammar of graphics system we had to just about start anew.\nThe complete guide to what constitutes a “Grammar of Graphics” is Leland Wilkinson’s book The Grammar of Graphics. To create ggplot2_ Hadley Wickham came up with an interpretation termed A layered grammar of graphics 1. Core to the interpretation is a crucial plot building pipeline 2 in ggplot2 that we adopted 3 for plotnine.\nThe R programming language has a rich statistical ecosystem that ggplot2 taps into with ease. In plotnine we have done our best to integrate with the rest of the scientific python ecosystem. Though we feel we could do more on that integration, notwithstanding language differences, users familiar with ggplot2 should be comfortable and productive with plotnine."
  },
  {
    "objectID": "about.html#built-with",
    "href": "about.html#built-with",
    "title": "About Plotnine",
    "section": "Built with",
    "text": "Built with\n\nmatplotlib - Plotting backend.\npandas - Data handling.\nmizani - Scales framework.\nstatsmodels - For various statistical computations.\nscipy - For various statistical computation procedures."
  },
  {
    "objectID": "about.html#footnotes",
    "href": "about.html#footnotes",
    "title": "About Plotnine",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe Grammar of Graphics has to be interpreted into a form that can be implemented. We were not up to this task.↩︎\nThis is more or less an implementation of what is depicted in Figure 2.2 of The Grammar of Graphics↩︎\nBy adopting a similar pipeline and user API as ggplot2 the other internals referenced within the pipeline look similar.↩︎"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "blog",
    "section": "",
    "text": "Version 0.14.0\n\n\n\n\n\n\n\n\nNov 7, 2024\n\n\nHassan Kibirige\n\n\n\n\n\n\n\n\n\n\n\n\n2024 Plotnine Contest - Last Call\n\n\n\n\n\n\n\n\nJul 22, 2024\n\n\nHassan Kibirige\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "blog/2024/11/version-0.14.0/index.html",
    "href": "blog/2024/11/version-0.14.0/index.html",
    "title": "Version 0.14.0",
    "section": "",
    "text": "Code - Imports\nimport pandas as pd\nfrom plotnine import (\n   aes,\n   ggplot,\n   geom_point,\n   geom_text,\n   scale_x_datetime,\n   theme,\n   theme_set,\n   theme_matplotlib,\n)\ntheme_set(theme_matplotlib());\nWe are happy to announce the release of plotnine v0.14! This version requires python 3.10 or later, a change aligned with NumPy’s deprecation policy.\nThis release also introduces our new hex logo!"
  },
  {
    "objectID": "blog/2024/11/version-0.14.0/index.html#no-more-print-for-plots",
    "href": "blog/2024/11/version-0.14.0/index.html#no-more-print-for-plots",
    "title": "Version 0.14.0",
    "section": "No More print for Plots",
    "text": "No More print for Plots\nOne of the most significant updates in v0.14 is the removal of print as a way to render plot objects. Starting with v0.13, we began deprecating this approach, encouraging users to transition to ggplot.show() for displaying plots.\nNow, print on a plot object will simply return the display size (in pixels) rather than rendering the plot.\n\ndata = pd.DataFrame({\"x\": [1, 2, 3], \"y\": [1, 2, 3 ]})\np = (\n   ggplot(data, aes(\"x\", \"y\"))\n   + geom_point()\n   + theme(figure_size=(4, 2))\n)\n\nprint(p)\nprint(\"There is no figure above this output sentence.\")\n\n&lt;ggplot: (768 x 384)&gt;\nThere is no figure above this output sentence.\n\n\nIn environments with retina output, the exact pixel-size dimensions of the image will be double the display size.\n\np.show()\nprint(\"There is a figure above this output sentence.\")\n\n\n\n\n\n\n\n\nThere is a figure above this output sentence."
  },
  {
    "objectID": "blog/2024/11/version-0.14.0/index.html#enhancements",
    "href": "blog/2024/11/version-0.14.0/index.html#enhancements",
    "title": "Version 0.14.0",
    "section": "Enhancements",
    "text": "Enhancements\nIf you have worked with scales and passed in parameters, you might have encountered an inconvenience: your IDE could not provide meaningful suggestions. Previously, scales used **kwargs to capture common parameters, making it challenging for IDEs to offer specific guidance. With around 100 scales, each with subtle differences, we handled these parameters dynamically to avoid extensive duplication while also generating docstrings automatically.\nWith Python &gt;= 3.10, we have converted scales to dataclasses and leveraged finer controls over keyword-only parameters. This allows us to provide explicit signatures and enables the documentation system to automatically include inherited docstrings for parameters. For example, where an IDE previously displayed something like this:\n\n\n\n\n\nit will now display:"
  },
  {
    "objectID": "blog/2024/11/version-0.14.0/index.html#datetimes-and-timedeltas",
    "href": "blog/2024/11/version-0.14.0/index.html#datetimes-and-timedeltas",
    "title": "Version 0.14.0",
    "section": "Datetimes and Timedeltas",
    "text": "Datetimes and Timedeltas\nWorking with datetimes can be challenging (sometimes even hellish), but we aim to simplify this experience for you. In Python, there are three main types of datetime objects you are likely to encounter:\n\ndatetime.datetime from the standard library\npandas.Timestamp from pandas\nnumpy.datetime64 from numpy\n\nEach of these types covers different ranges and resolutions. The standard library’s datetime has the smallest range, with a constant millisecond (ms) resolution; pandas offers a middle ground with a larger range and nanosecond (ns) resolution; and numpy provides varying resolutions (from years to attoseconds) with different ranges for each resolution. These differences mean that these types are not always directly interchangeable, though we work to make them feel that way. Since our data is stored in a dataframe, any datetime values are converted to the pandas type, which then stores values as numpy types!\nArithmetic operations on each datetime type yield corresponding timedelta types also with their unique resolutions. Certain ranges can exceed valid limits—for example, the range of pandas.Timestamp cannot be represented as a timedelta. This means there are edge cases. But you should not be too worried unless your desired time resolution is dictacted by the vagaries of sub-atomic particles.\nIn this release, you can now expand the limits of datetime and timedelta scales with additional constants.\n\nimport datetime\n\ndata = pd.DataFrame({\n    \"x\": [datetime.datetime(2024, 8, i) for i in range(1, 6)],\n    \"y\": range(5)\n})\n\n(\n    ggplot(data, aes(\"x\", \"y\"))\n    + geom_point()\n    + scale_x_datetime(\n        expand=(0, datetime.timedelta(days=1))\n    )\n    + theme(figure_size=(6, 4))\n)\n\n\n\n\n\n\n\n\nYou can also set the limits through the coordinate system.\ncoord_cartesian(xlim=(datetime(1999, 1, 1), datetime(2006, 1, 1)))\nBeyond datetime and timezone scales, this robustness now applies to any scale created for data types that are not strictly numeric."
  },
  {
    "objectID": "blog/2024/11/version-0.14.0/index.html#integration-with-quarto",
    "href": "blog/2024/11/version-0.14.0/index.html#integration-with-quarto",
    "title": "Version 0.14.0",
    "section": "Integration with Quarto",
    "text": "Integration with Quarto\nplotnine now recognizes figure options specified in the meta section of a Quarto document. These options control the size and format of output images, including fig-dpi, fig-width, fig-height, and fig-format.\nWhile these Quarto options are set as defaults, you can still override them for any specific plot. For example:\n---\ntitle: \"Plotnine Playing well with Quarto\"\nformat: html\njupyter: python3\nfig-dpi: 100\nfig-width: 6\nfig-height: 4\nfig-format: retina\n---\n\n```{python}\n#| label: using-quarto-figure-options\nfrom pandas import pd\nfrom plotnine import aes, geom_point, ggplot, theme\n\ndata = pd.DataFrame({\"x\": range(5), \"y\": range(5)})\n\n(\n  ggplot(data, aes(\"x\", \"y\"))\n  + geom_point()\n)\n```\n\n```{python}\n#| label: overriding-quarto-figure-options\n(\n  ggplot(data, aes(\"x\", \"y\"))\n  + geom_point()\n  + theme(figure_size=(4, 3))\n)\n```\nNote that, at the moment using these options at the chunk level has no effect."
  },
  {
    "objectID": "blog/2024/11/version-0.14.0/index.html#font-aesthetics",
    "href": "blog/2024/11/version-0.14.0/index.html#font-aesthetics",
    "title": "Version 0.14.0",
    "section": "Font Aesthetics",
    "text": "Font Aesthetics\nIn theory, aesthetics represent any properties we can perceive; in practice, only those we can see and vary predictably can be useful aesthetics. Previously, text attributes like family, fontweight, fontstyle, and fontvariant were parameters but not aesthetics, meaning you could not map variables to them. Not anymore, these attributes of a text are now aesthetics!\nfontweight controls the boldness of text. It accepts any number in the range [0, 1000], with common levels being normal (400) and bold (700). Some fonts provide multiple levels of boldness, with up to nine variations, typically at intervals like [100, 200, 300, 400, 500, 600, 700, 800, 900]. A given numeric weight will be mapped to the nearest available level.\nFor instance, here is an example comparing two fonts: Helvetica, which doesn’t have multiple weight levels (the one on your system may differ), and Open Sans (again, the one on your system may differ), which does.\n\nfrom mizani.bounds import rescale\n\ndata = pd.DataFrame({\n    \"x\": range(5),\n    \"y\": range(5),\n    \"w\": rescale(range(5), to=(0, 1000)),\n    \"label\": \"Zero One Two Three Four\".split()\n})\n\n(\n    ggplot(data, aes(\"x\", label=\"label\", fontweight=\"w\"))\n    + geom_text(aes(y=\"y\"), family=\"Helvetica\", colour=\"red\", size=16)\n    + geom_text(aes(y=\"y-.25\"), family=\"Open Sans\", colour=\"green\", size=16)\n)\n\n\n\n\n\n\n\n\nNote that, there is no scale for fontweight so we had to explicitly scale the value to the expected range. Currently you should expect at most 9 levels of bold variations, but pending better support, completely variable fonts are now a thing and will allow continuous variation on the range [0, 1000].\nNote that there is no scale for fontweight, so values must be explicitly scaled to the expected range. And, you can expect a maximum of 9 levels of bold variations. However, with the growing support for variable fonts, continuous variation across the full [0, 1000] range may be possible."
  },
  {
    "objectID": "external-resources.html",
    "href": "external-resources.html",
    "title": "External Resources",
    "section": "",
    "text": "Grammar of graphics with plotnine\n\nA good introductory tutorial on how to use plotnine. It is part of the data visualization track from kaggle’s free online course (https://www.kaggle.com/learn/overview).\n\nPython Plotting for Exploratory Analysis\n\nA list of plots for exploratory data analysis and how they can be created using different libraries.\n\nMaking Plots With plotnine\n\nAn introduction to “grammar of graphics”, and how to use plotnine. This is part of the Data Analysis and Visualization in Python for Ecologists course from Data Carpentry\n\nPlotnine: Grammar of Graphics for Python\n\nA translation of the visualisation chapters from “R for Data Science” to Python using Plotnine and Pandas. This is a comprehensive introduction on the Grammar of Graphics with plotnine."
  },
  {
    "objectID": "external-resources.html#articles",
    "href": "external-resources.html#articles",
    "title": "External Resources",
    "section": "",
    "text": "Grammar of graphics with plotnine\n\nA good introductory tutorial on how to use plotnine. It is part of the data visualization track from kaggle’s free online course (https://www.kaggle.com/learn/overview).\n\nPython Plotting for Exploratory Analysis\n\nA list of plots for exploratory data analysis and how they can be created using different libraries.\n\nMaking Plots With plotnine\n\nAn introduction to “grammar of graphics”, and how to use plotnine. This is part of the Data Analysis and Visualization in Python for Ecologists course from Data Carpentry\n\nPlotnine: Grammar of Graphics for Python\n\nA translation of the visualisation chapters from “R for Data Science” to Python using Plotnine and Pandas. This is a comprehensive introduction on the Grammar of Graphics with plotnine."
  },
  {
    "objectID": "gallery/aes.html",
    "href": "gallery/aes.html",
    "title": "Specifying Aesthetics",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import ggplot, aes, geom_point\n\nMapping variables to the visual properties of a plot.\n\ndf = pd.DataFrame({\n    \"col1\": np.arange(11),\n    \"col2\": np.arange(11)\n})\n\n(\n    ggplot(df, aes(x=\"col1\", y=\"col2\"))\n    + geom_point()\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(df, aes(x=\"col1\", y=\"col2 ** 2\"))\n    + geom_point()\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(df, aes(x=\"col1\", y=\"np.square(col2)\"))\n    + geom_point()\n)\n\n\n\n\n\n\n\n\nThe first two positional arguments are x and y aesthetics. Any other aesthetic must be mapped with a keyword argument.\n\n(\n    ggplot(df, aes(\"col1\", \"np.square(col2)\", color=\"col2\"))\n    + geom_point(size=3)\n)"
  },
  {
    "objectID": "gallery/annotated-heatmap.html",
    "href": "gallery/annotated-heatmap.html",
    "title": "Annotated Heatmap",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_tile,\n    geom_text,\n    scale_y_reverse,\n    scale_y_discrete,\n    scale_fill_brewer,\n    scale_color_manual,\n    coord_equal,\n    theme,\n    theme_void,\n    element_blank,\n    element_rect,\n    element_text,\n)\n\nConditinous data recorded at discrete time intervals over many cycles\nRead data\n\nflights = pd.read_csv(\"data/flights.csv\")\nmonths = flights[\"month\"].unique()  # Months ordered January, ..., December\nflights[\"month\"] = pd.Categorical(flights[\"month\"], categories=months)\nflights.head()\n\n\n\n\n\n\n\n\nyear\nmonth\npassengers\n\n\n\n\n0\n1949\nJanuary\n112\n\n\n1\n1949\nFebruary\n118\n\n\n2\n1949\nMarch\n132\n\n\n3\n1949\nApril\n129\n\n\n4\n1949\nMay\n121\n\n\n\n\n\n\n\n\n# We use 'factor(year)' -- a discrete -- instead of 'year' so that all the years\n# are displayed along the x-axis.\n# The .95s create spacing between the tiles.\n\n(\n    ggplot(flights, aes(\"factor(year)\", \"month\", fill=\"passengers\"))\n    + geom_tile(aes(width=0.95, height=0.95))\n    + geom_text(aes(label=\"passengers\"), size=9)\n)\n\n\n\n\n\n\n\n\nThat looks like what we want, but it could do with a few tweaks. First the contrast between the tiles and the text is not good for the lower passenger numbers. We use pd.cut to partition the number of passengers into two discrete groups.\n\nflights[\"p_group\"] = pd.cut(\n    flights[\"passengers\"], (0, 300, 1000), labels=(\"low\", \"high\")\n)\nflights.head()\n\n\n\n\n\n\n\n\nyear\nmonth\npassengers\np_group\n\n\n\n\n0\n1949\nJanuary\n112\nlow\n\n\n1\n1949\nFebruary\n118\nlow\n\n\n2\n1949\nMarch\n132\nlow\n\n\n3\n1949\nApril\n129\nlow\n\n\n4\n1949\nMay\n121\nlow\n\n\n\n\n\n\n\n\n(\n    ggplot(flights, aes(\"factor(year)\", \"month\", fill=\"passengers\"))\n    + geom_tile(aes(width=0.95, height=0.95))\n    + geom_text(aes(label=\"passengers\", color=\"p_group\"), size=9, show_legend=False)  # modified\n    + scale_color_manual([\"white\", \"black\"])  # new\n)\n\n\n\n\n\n\n\n\nLast tweaks, put January at the top and remove the axis ticks and plot background.\n\n(\n    ggplot(flights, aes(\"factor(year)\", \"month\", fill=\"passengers\"))\n    + geom_tile(aes(width=0.95, height=0.95))\n    + geom_text(aes(label=\"passengers\", color=\"p_group\"), size=9, show_legend=False)\n    + scale_color_manual([\"white\", \"black\"])  # new\n    + scale_y_discrete(limits=months[::-1])  # new\n    + theme(  # new\n        axis_ticks=element_blank(),\n        panel_background=element_rect(fill=\"white\"),\n    )\n)\n\n\n\n\n\n\n\n\nYou can get similar results if you replace\n + geom_tile(aes(width=.95, height=.95))\n + geom_text(aes(label='passengers', color='p_group'), size=9, show_legend=False)\nwith\n+ geom_label(aes(label='passengers', color='p_group'), size=9, show_legend=False)\nCredit: This example is a recreation of this seaborn example."
  },
  {
    "objectID": "gallery/coal-production.html",
    "href": "gallery/coal-production.html",
    "title": "Coal Production",
    "section": "",
    "text": "Plotnine is a visualisation library that brings the Grammar of Graphics to Python, and the 2024 Plotnine Contest aims to bring the community together to create and share with others great plotnine examples! In this tutorial, I’ll be walking you through the process of creating the following plot for my entry into the plotnine contest!\nThis entry for the plotnine contest was inspired by a visualisation I previously created using {ggplot2} in R for #TidyTuesday. You can see the original R version on GitHub."
  },
  {
    "objectID": "gallery/coal-production.html#python-libraries",
    "href": "gallery/coal-production.html#python-libraries",
    "title": "Coal Production",
    "section": "Python libraries",
    "text": "Python libraries\nLet’s start by loading the Python libraries that we’ll need to create the plot. Beyond plotnine for actually plotting, we also need pandas for data wrangling, textwrap for wrapping long strings of text, matplotlib.pyplot for some additional plot tinkering, highlight_text for adding coloured and bold text to annotations, and matplotlib.font_manager for dealing with fonts.\n\nimport plotnine as gg\nimport pandas as pd\nimport textwrap\nimport matplotlib.pyplot as plt\nimport matplotlib.font_manager"
  },
  {
    "objectID": "gallery/coal-production.html#reading-in-data",
    "href": "gallery/coal-production.html#reading-in-data",
    "title": "Coal Production",
    "section": "Reading in data",
    "text": "Reading in data\nThe data set we’ll be using is the Carbon Majors emissions data. As I mentioned earlier, this dataset was used as a #TidyTuesday dataset. This means we can read the data in directly from the #TidyTuesday GitHub repository:\n\nemissions = pd.read_csv(\n    'https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-05-21/emissions.csv')\n\nYou can download the emissions.csv file from GitHub if you prefer to load the data from a local file.\nCarbon Majors is a database of historical production data from 122 of the world’s largest oil, gas, coal, and cement producers. The dataset has 12,551 rows and 7 columns with the following variables: year, parent_entity, parent_type, commodity, production_value, production_unit, and total_emissions_MtCO2e. The #TidyTuesday README file has more information on what the variables are.\n\n\n\n\n\n\nCarbon Majors Data\n\n\n\nThe original data can be downloaded from carbonmajors.org/Downloads. The Carbon Majors dataset is available for download and for non-commercial use, subject to InfluenceMap’s Terms and Conditions. The version used in this plot was downloaded in May 2024."
  },
  {
    "objectID": "gallery/coal-production.html#data-wrangling",
    "href": "gallery/coal-production.html#data-wrangling",
    "title": "Coal Production",
    "section": "Data wrangling",
    "text": "Data wrangling\nFor this plot, let’s focus on emissions relating to coal only. There are six different types of coal in the data set and we’ll filter the data to keep only rows relating to those six types of coal. We’ll also remove the word \"Coal\" from each of the category labels since it will be obvious they are types of coal.\n\n# Prep data for plotting\nplot_data = emissions[\n    emissions['commodity'].isin([\n        'Sub-Bituminous Coal', 'Metallurgical Coal', 'Bituminous Coal',\n        'Thermal Coal', 'Anthracite Coal', 'Lignite Coal'\n    ])\n].copy()\nplot_data['commodity'] = plot_data['commodity'].str.replace(' Coal', '')\n\nWe’ll also focus on production levels, so we’ll keep only the columns we need to plot: year, type of coal (commodity), and amount produced (production_value). The data README tells us that the production_value column is given in million tonnes for coal production.\nWe need to sum up production across the different entities to get a total production value per year. We’ll also filter the data to consider only the years since 1900:\n\n# Total production per year since 1900\nplot_data = plot_data[['year', 'commodity', 'production_value']]\nplot_data = plot_data.groupby(['year', 'commodity'], as_index=False).agg(\n    {'production_value': 'sum'}).rename(columns={'production_value': 'n'})\nplot_data = plot_data[plot_data['year'] &gt;= 1900]\n\nLet’s also sort the categories based on their production amount in the last year of the data (2022), to make our plot a little bit clearer:\n\n# Sort values by 2022 levels\norders = plot_data[plot_data['year'] == 2022].sort_values(\n    by='n', ascending=False)['commodity']\nplot_data['commodity'] = pd.Categorical(\n    plot_data['commodity'],\n    categories=orders,\n    ordered=True)\n\nWe’re going to be adding some annotations to the plot, and one of the annotations will show the first year that production exceeded 100 million tonnes per year. Let’s calculate that year (and therefore the position of the annotation) in a data-driven way:\n\n# Values for annotations\nexceeds100 = plot_data.groupby('year')['n'].sum()\nexceeds100 = exceeds100[exceeds100 &gt; 100].index.min()\n\nI often find that traditional grid lines make a plot look a little bit too busy. Instead, we’re going to create our own grid lines by drawing some vertical lines. To do this, let’s create some data with the desired positions of where the vertical lines hit the x-axis:\n\n# Create data for x-axis labels\nsegment_data = pd.DataFrame({\n    'year': list(range(1900, 2021, 20))\n})\n\nWe’ll do something similar with the y-axis, by creating custom labels that encompass both the values and the units, instead of having a separate y-axis title. We’ll put these values on the right hand side of the plot (rather than the left as normal) because this is often where people’s eyes end up looking when they’re reading a chart of data over time.\n\nNote the \\n creates a linebreak in the text.\n\n\n# y-axis labels\ny_axis_data = pd.DataFrame({\n    'value': [0, 2000, 4000, 6000, 8000],\n    'label': ['0', '2,000', '4,000', '6,000', '8,000\\nmillion\\ntonnes']\n})"
  },
  {
    "objectID": "gallery/coal-production.html#colour-font-and-text-variables",
    "href": "gallery/coal-production.html#colour-font-and-text-variables",
    "title": "Coal Production",
    "section": "Colour, font, and text variables",
    "text": "Colour, font, and text variables\nTo make it easier to change up colour schemes, it’s useful to define colours as variables. Here, we define a background colour (bg_col), a text colour (text_col), and a colour palette (col_palette) that will be used to colour the different areas.\n\n# Define background colour, text colour, and colour palette\nbg_col = '#FFFFFA'\ntext_col = '#0D5C63'\ncol_palette = [\n    '#E58606',\n    '#5D69B1',\n    '#52BCA3',\n    '#99C945',\n    '#CC61B0',\n    '#24796C']\n\nSimilarly, we can define variable(s) for which font we want to use. But we also need to make sure that the font we want is actually available. We can get a list of available fonts using matplotlib.font_manager.findSystemFonts().\n\n# Available fonts\nflist = matplotlib.font_manager.findSystemFonts()\n\nIf 'Arial' is installed, we’ll use that as the main font (body_font) and if not, we’ll use the default sans serif font.\n\n# Check if 'Arial' in list of installed fonts\nflist = ''.join(flist).lower()\nif 'arial' in flist:\n    body_font = 'Arial'\nelse:\n    body_font = 'sans'\n\n\nIf you’re running this code on your own laptop, feel free to choose a different font!\n\nLet’s also create some variables to store our title and subtitle text. Although these could be passed straight into title and subtitle arguments in the plotting function, keeping them separate leaves the plotting code looking a little bit cleaner. The subtitle text is also quite long, so we’ll use textwrap.wrap() to wrap the text to 50 characters (without breaking words onto multiple lines):\n\n# title, subtitle\ntitle_text = 'Coal production since 1900'\nst = 'Carbon Majors is a database of historical production data from 122 of the world’s largest oil, gas, coal, and cement producers. This data is used to quantify the direct operational emissions and emissions from the combustion of marketed products that can be attributed to these entities.'\nwrapped_subtitle = '\\n'.join(textwrap.wrap(st, width=50))\n\nInstead of a traditional legend, we’re going to use coloured text to show which categories the different colours map to. So let’s prepare some text that we’ll use later in functions from the highlight-text library.\nWe create a string as normal with the text we want to display, then format words within the strings in the following way:\n\n'Normal text then &lt;coloured text::{\"color\": \"red\"}&gt;'\n\nInstead, of \"red\" we can use our different hex colours. We also add line breaks using \\n. We can add some text formatting to the caption in a similar way. Instead of colouring the text, we’ll make some of it bold. Therefore, we use \"fontweight\": \"bold\" instead of \"color\": \"red\":\n\n# annotation labels\ncoal_types_label = 'Total coal production includes\\nproduction of &lt;Bituminous::{\"color\": \"#E58606\"}&gt;,\\n&lt;Sub-bituminous::{\"color\": \"#5D69B1\"}&gt;, &lt;Metallurgical::{\"color\": \"#52BCA3\"}&gt;,\\n&lt;Lignite::{\"color\": \"#99C945\"}&gt;, &lt;Anthracite::{\"color\": \"#CC61B0\"}&gt;, and &lt;Thermal::{\"color\": \"#24796C\"}&gt;\\ncoal. Bituminous accounts\\nfor around half.'\n\n# caption\ncap = '&lt;Data::{\"fontweight\": \"bold\"}&gt;: Carbon Majors\\n&lt;Graphic::{\"fontweight\": \"bold\"}&gt;: Nicola Rennie (@nrennie)'\n\nNow we’re ready to plot!"
  },
  {
    "objectID": "gallery/coal-production.html#applying-text-styling-with-highlight-text",
    "href": "gallery/coal-production.html#applying-text-styling-with-highlight-text",
    "title": "Coal Production",
    "section": "Applying text styling with highlight-text",
    "text": "Applying text styling with highlight-text\nWe start by converting from a plotnine plot to a matplotlib plot using the draw() function. We can also set the size of the plot (and resolution if you want using fig.set_dpi(300)). The plt.gca() extracts the axes from the existing plotnine plot.\nThe ax_text() function from highlight-text adds text at the desired x- and y- coordinates, where the coordinates are based on the data range in the original plot. The vsep argument controls the line spacing, and fontname is used instead of family, but otherwise the arguments work similarly as in plotnine. We use the ax_text() function twice - once to add the coloured annotation, and once to add the caption. Finally, we show the plot.\n\n# Add coloured text with matplotlib and highlight-text\n# Convert to matplotlib and set plot options\nfig = p.draw()\nfig.set_size_inches(8, 6, forward=True)\nax = plt.gca()\n# add coloured text to annotation\nht.ax_text(\n    1977,\n    9400,\n    coal_types_label,\n    vsep=3,\n    color=text_col,\n    fontname=body_font,\n    fontsize=9,\n    va='top')\n# add caption\nht.ax_text(1900, -2300, cap, color=text_col,\n           fontname=body_font, fontsize=7.5, va='top')\nplt.show()\n\nIf we want to save our plot to a file, we can use plt.savefig() and specify the resolution and bbox_inches='tight' to avoid any extra whitespace around the edges of the plot.\n\n# Save image\nplt.savefig('plot.png', dpi=300, bbox_inches='tight')\n\nCheck out the plotnine Gallery for more examples of plots created using plotnine!\n\nYou can also read this tutorial on my website!"
  },
  {
    "objectID": "gallery/geom_area.html",
    "href": "gallery/geom_area.html",
    "title": "Area Under Line",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    geom_area,\n    geom_line,\n    scale_x_date,\n    scale_y_continuous,\n    theme_linedraw,\n    theme_set,\n)\nfrom plotnine.data import economics\n\n# Set default theme\ntheme_set(theme_linedraw())\n\n\n(\n    ggplot(economics, aes(x=\"date\", y=\"unemploy\"))\n    + geom_line()\n    + geom_area(fill=\"#e5c8d6\", color=\"#9e2f68\")\n    + scale_x_date(expand=(0, 0), date_labels=\"%Y\")\n    + scale_y_continuous(expand=(0, 0, 0.1, 0))\n    + theme_linedraw()\n)"
  },
  {
    "objectID": "gallery/geom_boxplot.html",
    "href": "gallery/geom_boxplot.html",
    "title": "Box And Whiskers",
    "section": "",
    "text": "import pandas as pd\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_boxplot,\n    geom_jitter,\n    scale_x_discrete,\n    coord_flip,\n)\n\nThe boxplot compactly displays the distribution of a continuous variable.\nRead more: + wikipedia + ggplot2 docs\n\nflights = pd.read_csv(\"data/flights.csv\")\nflights.head()\n\n\n\n\n\n\n\n\nyear\nmonth\npassengers\n\n\n\n\n0\n1949\nJanuary\n112\n\n\n1\n1949\nFebruary\n118\n\n\n2\n1949\nMarch\n132\n\n\n3\n1949\nApril\n129\n\n\n4\n1949\nMay\n121\n\n\n\n\n\n\n\nBasic boxplot\n\nmonths = [month[:3] for month in flights.month[:12]]\nprint(months)\n\n['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n\n\n\nA Basic Boxplot\n\n(\n    ggplot(flights)\n    + geom_boxplot(aes(x=\"factor(month)\", y=\"passengers\"))\n    + scale_x_discrete(labels=months, name=\"month\")  # change ticks labels on OX\n)\n\n\n\n\n\n\n\n\nHorizontal boxplot\n\n(\n    ggplot(flights)\n    + geom_boxplot(aes(x=\"factor(month)\", y=\"passengers\"))\n    + coord_flip()\n    + scale_x_discrete(\n        labels=months[::-1],\n        limits=flights.month[11::-1],\n        name=\"month\",\n    )\n)\n\n\n\n\n\n\n\n\nBoxplot with jittered points:\n\n(\n    ggplot(flights, aes(x=\"factor(month)\", y=\"passengers\"))\n    + geom_boxplot()\n    + geom_jitter()\n    + scale_x_discrete(labels=months, name=\"month\")  # change ticks labels on OX\n)"
  },
  {
    "objectID": "gallery/geom_density.html",
    "href": "gallery/geom_density.html",
    "title": "Shaded Density Plot",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    after_stat,\n    geom_density,\n    geom_histogram,\n    geom_vline,\n    geom_rect,\n    labs,\n    annotate,\n    theme_tufte,\n)\nfrom plotnine.data import mpg\n\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nThe defaults are not exactly beautiful, but still quite clear.\n\nBasic Density Plot\n\n(\n    ggplot(mpg, aes(x=\"cty\"))\n    + geom_density()\n)\n\n\n\n\n\n\n\n\nPlotting multiple groups is straightforward, but as each group is plotted as an independent PDF summing to 1, the relative size of each group will be normalized.\n\n\nDensity Plot with Groups\n\n(\n    ggplot(mpg, aes(x=\"cty\", color=\"drv\", fill=\"drv\"))\n    + geom_density(alpha=0.1)\n)\n\n\n\n\n\n\n\n\nTo plot multiple groups and scale them by their relative size, you can map the y aesthetic to 'count' (calculated by stat_density).\n\n(\n    ggplot(mpg, aes(x=\"cty\", color=\"drv\", fill=\"drv\"))\n    + geom_density(aes(y=after_stat(\"count\")), alpha=0.1)\n)\n\n\n\n\n\n\n\n\n\n\nDensity Plots + Histograms\nTo overlay a histogram onto the density, the y aesthetic of the density should be mapped to the 'count' scaled by the binwidth of the histograms.\nWhy?\nThe count calculated by stat_density is \\(count = density * n\\) where n is the number of points . The density curves have an area of 1 and have no information about the absolute frequency of the values along curve; only the relative frequencies. The count curve reveals the absolute frequencies. The scale of this count corresponds to the count calculated by the stat_bin for the histogram when the bins are 1 unit wide i.e. binwidth=1. The count * binwidth curve matches the scale of counts for the histogram for a give binwidth.\n\nbinwidth = 2  # The same for geom_density and geom_histogram\n\n(\n    ggplot(mpg, aes(x=\"cty\", color=\"drv\", fill=\"drv\"))\n    + geom_density(aes(y=after_stat(\"count*binwidth\")), alpha=0.1)\n    + geom_histogram(\n        aes(fill=\"drv\", y=after_stat(\"count\")),\n        binwidth=binwidth,\n        color=\"none\",\n        alpha=0.5,\n    )\n    # It is the histogram that gives us the meaningful y axis label\n    # i.e. 'count' and not 'count*2'\n    + labs(y=\"count\")\n)\n\n\n\n\n\n\n\n\n\n\nShaded Range Under a Density Plot\nExtending geom_density to create an effect of a shaded range\nCreate some data and plot the density\n\nn = 101\ndf = pd.DataFrame({\"x\": np.arange(n)})\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n)\n\n\n\n\n\n\n\n\nSuppose we want to mark a region as special e.g. (40, 60), we can use vertical lines to annotate it.\n\nregion = (40, 60)\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n    + annotate(geom_vline, xintercept=region)  # new line\n)\n\n\n\n\n\n\n\n\nTo make it standout more we can highlight. To do that, the first thought is to use a rectangle.\n\nregion = (40, 60)\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n    + annotate(\n        geom_rect, xmin=region[0], xmax=region[1], ymin=0, ymax=float(\"inf\"), alpha=0.5\n    )  # new annotation layer\n    + annotate(geom_vline, xintercept=region)\n)\n\n\n\n\n\n\n\n\nSince y upper-bound varies along the curve, a rectangular highlight has to stretch up to the top of the panel.\nTo hightlight only within the density curve, we have to use a second density curve. We need to calculate the density as normal, but just before the curve & region are plotted, we should keep only the region we want.\nWe create our own geom_density_highlight and override the setup_data method. First, we override but do nothing, we only inspect the data to see what we have to work with.\n\n# new class\nclass geom_density_highlight(geom_density):\n    def setup_data(self, data):\n        data = super().setup_data(data)\n        print(data)\n        return data\n\n\nregion = (40, 60)\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n    + geom_density_highlight(fill=\"black\", alpha=0.5)  # new line\n    + annotate(geom_vline, xintercept=region)\n)\n\n      PANEL     count   density  group    n    scaled           x         y  \\\n0         1  0.519038  0.005139     -1  101  0.519039    0.000000  0.005139   \n1         1  0.522757  0.005176     -1  101  0.522758    0.097752  0.005176   \n2         1  0.526473  0.005213     -1  101  0.526474    0.195503  0.005213   \n3         1  0.530187  0.005249     -1  101  0.530188    0.293255  0.005249   \n4         1  0.533899  0.005286     -1  101  0.533900    0.391007  0.005286   \n...     ...       ...       ...    ...  ...       ...         ...       ...   \n1019      1  0.533899  0.005286     -1  101  0.533900   99.608993  0.005286   \n1020      1  0.530187  0.005249     -1  101  0.530188   99.706745  0.005249   \n1021      1  0.526473  0.005213     -1  101  0.526474   99.804497  0.005213   \n1022      1  0.522757  0.005176     -1  101  0.522758   99.902248  0.005176   \n1023      1  0.519038  0.005139     -1  101  0.519039  100.000000  0.005139   \n\n      ymin      ymax  \n0        0  0.005139  \n1        0  0.005176  \n2        0  0.005213  \n3        0  0.005249  \n4        0  0.005286  \n...    ...       ...  \n1019     0  0.005286  \n1020     0  0.005249  \n1021     0  0.005213  \n1022     0  0.005176  \n1023     0  0.005139  \n\n[1024 rows x 10 columns]\n\n\n\n\n\n\n\n\n\nThe highlight has filled the whole region, but the printed data suggests that we can limit the rows to those where x column is within our region.\n\nclass geom_density_highlight(geom_density):\n    # new method\n    def __init__(self, *args, region=(-np.inf, np.inf), **kwargs):\n        super().__init__(*args, **kwargs)\n        self.region = region\n\n    def setup_data(self, data):\n        data = super().setup_data(data)\n        s = f\"{self.region[0]} &lt;= x &lt;= {self.region[1]}\"  # new line\n        data = data.query(s).reset_index(drop=True)  # new line\n        return data\n\n\nregion = (40, 60)\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n    + geom_density_highlight(region=region, fill=\"black\", alpha=0.5)  # modified line\n    + annotate(geom_vline, xintercept=region)\n)\n\n\n\n\n\n\n\n\nThat is it, but we can make it look better.\n\nclass geom_density_highlight(geom_density):\n    def __init__(self, *args, region=(-np.inf, np.inf), **kwargs):\n        super().__init__(*args, **kwargs)\n        self.region = region\n\n    def setup_data(self, data):\n        data = super().setup_data(data)\n        s = f\"{self.region[0]} &lt;= x &lt;= {self.region[1]}\"\n        data = data.query(s).reset_index(drop=True)\n        return data\n\n\nregion = (40, 60)\nteal = \"#029386\"\n\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density_highlight(region=region, fill=teal + \"88\", color=\"none\")\n    + geom_density(fill=teal + \"44\", color=teal, size=0.7)\n    + annotate(geom_vline, xintercept=region, color=teal, size=0.7)\n    + theme_tufte()\n)\n\n\n\n\n\n\n\n\nThis example was motivated by a question from github user Rishika-Ravindran."
  },
  {
    "objectID": "gallery/geom_line.html",
    "href": "gallery/geom_line.html",
    "title": "Line Plot",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    geom_line,\n    facet_wrap,\n    labs,\n    scale_x_datetime,\n    element_text,\n    theme_538\n)\nfrom plotnine.data import meat\n\ngeom_line() connects the dots, and is useful for time series data.\n\nmeat.head()\n\n\n\n\n\n\n\n\ndate\nbeef\nveal\npork\nlamb_and_mutton\nbroilers\nother_chicken\nturkey\n\n\n\n\n0\n1944-01-01\n751.0\n85.0\n1280.0\n89.0\nNaN\nNaN\nNaN\n\n\n1\n1944-02-01\n713.0\n77.0\n1169.0\n72.0\nNaN\nNaN\nNaN\n\n\n2\n1944-03-01\n741.0\n90.0\n1128.0\n75.0\nNaN\nNaN\nNaN\n\n\n3\n1944-04-01\n650.0\n89.0\n978.0\n66.0\nNaN\nNaN\nNaN\n\n\n4\n1944-05-01\n681.0\n106.0\n1029.0\n78.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\nMake it tidy.\n\nmeat_long = meat.melt(\n    id_vars=\"date\",\n    value_vars=[\"beef\", \"veal\", \"pork\", \"lamb_and_mutton\", \"broilers\", \"turkey\"],\n    var_name=\"animal\",\n    value_name=\"weight\"\n).dropna()\n\nmeat_long.head()\n\n\n\n\n\n\n\n\ndate\nanimal\nweight\n\n\n\n\n0\n1944-01-01\nbeef\n751.0\n\n\n1\n1944-02-01\nbeef\n713.0\n\n\n2\n1944-03-01\nbeef\n741.0\n\n\n3\n1944-04-01\nbeef\n650.0\n\n\n4\n1944-05-01\nbeef\n681.0\n\n\n\n\n\n\n\nFirst try\n\np = (\n    ggplot(meat_long, aes(x=\"date\", y=\"weight\"))\n    + geom_line()\n)\np\n\n\n\n\n\n\n\n\nIt looks crowded because each there is more than one monthly entry at each x-point. We can get a single trend line by getting a monthly aggregate of the weights.\n\nmeat_long_monthly_agg = meat_long.groupby(\"date\").agg({\"weight\": \"sum\"}).reset_index()\nmeat_long_monthly_agg\n\n\n\n\n\n\n\n\ndate\nweight\n\n\n\n\n0\n1944-01-01\n2205.0\n\n\n1\n1944-02-01\n2031.0\n\n\n2\n1944-03-01\n2034.0\n\n\n3\n1944-04-01\n1783.0\n\n\n4\n1944-05-01\n1894.0\n\n\n...\n...\n...\n\n\n955\n2023-08-01\n9319.1\n\n\n956\n2023-09-01\n8586.1\n\n\n957\n2023-10-01\n9452.5\n\n\n958\n2023-11-01\n8951.1\n\n\n959\n2023-12-01\n8555.1\n\n\n\n\n960 rows × 2 columns\n\n\n\n\nA Single Trend Line\n\n(\n    ggplot(meat_long_monthly_agg, aes(x=\"date\", y=\"weight\"))\n    + geom_line()\n)\n\n\n\n\n\n\n\n\nAdd some style\n\n(\n    ggplot(meat_long_monthly_agg, aes(x=\"date\", y=\"weight\"))\n    + geom_line()\n    # Styling\n    + scale_x_datetime(date_breaks=\"10 years\", date_labels=\"%Y\")\n    + theme_538()\n)\n\n\n\n\n\n\n\n\nOr we can group by the animals to get a trend line for each animal\n\n\nMultiple Trend Lines\n\n(\n    ggplot(meat_long, aes(x=\"date\", y=\"weight\", group=\"animal\"))\n    + geom_line()\n    # Styling\n    + scale_x_datetime(date_breaks=\"10 years\", date_labels=\"%Y\")\n    + theme_538()\n)\n\n\n\n\n\n\n\n\nMake each group be a different color.\n\n(\n    ggplot(meat_long, aes(x=\"date\", y=\"weight\", color=\"animal\"))\n    + geom_line()\n    # Styling\n    + scale_x_datetime(date_breaks=\"10 years\", date_labels=\"%Y\")\n    + theme_538()\n)\n\n\n\n\n\n\n\n\n\n\nA Trend Line Per Facet\nPlot each group on a separate panel. The legend is no longer required and we adjust to the smaller panels by reducing the size of the line, size of the text and the number of grid lines.\n\ndef titled(strip_title):\n    return \" \".join(s.title() if s != \"and\" else s for s in strip_title.split(\"_\"))\n\n(\n    ggplot(meat_long, aes(\"date\", \"weight\", color=\"animal\"))\n    + geom_line(size=.5, show_legend=False)\n    + facet_wrap(\"animal\", labeller=titled)\n    + scale_x_datetime(date_breaks=\"20 years\", date_labels=\"%Y\")\n    + labs(\n        x=\"Date\",\n        y=\"Weight (million pounds)\",\n        title=\"Meat Production\"\n    )\n    + theme_538(base_size=9)\n)"
  },
  {
    "objectID": "gallery/geom_point.html",
    "href": "gallery/geom_point.html",
    "title": "Bubbles",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    theme_matplotlib,\n    theme_set,\n)\n\n# Set default theme for all the plots\ntheme_set(theme_matplotlib())\n\n\nnp.random.seed(123)\nn = 150\n\ndf = pd.DataFrame({\n    \"x\": np.random.randint(0, 101, n),\n    \"y\": np.random.randint(0, 101, n),\n    \"var1\": np.random.randint(1, 6, n),\n    \"var2\": np.random.randint(0, 11, n)\n})\n\n\n(\n    ggplot(df, aes(\"x\", \"y\"))\n    + geom_point()\n)\n\n\n\n\n\n\n\n\n\nColoured Point Bubbles\n\n(\n    ggplot(df, aes(\"x\", \"y\", size=\"var1\"))\n    + geom_point(aes(color=\"var2\"))\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(df, aes(\"x\", \"y\", size=\"var1\"))\n    + geom_point(aes(fill=\"var2\"), stroke=0, alpha=0.5)\n    + geom_point(aes(color=\"var2\"), fill=\"none\")\n)"
  },
  {
    "objectID": "gallery/geom_smooth.html",
    "href": "gallery/geom_smooth.html",
    "title": "Smoothed Conditional Means",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_point, geom_smooth, labs, theme_matplotlib, theme_set\nfrom plotnine.data import mpg\n\ntheme_set(theme_matplotlib())\n\nAids the eye in seeing patterns in the presence of overplotting.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_smooth()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nUse span to control the “wiggliness” of the default loess smoother. The span is the fraction of points used to fit each local regression: small numbers make a wigglier curve, larger numbers make a smoother curve.\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_smooth(span=0.3)\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can remove confidence interval around smooth with se=False:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_smooth(span=0.3, se=False)\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nInstead of a loess smooth, you can use any other modelling function:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_smooth(method=\"lm\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\n\nPoints & Linear Models\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\", color=\"factor(drv)\"))\n    + geom_point()\n    + geom_smooth(method=\"lm\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)"
  },
  {
    "objectID": "gallery/index.html",
    "href": "gallery/index.html",
    "title": "Plotnine Gallery",
    "section": "",
    "text": "Add Counts And Percentages\n\n\n\nbar chart\n\ntutorial\n\n\n\n\n\n\n\n\n\n\n\nAn Elaborate Range Plot\n\n\n\nsegment\n\n\n\n\n\n\n\n\n\n\n\nAnnotated Heatmap\n\n\n\nheatmap\n\ntext\n\n\n\n\n\n\n\n\n\n\n\nAnscombe’s Quartet\n\n\n\nscatter plot\n\ncontest\n\n\n\n\n\n\n\n\n\n\n\nArea Under Line\n\n\n\narea\n\n\n\n\n\n\n\n\n\n\n\nBox And Whiskers\n\n\n\nbox plot\n\n\n\n\n\n\n\n\n\n\n\nBubbles\n\n\n\nscatter plot\n\n\n\n\n\n\n\n\n\n\n\nCoal Production\n\n\n\narea\n\ncontest\n\n\n\n\n\n\n\n\n\n\n\nHeatmap\n\n\n\nheatmap\n\n\n\n\n\n\n\n\n\n\n\nHistogram\n\n\n\nhistogram\n\ntheme\n\n\n\n\n\n\n\n\n\n\n\nHorizontal Bar Chart\n\n\n\nbar chart\n\n\n\n\n\n\n\n\n\n\n\nLine Plot\n\n\n\nline plot\n\nfacet\n\ntheme\n\n\n\n\n\n\n\n\n\n\n\nManipulating Date Breaks and Labels\n\n\n\ndate\n\ntutorial\n\n\n\n\n\n\n\n\n\n\n\nMondrian\n\n\n\nart\n\ncontest\n\n\n\n\n\n\n\n\n\n\n\nNorth Carolina\n\n\n\nmap\n\n\n\n\n\n\n\n\n\n\n\nPeriodic Table\n\n\n\nheatmap\n\n\n\n\n\n\n\n\n\n\n\nRank Plot\n\n\n\n\n\n\n\n\n\n\nScatter Plot Shapes\n\n\n\nscatter plot\n\n\n\n\n\n\n\n\n\n\n\nShaded Density Plot\n\n\n\ndensity plot\n\n\n\n\n\n\n\n\n\n\n\nSmoothed Conditional Means\n\n\n\nscatter plot\n\nsmooth\n\n\n\n\n\n\n\n\n\n\n\nSpecifying Aesthetics\n\n\n\nscatter plot\n\n\n\n\n\n\n\n\n\n\n\nSpiral Animation\n\n\n\nanimation\n\n\n\n\n\n\n\n\n\n\n\nStacked Bar Chart\n\n\n\nbar chart\n\ntext\n\n\n\n\n\n\n\n\n\n\n\nText Outside Panel\n\n\n\ntext\n\n\n\n\n\n\n\n\n\n\n\nThe Territories of Westeros\n\n\n\nmap\n\n\n\n\n\n\n\n\n\n\n\nTheming Specific Elements\n\n\n\ntheme\n\n\n\n\n\n\n\n\n\n\n\nTrend Line\n\n\n\nscatter plot\n\nline plot\n\nfacet\n\n\n\n\n\n\n\n\n\n\n\nTwo Variable Bar Plot\n\n\n\nbar chart\n\ntext\n\n\n\n\n\n\n\n\n\n\n\nUsing Letters As Shapes\n\n\n\ntext\n\ntutorial\n\n\n\n\n\n\n\n\n\n\n\nUsing after_scale()\n\n\n\n\n\n\n\n\n\n\n\n\n\nViolins, Boxes, Points & Lines\n\n\n\nviolin plot\n\nsegment\n\n\n\n\n\n\n\n\n\n\n\nWeather Forecast\n\n\n\nrange\n\ncontest\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "gallery/manipulating-date-breaks-and-date-labels.html",
    "href": "gallery/manipulating-date-breaks-and-date-labels.html",
    "title": "Manipulating Date Breaks and Labels",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    scale_x_datetime,\n    labs,\n    theme_set,\n    theme_linedraw,\n)\nfrom plotnine.data import economics\n\nfrom mizani.breaks import date_breaks\nfrom mizani.formatters import date_format\n\ntheme_set(theme_linedraw())  # default theme\n\nUsing the economics dataset\n\neconomics.head()\n\n\n\n\n\n\n\n\ndate\npce\npop\npsavert\nuempmed\nunemploy\n\n\n\n\n0\n1967-07-01\n507.4\n198712\n12.5\n4.5\n2944\n\n\n1\n1967-08-01\n510.5\n198911\n12.5\n4.7\n2945\n\n\n2\n1967-09-01\n516.3\n199113\n11.7\n4.6\n2958\n\n\n3\n1967-10-01\n512.9\n199311\n12.5\n4.9\n3143\n\n\n4\n1967-11-01\n518.1\n199498\n12.5\n4.7\n3066\n\n\n\n\n\n\n\nHow does the saving rate vary with time?\n\n(\n    ggplot(economics)\n    + geom_point(aes(\"date\", \"psavert\"))\n    + labs(y=\"personal saving rate\")\n)\n\n\n\n\n\n\n\n\nYikes! the calculated breaks are awful, we need to intervene. We do so using the date_breaks and date_format functions from mizani.\nSet breaks every 10 years\n\n(\n    ggplot(economics)\n    + geom_point(aes(\"date\", \"psavert\"))\n    + scale_x_datetime(breaks=date_breaks(\"10 years\"))  # new\n    + labs(y=\"personal saving rate\")\n)\n\n\n\n\n\n\n\n\nThat is better. Since all the breaks are at the beginning of the year, we can omit the month and day. Using date_format we override the format string. For more on the options for the format string see the strftime behavior.\n\n(\n    ggplot(economics)\n    + geom_point(aes(\"date\", \"psavert\"))\n    + scale_x_datetime(\n        breaks=date_breaks(\"10 years\"), labels=date_format(\"%Y\")\n    )  # modified\n    + labs(y=\"personal saving rate\")\n)\n\n\n\n\n\n\n\n\nWe can achieve the same result with a custom formating function.\n\ndef custom_date_format1(breaks):\n    \"\"\"\n    Function to format the date\n    \"\"\"\n    return [x.year if x.month == 1 and x.day == 1 else \"\" for x in breaks]\n\n\n(\n    ggplot(economics)\n    + geom_point(aes(\"date\", \"psavert\"))\n    + scale_x_datetime(  # modified\n        breaks=date_breaks(\"10 years\"), labels=custom_date_format1\n    )\n    + labs(y=\"personal saving rate\")\n)\n\n\n\n\n\n\n\n\nWe can use a custom formatting function to get results that are not obtainable with the date_format function. For example if we have monthly breaks over a handful of years we can mix date formats as follows; specify beginning of the year and every other month. Such tricks can be used reduce overcrowding.\n\nfrom datetime import date\n\n\ndef custom_date_format2(breaks):\n    \"\"\"\n    Function to format the date\n    \"\"\"\n    res = []\n    for x in breaks:\n        # First day of the year\n        if x.month == 1 and x.day == 1:\n            fmt = \"%Y\"\n        # Every other month\n        elif x.month % 2 != 0:\n            fmt = \"%b\"\n        else:\n            fmt = \"\"\n\n        res.append(date.strftime(x, fmt))\n\n    return res\n\n\n(\n    ggplot(economics.loc[40:60, :])  # modified\n    + geom_point(aes(\"date\", \"psavert\"))\n    + scale_x_datetime(\n        breaks=date_breaks(\"1 months\"), labels=custom_date_format2, minor_breaks=[]\n    )\n    + labs(y=\"personal saving rate\")\n)\n\n\n\n\n\n\n\n\nWe removed the labels but not the breaks, leaving behind dangling ticks for the skipped months. We can fix that by wrapping date_breaks around a filtering function.\n\ndef custom_date_format3(breaks):\n    \"\"\"\n    Function to format the date\n    \"\"\"\n    res = []\n    for x in breaks:\n        # First day of the year\n        if x.month == 1:\n            fmt = \"%Y\"\n        else:\n            fmt = \"%b\"\n\n        res.append(date.strftime(x, fmt))\n\n    return res\n\n\ndef custom_date_breaks(width=None):\n    \"\"\"\n    Create a function that calculates date breaks\n\n    It delegates the work to `date_breaks`\n    \"\"\"\n\n    def filter_func(limits):\n        breaks = date_breaks(width)(limits)\n        # filter\n        return [x for x in breaks if x.month % 2]\n\n    return filter_func\n\n\n(\n    ggplot(economics.loc[40:60, :])\n    + geom_point(aes(\"date\", \"psavert\"))\n    + scale_x_datetime(  # modified\n        breaks=custom_date_breaks(\"1 months\"), labels=custom_date_format3\n    )\n    + labs(y=\"personal saving rate\")\n)\n\n\n\n\n\n\n\n\nThe breaks and labels functions are tightly coupled to give us exactly what we want.\nCredit: This example was motivated by the github user lorin (Lorin Hochstein) and his endeavor to control date breaks and date labels."
  },
  {
    "objectID": "gallery/periodic-table.html",
    "href": "gallery/periodic-table.html",
    "title": "Periodic Table",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_tile,\n    geom_text,\n    scale_y_reverse,\n    scale_y_discrete,\n    scale_fill_brewer,\n    scale_color_manual,\n    coord_equal,\n    theme,\n    theme_void,\n    element_blank,\n    element_rect,\n    element_text,\n)\n\nGraphing of highly organised tabular information\nRead the data.\n\nelements = pd.read_csv(\"data/elements.csv\")\nelements.head()\n\n\n\n\n\n\n\n\natomic number\nsymbol\nname\natomic mass\nCPK\nelectronic configuration\nelectronegativity\natomic radius\nion radius\nvan der Waals radius\n...\nEA\nstandard state\nbonding type\nmelting point\nboiling point\ndensity\nmetal\nyear discovered\ngroup\nperiod\n\n\n\n\n0\n1\nH\nHydrogen\n1.00794\n#FFFFFF\n1s1\n2.20\n37.0\nNaN\n120.0\n...\n-73.0\ngas\ndiatomic\n14.0\n20.0\n0.00009\nnonmetal\n1766\n1\n1\n\n\n1\n2\nHe\nHelium\n4.002602\n#D9FFFF\n1s2\nNaN\n32.0\nNaN\n140.0\n...\n0.0\ngas\natomic\nNaN\n4.0\n0.00000\nnoble gas\n1868\n18\n1\n\n\n2\n3\nLi\nLithium\n6.941\n#CC80FF\n[He] 2s1\n0.98\n134.0\n76 (+1)\n182.0\n...\n-60.0\nsolid\nmetallic\n454.0\n1615.0\n0.54000\nalkali metal\n1817\n1\n2\n\n\n3\n4\nBe\nBeryllium\n9.012182\n#C2FF00\n[He] 2s2\n1.57\n90.0\n45 (+2)\nNaN\n...\n0.0\nsolid\nmetallic\n1560.0\n2743.0\n1.85000\nalkaline earth metal\n1798\n2\n2\n\n\n4\n5\nB\nBoron\n10.811\n#FFB5B5\n[He] 2s2 2p1\n2.04\n82.0\n27 (+3)\nNaN\n...\n-27.0\nsolid\ncovalent network\n2348.0\n4273.0\n2.46000\nmetalloid\n1807\n13\n2\n\n\n\n\n5 rows × 21 columns\n\n\n\nAlter the data types of the information that will be plotted. This makes it convenient to work with.\n\nelements[\"group\"] = [-1 if g == \"-\" else int(g) for g in elements.group]\nelements[\"bonding type\"] = elements[\"bonding type\"].astype(\"category\")\nelements[\"metal\"] = elements[\"metal\"].astype(\"category\")\nelements[\"atomic_number\"] = elements[\"atomic number\"].astype(str)\n\nThe periodic table has two tables, a top and bottom. The elements in the top have groups, and those in the bottom have no groups. We make separate dataframes for both – they have different alignments.\n\ntop = elements.query(\"group != -1\").copy()\nbottom = elements.query(\"group == -1\").copy()\n\nThe top table is nice and well behaving. The x location of the elements indicate the group and the y locations the period.\n\ntop[\"x\"] = top.group\ntop[\"y\"] = top.period\n\nThe bottom table has 2 rows, with the atomic number increasing to the right. We create an x based on the atomic number and add a horizontal shift. As the dataframe is ordered by atomic number, the operation is easier. The bottom elements are labelled with a “period”. We add a vertical shift to give us a good y location that gives the appearance of two tables.\n\nnrows = 2\nhshift = 3.5\nvshift = 3\nbottom[\"x\"] = np.tile(np.arange(len(bottom) // nrows), nrows) + hshift\nbottom[\"y\"] = bottom.period + vshift\n\nWe will be plotting using tiles and we want to have some space between the tiles. We have set the x and y locations above to take up a unit of space. To get a good effect, the tile dimensions should be less than 1.\n\ntile_width = 0.95\ntile_height = 0.95\n\nFirst peak\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n)\n\n\n\n\n\n\n\n\nThe table upside down. We could have been more careful when creating the y locations since the periods are drawn in descending order. But, we can fix that with a reverse scale.\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + scale_y_reverse()  # new\n)\n\n\n\n\n\n\n\n\nLet us apply some color to it.\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")  # new\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + scale_y_reverse()\n)\n\n\n\n\n\n\n\n\n\nNow for some trick\nGoal: To add text to the tiles\nThere are four pieces of text that we shall add to the tiles, that is 4 geom_text additions. As we have two tables, that comes to 8 geom_text additions. When any geom is added to a ggplot object, behind the scenes a layer is created and added. We can create a group of layers that can be added to a ggplot object in one go using a list.\nWe use a function that accepts a dataframe, and returns a list of geoms.\n\ndef inner_text(data):\n    layers = [\n        geom_text(\n            data,\n            aes(label=\"atomic_number\"),\n            nudge_x=-0.40,\n            nudge_y=0.40,\n            ha=\"left\",\n            va=\"top\",\n            fontweight=\"normal\",\n            size=6,\n        ),\n        geom_text(data, aes(label=\"symbol\"), nudge_y=0.1, size=9),\n        geom_text(\n            data, aes(label=\"name\"), nudge_y=-0.125, fontweight=\"normal\", size=4.5\n        ),\n        geom_text(\n            data, aes(label=\"atomic mass\"), nudge_y=-0.3, fontweight=\"normal\", size=4.5\n        ),\n    ]\n    return layers\n\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)  # new\n    + inner_text(bottom)  # new\n    + scale_y_reverse()\n)\n\n\n\n\n\n\n\n\nIt is crowded in there and the tiles do not have equal dimentions. Use the theme create a larger figure. coord_equal give us equal units along the axes, this makes the tiles square.\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)\n    + inner_text(bottom)\n    + scale_y_reverse()\n    + coord_equal(expand=False)  # new\n    + theme(figure_size=(12, 6))  # new\n)\n\n\n\n\n\n\n\n\nIt is has all the information we want, except one for complication. Elements Lu and Lr also belong in the bottom table. One way to show this duality is to have tiles with two colors split horizontally.\nThe colors are determined by the metal field, and we know the x and y locations. We create a dataframe with this information to create a half-tile. A half-tile is centered at the quarter mark.\n\nsplit_df = pd.DataFrame(\n    {\n        \"x\": 3 - tile_width / 4,\n        \"y\": [6, 7],\n        \"metal\": pd.Categorical([\"lanthanoid\", \"actinoid\"]),\n    }\n)\n\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(split_df, aes(width=tile_width / 2, height=tile_height))  # new\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)\n    + inner_text(bottom)\n    + scale_y_reverse()\n    + coord_equal(expand=False)\n    + theme(figure_size=(12, 6))\n)\n\n\n\n\n\n\n\n\nChange the fill color for a different look and use a theme that clears out all the clutter.\n\nfrom plotnine import guides\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(split_df, aes(width=tile_width / 2, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)\n    + inner_text(bottom)\n    + scale_y_reverse()\n    + scale_fill_brewer(type=\"qual\", palette=3)  # new\n    + coord_equal(expand=False)\n    + theme_void()  # new\n    + theme(\n        figure_size=(12, 6),\n        plot_margin_left=0.01,\n        plot_margin_right=0.01,\n        plot_background=element_rect(fill=\"white\"),\n    )  # new\n)\n\n\n\n\n\n\n\n\nAdd the group number along the top most row of each column, and period number along the left side of the top table.\nFor the period number, we set the breaks on the y scale.\n\n# The location of the group number is the top most (and therefore smallest period)\n# element with the group\ngroupdf = top.groupby(\"group\").agg(y=(\"period\", \"min\")).reset_index()\n\nFinally,\n\n(\n    ggplot(aes(\"x\", \"y\"))\n    + aes(fill=\"metal\")\n    + geom_tile(top, aes(width=tile_width, height=tile_height))\n    + geom_tile(split_df, aes(width=tile_width / 2, height=tile_height))\n    + geom_tile(bottom, aes(width=tile_width, height=tile_height))\n    + inner_text(top)\n    + inner_text(bottom)\n    + geom_text(\n        groupdf,\n        aes(\"group\", \"y\", label=\"group\"),\n        color=\"gray\",\n        nudge_y=0.525,\n        va=\"bottom\",\n        fontweight=\"normal\",\n        size=9,\n        inherit_aes=False,\n    )  # new\n    + scale_y_reverse(breaks=range(1, 8), limits=(0, 10.5))  # modified\n    + scale_fill_brewer(type=\"qual\", palette=3)\n    + coord_equal(expand=False)\n    + theme_void()\n    + theme(\n        figure_size=(12, 6),\n        plot_margin_left=0.01,\n        plot_margin_right=0.01,\n        plot_background=element_rect(fill=\"white\"),\n        axis_text_y=element_text(margin={\"r\": 5}, color=\"gray\", size=9),  # new\n    )\n)\n\n\n\n\n\n\n\n\nWhat we could have done different:\n\nAfter we set the x and y positions in th the top and bottom dataframes, we could have concatenated them back together. Then, that Layers trick would not save us much.\n\nPro tip: Save the plot as a pdf."
  },
  {
    "objectID": "gallery/scale_fill_continuous.html",
    "href": "gallery/scale_fill_continuous.html",
    "title": "Heatmap",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    theme_matplotlib,\n    theme_set,\n    geom_tile,\n    scale_fill_continuous,\n    coord_cartesian\n)\n\nfrom plotnine.data import faithfuld\n\n# Set default theme for all the plots\ntheme_set(theme_matplotlib())\n\nMap data to color gradient\nWithout specifically calling scale_fill_continuous(), a default scale is applied to geom_tile().\n\nfaithfuld.head()\n\n\n\n\n\n\n\n\neruptions\nwaiting\ndensity\n\n\n\n\n0\n1.600000\n43.0\n0.003216\n\n\n1\n1.647297\n43.0\n0.003835\n\n\n2\n1.694595\n43.0\n0.004436\n\n\n3\n1.741892\n43.0\n0.004978\n\n\n4\n1.789189\n43.0\n0.005424\n\n\n\n\n\n\n\n\n(\n    ggplot(faithfuld, aes(\"waiting\", \"eruptions\", fill=\"density\")) \n    + geom_tile()\n)\n\n\n\n\n\n\n\n\nNotice that adding scale_fill_continuous() will not change the default plot.\n\n(\n    ggplot(faithfuld, aes(\"waiting\", \"eruptions\", fill=\"density\"))\n    + geom_tile()\n    + scale_fill_continuous()\n)\n\n\n\n\n\n\n\n\nThe scale aesthetics can be edited to other color maps. Use the cmap_name argument to specify an alternative palette. Find other available color maps in the matplotlib documentation.\n\n(\n    ggplot(faithfuld, aes(\"waiting\", \"eruptions\", fill=\"density\"))\n    + geom_tile()\n    + scale_fill_continuous(cmap_name=\"plasma\")\n    + coord_cartesian(expand=False)\n)"
  },
  {
    "objectID": "gallery/show-counts-and-percentages-for-bar-plots.html",
    "href": "gallery/show-counts-and-percentages-for-bar-plots.html",
    "title": "Add Counts And Percentages",
    "section": "",
    "text": "import pandas as pd\nfrom plotnine import (\n    ggplot,\n    aes,\n    after_stat,\n    stage,\n    geom_bar,\n    geom_text,\n    geom_label,\n    position_dodge2,\n    facet_wrap,\n)\nfrom plotnine.data import mtcars\n\nWe can plot a bar graph and easily show the counts for each bar\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(cyl)\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"count\")), stat=\"count\", nudge_y=0.125, va=\"bottom\"\n    )\n)\n\n\n\n\n\n\n\n\nstat_count also calculates proportions (as prop) and a proportion can be converted to a percentage.\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(cyl)\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"prop*100\")),\n        stat=\"count\",\n        nudge_y=0.125,\n        va=\"bottom\",\n        format_string=\"{:.1f}% \",\n    )\n)\n\n\n\n\n\n\n\n\nThese are clearly wrong percentages. The system puts each bar in a separate group. We need to tell it to put all bars in the panel in single group, so that the percentage are what we expect.\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(cyl)\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"prop*100\"), group=1),\n        stat=\"count\",\n        nudge_y=0.125,\n        va=\"bottom\",\n        format_string=\"{:.1f}%\",\n    )\n)\n\n\n\n\n\n\n\n\nWithout group=1, you can calculate the proportion / percentage after statistics have been calculated. This works because mapping expressions are evaluated across the whole panel. It can work when you have more than 1 categorical.\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(cyl)\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"count / sum(count) * 100\")),\n        stat=\"count\",\n        nudge_y=0.125,\n        va=\"bottom\",\n        format_string=\"{:.1f}%\",\n    )\n)\n\n\n\n\n\n\n\n\nFor more on why automatic grouping may work the way you want, see this tutorial.\nWe can get the counts and we can get the percentages we need to print both. We can do that in two ways,\n\nUsing two geom_text layers.\n\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(cyl)\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"count\")),\n        stat=\"count\",\n        nudge_x=-0.14,\n        nudge_y=0.125,\n        va=\"bottom\",\n    )\n    + geom_text(\n        aes(label=after_stat(\"prop*100\"), group=1),\n        stat=\"count\",\n        nudge_x=0.14,\n        nudge_y=0.125,\n        va=\"bottom\",\n        format_string=\"({:.1f}%)\",\n    )\n)\n\n\n\n\n\n\n\n\n\nUsing a function to combine the counts and percentages\n\n\ndef combine(counts, percentages):\n    fmt = \"{} ({:.1f}%)\".format\n    return [fmt(c, p) for c, p in zip(counts, percentages)]\n\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(cyl)\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"combine(count, prop*100)\"), group=1),\n        stat=\"count\",\n        nudge_y=0.125,\n        va=\"bottom\",\n    )\n)\n\n\n\n\n\n\n\n\nIt works with facetting.\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(cyl)\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"combine(count, prop*100)\"), group=1),\n        stat=\"count\",\n        nudge_y=0.125,\n        va=\"bottom\",\n        size=9,\n    )\n    + facet_wrap(\"am\")\n)\n\n\n\n\n\n\n\n\nCredit: This example was motivated by the github user Fandekasp (Adrien Lemaire) and difficulty he faced in displaying percentages of bar plots.\n\nPercentages when you have more than one categorical.\ngroup = 1 does not work when you have more than one categories per x location.\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(am)\"))\n    + geom_bar(position=\"dodge2\")\n    + geom_text(\n        aes(label=after_stat(\"prop * 100\"), group=1),\n        stat=\"count\",\n        position=position_dodge2(width=0.9),\n        format_string=\"{:.1f}%\",\n        size=9,\n    )\n)\n\n\n\n\n\n\n\n\nYou have to calculate the percentages after statistics for the panel have been calculated.\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(am)\"))\n    + geom_bar(position=\"dodge2\")\n    + geom_text(\n        aes(\n            label=after_stat(\"count / sum(count) * 100\"),\n            y=stage(after_stat=\"count\", after_scale=\"y + 0.25\"),\n        ),\n        stat=\"count\",\n        position=position_dodge2(width=0.9),\n        format_string=\"{:.1f}%\",\n        size=9,\n    )\n)\n\n\n\n\n\n\n\n\nFor percentages per bar at each x location, you have to group the counts per location can compute the proportions.\n\n\nBars with Group Percentages\n\ndef prop_per_x(x, count):\n    \"\"\"\n    Compute the proportion of the counts for each value of x\n    \"\"\"\n    df = pd.DataFrame({\"x\": x, \"count\": count})\n    prop = df[\"count\"] / df.groupby(\"x\")[\"count\"].transform(\"sum\")\n    return prop\n\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(am)\"))\n    + geom_bar(position=\"dodge2\")\n    + geom_text(\n        aes(\n            label=after_stat(\"prop_per_x(x, count) * 100\"),\n            y=stage(after_stat=\"count\", after_scale=\"y+.25\"),\n        ),\n        stat=\"count\",\n        position=position_dodge2(width=0.9),\n        format_string=\"{:.1f}%\",\n        size=9,\n    )\n)\n\n\n\n\n\n\n\n\n\n\nStacked Bars with Group Percentages\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(am)\"))\n    + geom_bar(position=\"fill\")\n    + geom_label(\n        aes(label=after_stat(\"prop_per_x(x, count) * 100\")),\n        stat=\"count\",\n        position=\"fill\",\n        format_string=\"{:.1f}%\",\n        size=9,\n    )\n)\n\n\n\n\n\n\n\n\nNOTE\nWith more categories, if it becomes harder get the right groupings withing plotnine, the solution is to do all (or most) the data manipulation in pandas then plot using geom_col + geom_text."
  },
  {
    "objectID": "gallery/theme.html",
    "href": "gallery/theme.html",
    "title": "Theming Specific Elements",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    facet_grid,\n    labs,\n    guide_legend,\n    guides,\n    theme,\n    element_text,\n    element_line,\n    element_rect,\n    theme_set,\n    theme_void,\n)\nfrom plotnine.data import mtcars\n\n# We use theme_void as the base theme so that the modifications\n# we make in the code are transparent in the output\ntheme_set(theme_void())\nmtcars.head()\n\n\n\n\n\n\n\n\nname\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\n0\nMazda RX4\n21.0\n6\n160.0\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\n1\nMazda RX4 Wag\n21.0\n6\n160.0\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\n2\nDatsun 710\n22.8\n4\n108.0\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\n3\nHornet 4 Drive\n21.4\n6\n258.0\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\n4\nHornet Sportabout\n18.7\n8\n360.0\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\nThe base plots we will use for the demonstation and some colors.\np1 = (\n    ggplot(mtcars, aes(\"wt\", \"mpg\", color=\"factor(cyl)\"))\n    + geom_point()\n    + labs(title=\"mpg vs wt\")\n)\n\np2 = p1 + facet_grid(\"gear\", \"am\")\n\nblack = \"#222222\"\ngray = \"#666666\"\nred = \"#FF3333\"\ngreen = \"#66CC00\"\nblue = \"#3333FF\"\npurple = \"#9933FF\"\norange = \"#FF8000\"\nyellow = \"#FFFF33\"\nWhat the plots look like unmodified (unthemed).\np1\np2\nThere are 3 main top level theming elements:\nNote that none of the themeables control/modify the plotted data. e.g You cannot use text to change the appearance of objects plotted with geom_text.\ntext\np1 + theme(text=element_text(color=purple))\nrect\np1 + theme(rect=element_rect(color=black, size=3, fill=\"#EEBB0050\"))\nline\np1 + theme(line=element_line(color=black))"
  },
  {
    "objectID": "gallery/theme.html#theming-specific-items",
    "href": "gallery/theme.html#theming-specific-items",
    "title": "Theming Specific Elements",
    "section": "Theming specific items",
    "text": "Theming specific items\n\naxis_line and axis_text\n\np1 + theme(\n    axis_line=element_line(size=2),\n    axis_line_x=element_line(color=red),\n    axis_line_y=element_line(color=blue),\n    axis_text=element_text(margin={\"t\": 5, \"r\": 5}),\n    axis_text_x=element_text(color=black),\n    axis_text_y=element_text(color=purple),\n)\n\n\n\n\n\n\n\n\n\np1 + theme(\n    axis_line=element_line(size=0.7, color=gray),\n    # We are focusing on the ticks, make them long\n    axis_ticks_length=20,\n    axis_ticks_length_minor=10,\n    axis_ticks_length_major=20,\n    axis_ticks=element_line(size=2),\n    axis_ticks_major=element_line(color=purple),\n    axis_ticks_major_x=element_line(size=4),  # override size=2\n    axis_ticks_major_y=element_line(color=yellow),  # override color=purple\n    axis_ticks_minor=element_line(color=red),\n    axis_ticks_minor_x=element_line(),  # do not override anything\n    axis_ticks_minor_y=element_line(color=gray),  # override color=red\n)\n\n\n\n\n\n\n\n\n\n\naxis_title and axis_ticks_pad\n\np1 + theme(\n    axis_line=element_line(size=0.7, color=gray),\n    axis_ticks=element_line(),\n    axis_title=element_text(),\n    axis_title_x=element_text(color=blue),\n    axis_title_y=element_text(color=red),\n    # The gap between the title and the ticks\n    axis_ticks_pad=20,\n    axis_ticks_pad_major=20,\n    axis_ticks_pad_minor=20,\n)\n\n\n\n\n\n\n\n\n\n\naxis_ticks_direction\n\np1 + theme(\n    axis_line=element_line(size=0.7, color=gray),\n    axis_ticks=element_line(),\n    axis_ticks_direction=\"in\",\n    axis_ticks_direction_x=\"in\",\n    axis_ticks_direction_y=\"out\",\n)\n\n\n\n\n\n\n\n\n\n\nLegend_box\nNot all themeables that affect the legend box are demonstrated\n\n(\n    p1\n    + aes(fill=\"drat\")\n    + theme(\n        legend_position=\"left\",\n        legend_direction=\"horizontal\",  # affected by the ncol=2\n        legend_box_margin=5,\n        legend_background=element_rect(color=purple, size=2, fill=\"white\"),\n        legend_box=\"vertical\",\n        legend_key=element_rect(fill=gray, alpha=0.3),\n        legend_title=element_text(color=orange, va=\"top\"),\n        legend_text=element_text(weight=\"bold\"),\n        legend_key_spacing=10,  # overridden\n        legend_key_spacing_x=15,\n        legend_key_spacing_y=5,\n    )\n    # so we can see legend_entry_spacing in action\n    + guides(color=guide_legend(ncol=2))\n)\n\n\n\n\n\n\n\n\n\n\nplot_background, panel_background and panel_border\n\np2 + theme(\n    plot_background=element_rect(fill=\"gray\", alpha=0.3),\n    panel_background=element_rect(fill=purple, alpha=0.2),\n    panel_border=element_rect(color=red, size=1),\n    panel_spacing=0.025,\n)\n\n\n\n\n\n\n\n\n\n\npanel_grid\n\np1 + theme(\n    panel_grid=element_line(color=purple),\n    panel_grid_major=element_line(size=1.4, alpha=1),\n    panel_grid_major_x=element_line(linetype=\"dashed\"),\n    panel_grid_major_y=element_line(linetype=\"dashdot\"),\n    panel_grid_minor=element_line(alpha=0.25),\n    panel_grid_minor_x=element_line(color=red),\n    panel_grid_minor_y=element_line(color=green),\n    panel_ontop=False,  # puts the points behind the grid\n)\n\n\n\n\n\n\n\n\n\n\nstrip_background, strip_align and strip_text\n\np2 + theme(\n    panel_spacing=0.025,\n    panel_background=element_rect(fill=gray, alpha=0.2),\n    strip_background=element_rect(color=purple, fill=orange, size=1.4, alpha=0.95),\n    strip_background_x=element_rect(x=1 / 6, width=2 / 3),  # you can get really crazy\n    strip_background_y=element_rect(),\n    strip_align=0,\n    strip_align_x=0.2,\n    strip_align_y=0.2,\n    strip_text=element_text(weight=\"bold\"),\n    strip_text_x=element_text(color=red),\n    strip_text_y=element_text(color=blue),\n)\n\n\n\n\n\n\n\n\n\n\naspect_ratio and figure_size\nThe aspect_ratio takes precedence over the figure_size, and it modifies the height. The effective width and height are:\nwidth = figure_size[0]\nheight = figure_size[0] * aspect_ratio\n\np1 + theme(\n    panel_background=element_rect(fill=gray, alpha=0.2),\n    figure_size=(8, 6),  # inches\n    aspect_ratio=1 / 3,  # height:width\n)"
  },
  {
    "objectID": "gallery/weather-forecast.html",
    "href": "gallery/weather-forecast.html",
    "title": "Weather Forecast",
    "section": "",
    "text": "The code in this jupyter notebook walks through generating plots to represent a 7 day forecast (inspired by the Apple Weather app) using plotnine. Here is an example of a finished plot:\nThe plot uses: * geom_path to draw temperature ranges (geom_line would have worked just as well) * geom_text to label the high and low temperatures * watermark to display the weather icons\nThe remaining plot components are the title, subtitle, and y-axis labels.\nThe icons were modified from the open source icon library, Bootstrap Icons: I colorized the icons and saved them as PNGs. Thanks to the Bootstrap team and contributors for Bootstrap Icons and the Bootstrap framework.\nThe trickier parts of creating this plot are getting the color gradient right and positioning the icons. The most time-consuming part is tweaking the plot’s theme to polish the plot’s look including placement and styling of elements.\nIf you want to skip past the prototypes that eventually led to the final product, jump to the Final Plot section. After working out how I want the plot to look, I write a function to facilitate generating additional plots at the end of this notebook."
  },
  {
    "objectID": "gallery/weather-forecast.html#imports",
    "href": "gallery/weather-forecast.html#imports",
    "title": "Weather Forecast",
    "section": "Imports",
    "text": "Imports\nThe code uses polars to read in the raw data and manipulate it to be ready to create the plot in plotnine. Here is an example table of raw data:\n\n\n\nDay\nLow\nHigh\nConditions\n\n\n\n\nToday\n65\n77\nCloudy\n\n\nMon\n61\n84\nSunny\n\n\nTue\n67\n93\nHot\n\n\nWed\n59\n76\nDrizzle\n\n\nThu\n54\n75\nWindy\n\n\nFri\n57\n81\nParty cloudy\n\n\nSat\n60\n71\nHeavy rain\n\n\n\n\nimport polars as pl\nimport plotnine as p9\n\npl.__version__, p9.__version__\n\n('1.30.0', '0.15.0a2')"
  },
  {
    "objectID": "gallery/weather-forecast.html#import-data",
    "href": "gallery/weather-forecast.html#import-data",
    "title": "Weather Forecast",
    "section": "Import data",
    "text": "Import data\ngeom_segment requires x, xend, y, and yend aesthetics. We can map “Low” and “High” to x and xend, respectively, and “Day” to y and yend.\nWe can use the raw data with geom_segment with minimal work: we’ll just want to type the “Day” column as a categorical column to establish the correct plotting order. If we don’t do this, the days will be plot in alphabetical order.\nSince this is just a 7-day forecast, we don’t need to worry about non-unique “Day” values. If there were non-unique “Day” values, we would need a different strategy such as using a unique value to order the days while using the “Day” value for labeling.\nDon’t be concerned about the “Conditions” column for now. We’ll figure out what, if anything, to do with it after figuring out most of the other parts.\n\nraw_data = pl.read_csv('./data/7-day_forecast.csv')\nraw_data = raw_data.with_columns(pl.col('Day').cast(pl.Categorical))\nraw_data\n\n\nshape: (7, 4)\n\n\n\nDay\nLow\nHigh\nConditions\n\n\ncat\ni64\ni64\nstr\n\n\n\n\n\"Today\"\n65\n77\n\"Cloudy\"\n\n\n\"Mon\"\n61\n84\n\"Sunny\"\n\n\n\"Tue\"\n67\n93\n\"Hot\"\n\n\n\"Wed\"\n59\n76\n\"Drizzle\"\n\n\n\"Thu\"\n54\n75\n\"Windy\"\n\n\n\"Fri\"\n57\n81\n\"Partly cloudy\"\n\n\n\"Sat\"\n60\n71\n\"Heavy rain\""
  },
  {
    "objectID": "gallery/weather-forecast.html#create-plot",
    "href": "gallery/weather-forecast.html#create-plot",
    "title": "Weather Forecast",
    "section": "Create plot",
    "text": "Create plot\nI’m not showing the most basic prototype below, but if you want to see it, comment out line 4 and uncomment line 5 in the code block below.\nFrom the most basic prototype, I made the design choices that I want a thicker line, I want round ends, and I want color in the line, ideally a color gradient. The first prototype on display below shows attempts at working towards the design choices.\n\nplot = (\n    p9.ggplot(raw_data, p9.aes(x='Low', xend='High', y='Day', yend='Day'))\n    + p9.labs(title='Prototype 1')\n    + p9.geom_segment(size=8, lineend='round', color='steelblue')\n    # + p9.geom_segment()\n)\nplot.show()"
  },
  {
    "objectID": "gallery/weather-forecast.html#prototype-1-learnings",
    "href": "gallery/weather-forecast.html#prototype-1-learnings",
    "title": "Weather Forecast",
    "section": "Prototype 1 learnings",
    "text": "Prototype 1 learnings\nThe plot is starting to come together a little bit but there are a few things to take from this prototype:\n\nThe days are on the y-axis where low ordinality is at the bottom and high ordinality is at the top (opposite of what I want)\nThe line ends are not rounded\nA color gradient is going to require some work\n\nThere are a couple of strategies we can use to get the days ordered the way I want: we can either reverse the ordinality of the days in the dataframe or we can flip the y-axis. We can’t use scale_y_reverse because we do not have continuous values, but we can use scale_y_discrete and set the limits in reverse order. I use scale_y_discrete to reverse the order as demonstrated below.\n\n# reverse order of the days with scale_y_discrete\n(\n    plot\n    + p9.labs(title='Prototype 1', caption='Fix day order')\n    + p9.scale_y_discrete(limits=raw_data['Day'].reverse().to_list())\n).show()\n\n\n\n\n\n\n\n\nIt looks like geom_segment doesn’t produce round ends although the code specifies lineend='round'. I’d like to dig into the code a bit to see if this observation might be similar to this issue and commit but I don’t have cycles available to do that right now. It took me a couple weeks to get to it but taking a look at the geom_segment code, I believe that geom_segment does not pass on the value of lineend and it can be solved similarly to the commit noted above; I’ve opened an issue.\nBefore moving on, let’s try one thing with geom_segment and a color gradient. I create a simple dataframe that has data to draw horizontal line segments at y=1. Each line segment has a z value ranging from 0 - 1 which we map to the color aesthetic.\n\nplot_data = pl.DataFrame({\n    'x': range(1, 11),\n    'y': [1] * 10,\n    'z': [0] * 3 + [0.2, 0.4, 0.6, 0.8]  + [1] * 3\n}, strict=False)\nplot_data = plot_data.with_columns(\n    xend = pl.col('x') + 1\n)\nplot_data\n\n\nshape: (10, 4)\n\n\n\nx\ny\nz\nxend\n\n\ni64\ni64\nf64\ni64\n\n\n\n\n1\n1\n0.0\n2\n\n\n2\n1\n0.0\n3\n\n\n3\n1\n0.0\n4\n\n\n4\n1\n0.2\n5\n\n\n5\n1\n0.4\n6\n\n\n6\n1\n0.6\n7\n\n\n7\n1\n0.8\n8\n\n\n8\n1\n1.0\n9\n\n\n9\n1\n1.0\n10\n\n\n10\n1\n1.0\n11\n\n\n\n\n\n\n\nplot = (\n    p9.ggplot(plot_data, p9.aes(x='x', xend='xend', y='y', yend='y', color='z'))\n    + p9.labs(caption='Color gradient testing')\n    + p9.geom_segment(size=8, lineend='round')\n)\nplot.show()\n\n\n\n\n\n\n\n\nHere’s the start of a color gradient effect, but we’ll need a lot more segments to get a smooth gradient. If you zoom in and take a close look at the segments, there are seams between the segments and there’s still the issue with not having rounded ends. We could deal with the seams by plotting overlapping line segments and try using geom_points to simulate rounded ends, but these workarounds suggest that it’s worth considering what other approaches might be out there. Let’s move on to trying geom_path."
  },
  {
    "objectID": "gallery/weather-forecast.html#import-data-1",
    "href": "gallery/weather-forecast.html#import-data-1",
    "title": "Weather Forecast",
    "section": "Import data",
    "text": "Import data\ngeom_path requires x and y aesthetics where it connects points according to their order in the dataframe. I want to map a temperature to x and “Day” to y, so I need the Low and High temperatures for each day to be separated to different rows. This will require reshaping the data: in this case, we’ll melt the data from wide to long format so that we have “Temperature” (x) and “Day” (y) columns.\nI’m going to work from the raw_data that was read in previously where Day is a categorical column.\n\nplot_data = (\n    raw_data\n    .melt(id_vars=['Day'], value_vars=['High', 'Low'], variable_name='Low/High', value_name='Temperature')\n    .sort(['Day', 'Temperature'], descending=False)\n)\nplot_data\n\n\nshape: (14, 3)\n\n\n\nDay\nLow/High\nTemperature\n\n\ncat\nstr\ni64\n\n\n\n\n\"Today\"\n\"Low\"\n65\n\n\n\"Today\"\n\"High\"\n77\n\n\n\"Mon\"\n\"Low\"\n61\n\n\n\"Mon\"\n\"High\"\n84\n\n\n\"Tue\"\n\"Low\"\n67\n\n\n…\n…\n…\n\n\n\"Thu\"\n\"High\"\n75\n\n\n\"Fri\"\n\"Low\"\n57\n\n\n\"Fri\"\n\"High\"\n81\n\n\n\"Sat\"\n\"Low\"\n60\n\n\n\"Sat\"\n\"High\"\n71"
  },
  {
    "objectID": "gallery/weather-forecast.html#create-plot-1",
    "href": "gallery/weather-forecast.html#create-plot-1",
    "title": "Weather Forecast",
    "section": "Create plot",
    "text": "Create plot\nI had imagined/hoped that geom_path might be able to auto-calculate a color gradient for the line between each of the two points, but ultimately the plot below demonstrates that this isn’t the case.\n\nplot = (\n    p9.ggplot(plot_data, p9.aes(x='Temperature', y='Day', color='Temperature'))\n    + p9.labs(title='Prototype 2')\n    + p9.geom_path(size=8, lineend='round')\n    + p9.scale_y_discrete(limits=raw_data['Day'].reverse().to_list())\n)\nplot.show()\n\n\n\n\n\n\n\n\n\nNo group aesthetic?\nYou might have noticed that the code above doesn’t map anything to the group aesthetic. Initially, I mapped “Day” to the group aesthetic, but it doesn’t appear to matter in this case. I believe it’s because y is mapped to discrete rather than continuous values. Look at the plot below to see what happens if y is mapped to continuous values without a group aesthetic.\nSince we’ll have continuous values, we can use scale_y_reverse to reverse the order of the days.\n\n# prep dictionary to map days to numbers\ndays = plot_data.get_column('Day').unique(maintain_order=True)\ndays = dict(zip(days, range(days.len())))\ndays\n\n{'Today': 0, 'Mon': 1, 'Tue': 2, 'Wed': 3, 'Thu': 4, 'Fri': 5, 'Sat': 6}\n\n\n\n# convert days to numbers in \"Day_int\" column\nplot_data_test = plot_data.with_columns(\n    pl.col('Day').cast(str).replace(days).cast(int).alias('Day_int')\n)\nplot_data_test\n\n\nshape: (14, 4)\n\n\n\nDay\nLow/High\nTemperature\nDay_int\n\n\ncat\nstr\ni64\ni64\n\n\n\n\n\"Today\"\n\"Low\"\n65\n0\n\n\n\"Today\"\n\"High\"\n77\n0\n\n\n\"Mon\"\n\"Low\"\n61\n1\n\n\n\"Mon\"\n\"High\"\n84\n1\n\n\n\"Tue\"\n\"Low\"\n67\n2\n\n\n…\n…\n…\n…\n\n\n\"Thu\"\n\"High\"\n75\n4\n\n\n\"Fri\"\n\"Low\"\n57\n5\n\n\n\"Fri\"\n\"High\"\n81\n5\n\n\n\"Sat\"\n\"Low\"\n60\n6\n\n\n\"Sat\"\n\"High\"\n71\n6\n\n\n\n\n\n\n\n# plot with Day_int mapped to y; switch between commenting out lines 3 and 4 to see what happens\nplot = (\n    p9.ggplot(plot_data_test, p9.aes(x='Temperature', y='Day_int', color='Temperature'))\n    # p9.ggplot(plot_data_test, p9.aes(x='Temperature', y='Day_int', color='Temperature', group='Day_int'))\n    + p9.labs(title='Prototype 2', caption='Continuous variable testing')\n    + p9.geom_path(size=8, lineend='round')\n    + p9.scale_y_reverse()\n)\nplot.show()\n\n\n\n\n\n\n\n\n\n\nExtra geom_path testing\nThe continuous variable testing plot above hints at this but let’s take another look at what’s going on with geom_path and the color: calculate a midpoint between Low and High and then remake the plot with geom_path.\n\nplot_data = (\n    raw_data\n    .with_columns(Mid = (pl.col('High') + pl.col('Low')) / 2)\n    .melt(id_vars=['Day'], value_vars=['High', 'Mid', 'Low'], variable_name='Low/High', value_name='Temperature')\n    .sort(['Day', 'Temperature'], descending=False)\n)\nplot_data\n\n\nshape: (21, 3)\n\n\n\nDay\nLow/High\nTemperature\n\n\ncat\nstr\nf64\n\n\n\n\n\"Today\"\n\"Low\"\n65.0\n\n\n\"Today\"\n\"Mid\"\n71.0\n\n\n\"Today\"\n\"High\"\n77.0\n\n\n\"Mon\"\n\"Low\"\n61.0\n\n\n\"Mon\"\n\"Mid\"\n72.5\n\n\n…\n…\n…\n\n\n\"Fri\"\n\"Mid\"\n69.0\n\n\n\"Fri\"\n\"High\"\n81.0\n\n\n\"Sat\"\n\"Low\"\n60.0\n\n\n\"Sat\"\n\"Mid\"\n65.5\n\n\n\"Sat\"\n\"High\"\n71.0\n\n\n\n\n\n\n\nplot = (\n    p9.ggplot(plot_data, p9.aes(x='Temperature', y='Day', color='Temperature'))\n    + p9.labs(title='Prototype 2', caption='Color gradient testing')\n    + p9.geom_path(size=8, lineend='round')\n    + p9.scale_y_discrete(limits=raw_data['Day'].reverse().to_list())\n)\nplot.show()"
  },
  {
    "objectID": "gallery/weather-forecast.html#prototype-2-learnings",
    "href": "gallery/weather-forecast.html#prototype-2-learnings",
    "title": "Weather Forecast",
    "section": "Prototype 2 learnings",
    "text": "Prototype 2 learnings\n\nRounded ends works for geom_path\ngeom_path does not change color until the next data point\n\nA color gradient is going to require some more work but geom_path looks like it has potential to do the job."
  },
  {
    "objectID": "gallery/weather-forecast.html#color-gradient-prototype",
    "href": "gallery/weather-forecast.html#color-gradient-prototype",
    "title": "Weather Forecast",
    "section": "Color gradient prototype",
    "text": "Color gradient prototype\nLet’s use our exploded out dataframe and see if the color gradient works.\n\nplot = (\n    p9.ggplot(plot_data, p9.aes(x='Temperature', y='Day'))\n    + p9.labs(title=\"Color gradient prototype\")\n    + p9.geom_path(p9.aes(color='Temperature'), size=8, lineend='round')\n    + p9.scale_y_discrete(limits=raw_data['Day'].reverse().to_list())\n)\nplot.show()\n\n\n\n\n\n\n\n\nThe gradient looks good! We’ll change the color scale to something more appropriate to express temperature range later."
  },
  {
    "objectID": "gallery/weather-forecast.html#full-temperature-prototype",
    "href": "gallery/weather-forecast.html#full-temperature-prototype",
    "title": "Weather Forecast",
    "section": "Full temperature prototype",
    "text": "Full temperature prototype\nLet’s add:\n\nA 7-day range underneath the daily temperature range\nLabels for the high and low temperatures to the plot\n\nFor the 7-day range, I want something that’s underneath (on the z-axis) and a little larger than the temperature range. The effect I want is a thin border around the edges, especially at the extreme low and high temperatures. This means using a geom_path with a slightly larger size that spans from the lowest low temperature to the highest high temperature. Then, add the daily temperature ranges with another geom_path that layers on top. We’ll create a dataframe to make the underlayment easy to add.\nFor the temperature labels, we’ll use geom_text and create a dataframe with columns that can map to the x, y, and label aesthetics to make them easy to add. The labels will be placed to the left and right of the full 7-day temperature range for each day.\n\nlow_high = [raw_data.get_column('Low').min(), raw_data.get_column('High').max()]\nlow_high\n\n[54, 93]\n\n\n\n# create dataframe for temperature range underlayment\ntemp_range = pl.DataFrame({\n    'Day': raw_data.get_column('Day'),\n    'Temperature': [low_high] * len(raw_data)\n}).explode('Temperature')\ntemp_range\n\n\nshape: (14, 2)\n\n\n\nDay\nTemperature\n\n\ncat\ni64\n\n\n\n\n\"Today\"\n54\n\n\n\"Today\"\n93\n\n\n\"Mon\"\n54\n\n\n\"Mon\"\n93\n\n\n\"Tue\"\n54\n\n\n…\n…\n\n\n\"Thu\"\n93\n\n\n\"Fri\"\n54\n\n\n\"Fri\"\n93\n\n\n\"Sat\"\n54\n\n\n\"Sat\"\n93\n\n\n\n\n\n\n\n# create dataframe for temperature labels; the offset used here will look better in the final plot\nx_offset = 5\ntemp_labels = (\n    raw_data.lazy()\n    .melt(id_vars=['Day', 'Conditions'], value_vars=['Low', 'High'], value_name='temperature')\n    .with_columns(\n        (pl.col('temperature').cast(str) + pl.lit('°')).alias('label'),\n        pl.when(pl.col('variable') == 'Low')\n        .then(pl.lit(low_high[0]) - x_offset)\n        .otherwise(pl.lit(low_high[1]) + x_offset)\n        .alias('x')\n    )\n    .sort('Day')\n    .collect()\n)\ntemp_labels\n\n\nshape: (14, 6)\n\n\n\nDay\nConditions\nvariable\ntemperature\nlabel\nx\n\n\ncat\nstr\nstr\ni64\nstr\ni32\n\n\n\n\n\"Today\"\n\"Cloudy\"\n\"Low\"\n65\n\"65°\"\n49\n\n\n\"Today\"\n\"Cloudy\"\n\"High\"\n77\n\"77°\"\n98\n\n\n\"Mon\"\n\"Sunny\"\n\"Low\"\n61\n\"61°\"\n49\n\n\n\"Mon\"\n\"Sunny\"\n\"High\"\n84\n\"84°\"\n98\n\n\n\"Tue\"\n\"Hot\"\n\"Low\"\n67\n\"67°\"\n49\n\n\n…\n…\n…\n…\n…\n…\n\n\n\"Thu\"\n\"Windy\"\n\"High\"\n75\n\"75°\"\n98\n\n\n\"Fri\"\n\"Partly cloudy\"\n\"Low\"\n57\n\"57°\"\n49\n\n\n\"Fri\"\n\"Partly cloudy\"\n\"High\"\n81\n\"81°\"\n98\n\n\n\"Sat\"\n\"Heavy rain\"\n\"Low\"\n60\n\"60°\"\n49\n\n\n\"Sat\"\n\"Heavy rain\"\n\"High\"\n71\n\"71°\"\n98\n\n\n\n\n\n\n\nplot = (\n    p9.ggplot(plot_data, p9.aes(x='Temperature', y='Day'))\n    + p9.labs(title=\"Full temperature prototype\")\n    + p9.geom_path(data=temp_range, size=9, color='black', lineend='round', alpha=0.8)\n    + p9.geom_path(p9.aes(color='Temperature'), size=8, lineend='round')\n    + p9.geom_text(data=temp_labels, mapping=p9.aes(x='x', label='label'), ha='center', va='center')\n    + p9.scale_y_discrete(limits=raw_data['Day'].reverse().to_list())\n)\nplot.show()"
  },
  {
    "objectID": "gallery/weather-forecast.html#temperature-info-prototype-learnings",
    "href": "gallery/weather-forecast.html#temperature-info-prototype-learnings",
    "title": "Weather Forecast",
    "section": "Temperature info prototype learnings",
    "text": "Temperature info prototype learnings\n\nThe color gradient in the temperature range and the underlayment work; we’ll adjust the colors for the final plot\nThe text labels are in place too: we’ll adjust the placement and font size in the final plot"
  },
  {
    "objectID": "gallery/weather-forecast.html#prep-data",
    "href": "gallery/weather-forecast.html#prep-data",
    "title": "Weather Forecast",
    "section": "Prep data",
    "text": "Prep data\nFor convenience, here is all of the code to prep the data for the final plot in one place.\n\nraw_data = pl.read_csv('./data/7-day_forecast.csv')\nraw_data = raw_data.with_columns(pl.col('Day').cast(pl.Categorical))\nlow_high = [raw_data.get_column('Low').min(), raw_data.get_column('High').max()]\n\n# daily temperature range data\nplot_data = (\n    raw_data\n    .with_columns(\n        Temperature = pl.int_ranges(pl.col('Low') * 10, pl.col('High') * 10 + 1).list.eval(pl.element() / 10)\n    )\n    .select('Day', 'Conditions', 'Temperature')\n    .explode('Temperature')\n)\n\n# underlayment data\ntemp_range = pl.DataFrame({\n    'Day': raw_data.get_column('Day'),\n    'Temperature': [low_high] * len(raw_data)\n}).explode('Temperature')\n\n# text label data\nx_offset = 5  # this is calculated dynamically in plot_forecast.py\ntemp_labels = (\n    raw_data\n    .melt(id_vars=['Day', 'Conditions'], value_vars=['Low', 'High'], value_name='temperature')\n    .with_columns(\n        (pl.col('temperature').cast(str) + pl.lit('°')).alias('label'),\n        pl.when(pl.col('variable') == 'Low')\n        .then(pl.lit(low_high[0]) - x_offset)\n        .otherwise(pl.lit(low_high[1]) + x_offset)\n        .alias('x')\n    )\n    .sort('Day')\n)"
  },
  {
    "objectID": "gallery/weather-forecast.html#plot-without-weather-icons",
    "href": "gallery/weather-forecast.html#plot-without-weather-icons",
    "title": "Weather Forecast",
    "section": "Plot without weather icons",
    "text": "Plot without weather icons\nMadison, WI is my current location and this is an actual 7-day forecast from late mid-June when I first started thinking about this. I did take some liberty on Tuesday to increase the high temperature for reasons you’ll see in the plot with icons. Check line 11 to see how I define the color gradient. I’ve left a gap for the weather icons to be added later, and this plot is going to get stretched out vertically.\nYou’ll notice that a lot of work happens in theme(). Also, there are a few variables I define at the top and these are where I spent more time trying out different settings. I had never used named colors from the xkcd color name survey before, but you can use them by placing xkcd: before the color name.\nFinal comment here on the tweaks: I use Arial instead of Helvetica font. Look at the “Full temperature prototype” plot above and you might notice that some of the numbers look a little uneven. The “65°” text label in the upper-left is an example of this. I think the Helvetica font is getting rendered a little unevenly and Arial looks better. I tried 20 different fonts and settled on Arial.\n\nrange_bg = 'xkcd:dark blue grey'\nfont_size = 18\nfont_family = 'Arial' # default is Helvetica; I think Arial looks a tiny bit better\n\nplot = (\n    p9.ggplot(plot_data, p9.aes(x='Temperature', y='Day'))\n    + p9.labs(title=\"Madison, WI\", subtitle=\"7-day forecast\", x=\"\", y=\"\")\n    + p9.geom_path(data=temp_range, size=9, color=range_bg, lineend='round', alpha=0.8)\n    + p9.geom_path(p9.aes(color='Temperature'), size=8, lineend='round')\n    + p9.geom_text(data=temp_labels, mapping=p9.aes(x='x', label='label'), color='white', size=font_size, ha='center', va='center')\n    + p9.scale_color_gradientn(colors=['deepskyblue', 'aqua', 'palegreen', 'yellow', 'orange', 'red'], limits=[0, 100])\n    + p9.scale_y_discrete(limits=raw_data['Day'].reverse().to_list(), expand=(0, 0.5, 0, 0.4))\n    + p9.theme_void()\n    + p9.theme(\n        text=p9.element_text(family=font_family, color='white'),\n        plot_background=p9.element_rect(fill='royalblue'),\n        plot_title=p9.element_text(size=24),\n        plot_subtitle=p9.element_text(size=16, ha='center'),\n        plot_margin_top=0.05,\n        plot_margin_right=0.04,\n        plot_margin_bottom=0.03,\n        plot_margin_left=-0.05,\n        axis_text_y=p9.element_text(angle=0, size=font_size, va='center', ha='left', margin={'t': 0, 'r': 95, 'b': 0, 'l': 0, 'units': 'pt'}),\n        axis_text_x=p9.element_blank(),\n        legend_position='none',\n    )\n)\nplot.show()"
  },
  {
    "objectID": "gallery/weather-forecast.html#plot-with-weather-icons",
    "href": "gallery/weather-forecast.html#plot-with-weather-icons",
    "title": "Weather Forecast",
    "section": "Plot with weather icons",
    "text": "Plot with weather icons\nLet’s take a quick look at using watermark to add .png images to a plot. The watermark feature takes the path to an image, and x and y pixel coordinates, then places the image with respect to the origin, [0, 0], which is the bottom-left corner of the plot.\nI didn’t expect it to work but I did try using an .svg image with watermark and it didn’t work.\n\n# add 3 weather icons to the plot in the bottom-left corner\n(\n    plot\n    + p9.watermark('./img/misc/weather-forecast/drizzle_32px.png')\n    + p9.watermark('./img/misc/weather-forecast/rain_32px.png', xo=40, yo=10)\n    + p9.watermark('./img/misc/weather-forecast/heavy_rain_32px.png', xo=80, yo=20)\n).show()\n\n\n\n\n\n\n\n\nSince the coordinates are in pixels, this makes things a little trickier. To handle this, I created a version of the plot at a specific resolution to figure out where the place the icons for each day. I’m not going to use plot.show() since the placement probably will look off, but I’ll save the plot to a file and then display it in this jupyter notebook.\n\nraw_data\n\n\nshape: (7, 4)\n\n\n\nDay\nLow\nHigh\nConditions\n\n\ncat\ni64\ni64\nstr\n\n\n\n\n\"Today\"\n65\n77\n\"Cloudy\"\n\n\n\"Mon\"\n61\n84\n\"Sunny\"\n\n\n\"Tue\"\n67\n93\n\"Hot\"\n\n\n\"Wed\"\n59\n76\n\"Drizzle\"\n\n\n\"Thu\"\n54\n75\n\"Windy\"\n\n\n\"Fri\"\n57\n81\n\"Partly cloudy\"\n\n\n\"Sat\"\n60\n71\n\"Heavy rain\"\n\n\n\n\n\n\n\nplot_w_icons = plot\nxo = 120\nyo_max = 509\nyo_mod = 78\n\nrows = raw_data.rows(named=True)\nfor i, row in enumerate(rows):\n    yo = yo_max - i * yo_mod\n    plot_w_icons = (\n        plot_w_icons \n        + p9.watermark(f'./img/misc/weather-forecast/{row[\"Conditions\"].lower().replace(\" \", \"_\")}_32px.png', xo=xo, yo=yo)\n    )\n\nHere’s the final plot:\n\n\n\n7-day forecast\n\n\nI think this is a satisfying detail: zoom into the extreme low or high temperature on the plot and see the border formed by the underlayment around the temperature range.\n\n\n\nplot zoom"
  },
  {
    "objectID": "guide/aesthetic-mappings.html",
    "href": "guide/aesthetic-mappings.html",
    "title": "Aesthetic mappings",
    "section": "",
    "text": "The aes() function maps columns of data onto graphical attributes–such as colors, shapes, or x and y coordinates. (aes() is short for aesthetic). It can be specified at the plot level, as well as at the individual geom level.\nThis page will cover the basics of specifying mappings and how they interact with geoms.",
    "crumbs": [
      "Guide",
      "Basics",
      "Aesthetic mappings"
    ]
  },
  {
    "objectID": "guide/aesthetic-mappings.html#setup",
    "href": "guide/aesthetic-mappings.html#setup",
    "title": "Aesthetic mappings",
    "section": "Setup",
    "text": "Setup\n\nfrom plotnine import *\nfrom plotnine.data import penguins",
    "crumbs": [
      "Guide",
      "Basics",
      "Aesthetic mappings"
    ]
  },
  {
    "objectID": "guide/aesthetic-mappings.html#basics",
    "href": "guide/aesthetic-mappings.html#basics",
    "title": "Aesthetic mappings",
    "section": "Basics",
    "text": "Basics\nThe simplest way to specify aesthetic mappings is through passing aes() to the ggplot(mapping = ...) argument. This is shown below, with flipper_length_mm and body_mass_g mapped to the x- and y- axes.\n\n(\n    ggplot(\n      data = penguins,\n      mapping = aes(x = \"flipper_length_mm\", y = \"body_mass_g\")\n    )\n    + geom_point()\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Aesthetic mappings"
    ]
  },
  {
    "objectID": "guide/aesthetic-mappings.html#variable-mappings",
    "href": "guide/aesthetic-mappings.html#variable-mappings",
    "title": "Aesthetic mappings",
    "section": "Variable mappings",
    "text": "Variable mappings\nWhen a mapping in aes() references a column of data, it is called a variable mapping—since the values of the column are used to determine the appearance of the plot. Below are some plots with variable mappings to different columns of data (e.g flipper_length_mm, body_mass_g, species).\n\nColorShapeSize and alpha\n\n\n\n(\n    ggplot(\n        penguins,\n        aes(x = \"flipper_length_mm\", y = \"body_mass_g\", color = \"species\")\n    ) +\n    geom_point()\n)\n\n\n\n\n\n\n\n\n\n\n\n(\n    ggplot(\n        penguins,\n        aes(\n            x=\"flipper_length_mm\", y=\"body_mass_g\", shape=\"species\"\n        ),\n    )\n    + geom_point()\n)\n\n\n\n\n\n\n\n\n\n\n\n(\n    ggplot(\n        penguins,\n        aes(\n            x=\"flipper_length_mm\",\n            y=\"body_mass_g\",\n            size=\"body_mass_g\",\n            alpha=\"body_mass_g\",\n        ),\n    )\n    + geom_point()\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Aesthetic mappings"
    ]
  },
  {
    "objectID": "guide/aesthetic-mappings.html#literal-mappings",
    "href": "guide/aesthetic-mappings.html#literal-mappings",
    "title": "Aesthetic mappings",
    "section": "Literal mappings",
    "text": "Literal mappings\nIn order to set a mapping to a literal value, pass the value directly to the geom. For example, the code below sets size=, alpha=, and color= to specific values.\n\n(\n    ggplot(\n        penguins,\n        aes(x=\"flipper_length_mm\", y=\"body_mass_g\"),\n    )\n    + geom_point(size=7, alpha=.5, color=\"purple\")\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Aesthetic mappings"
    ]
  },
  {
    "objectID": "guide/aesthetic-mappings.html#aes-inside-a-specific-geom",
    "href": "guide/aesthetic-mappings.html#aes-inside-a-specific-geom",
    "title": "Aesthetic mappings",
    "section": "aes() inside a specific geom",
    "text": "aes() inside a specific geom\nAn aes() mapping can be applied to a single geom, by passing it directly to the geom call. For example, the code below sets color for one point, and shape for another.\n\n(\n    ggplot(\n        penguins,\n        aes(x=\"flipper_length_mm\", y=\"body_mass_g\"),\n    )\n    + geom_point(aes(color=\"species\"), size=5)   # big circle points\n    + geom_point(aes(shape=\"species\"))           # shape points\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Aesthetic mappings"
    ]
  },
  {
    "objectID": "guide/aesthetic-mappings.html#aes-collective-groupings",
    "href": "guide/aesthetic-mappings.html#aes-collective-groupings",
    "title": "Aesthetic mappings",
    "section": "aes() collective groupings",
    "text": "aes() collective groupings\nSome geoms accept a aes(group=...). These are called collective geoms, because they group data points together. For example, geom_smooth() fits a trend line to the data, and the group mapping tells it to create a separate line per grouping in the data.\nThis is shown below, with a trend line created for each of the three species of penguins.\n\n(\n    ggplot(\n        penguins,\n        aes(x=\"flipper_length_mm\", y=\"body_mass_g\", group=\"species\"),\n    )\n    + geom_point()\n    + geom_smooth(method=\"lm\")\n)\n\n\n\n\n\n\n\n\n\nAutomatic groupings\nMappings attributes like color will automatically group data points for collective geoms, even if group isn’t specified.\n\n(\n    ggplot(\n        penguins,\n        aes(x=\"flipper_length_mm\", y=\"body_mass_g\", color=\"species\"),\n    )\n    + geom_point()\n    + geom_smooth(method=\"lm\")\n)\n\n\n\n\n\n\n\n\n\n\nWorking around grouping\nTo avoid automatically splitting data into groups, try setting aesthetics like color or fill at the individual geom level.\nFor example, the plot below colors points by species, but with only a single trend line.\n\n(\n    ggplot(\n        penguins,\n        aes(x=\"flipper_length_mm\", y=\"body_mass_g\"),\n    )\n    + geom_point(aes(color=\"species\"))\n    + geom_smooth(method=\"lm\")\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Aesthetic mappings"
    ]
  },
  {
    "objectID": "guide/aesthetic-mappings.html#mappings-allow-expressions",
    "href": "guide/aesthetic-mappings.html#mappings-allow-expressions",
    "title": "Aesthetic mappings",
    "section": "Mappings allow expressions",
    "text": "Mappings allow expressions\nMappings passed to aes() can be expression strings.\nFor example, you could make a scatterplot with bill_length_mm / bill_depth_mm on the x-axis as follows.\n\n(\n    ggplot(\n        penguins,\n        aes(x=\"bill_length_mm / bill_depth_mm\", y=\"body_mass_g\"),\n    )\n    + geom_point(aes(color=\"species\"))\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Aesthetic mappings"
    ]
  },
  {
    "objectID": "guide/annotations.html",
    "href": "guide/annotations.html",
    "title": "Annotations",
    "section": "",
    "text": "This page covers how to describe or emphasize data with annotations in plots. This includes labelling points, adding arrows, and highlighting areas of interest. It also describes how to tackle the common issue of overlapping text labels.",
    "crumbs": [
      "Guide",
      "Polishing",
      "Annotations"
    ]
  },
  {
    "objectID": "guide/annotations.html#setup",
    "href": "guide/annotations.html#setup",
    "title": "Annotations",
    "section": "Setup",
    "text": "Setup\n\nfrom plotnine import *\nfrom plotnine.data import penguins",
    "crumbs": [
      "Guide",
      "Polishing",
      "Annotations"
    ]
  },
  {
    "objectID": "guide/annotations.html#annotate",
    "href": "guide/annotations.html#annotate",
    "title": "Annotations",
    "section": "annotate()",
    "text": "annotate()\nUse annotate() to write some text on a plot.\n\nr_coef = penguins[\"flipper_length_mm\"].corr(penguins[\"body_mass_g\"])\np = (\n    ggplot(penguins, aes(\"flipper_length_mm\", \"body_mass_g\"))\n    + geom_point()\n    + geom_smooth(method=\"lm\")\n    + annotate(\n        \"text\",\n        x=180,\n        y=5750,\n        label=f\"r = {r_coef:.2f}\",\n        color=\"blue\",\n        size=20,\n    )\n)\n\np\n\n\n\n\n\n\n\n\nNotice that the correlation coefficient is shown on the top-left of the plot. The first argument to annotate, specifies the geom to use (in this case, the \"text\" means to use geom_text()).\nIn order to use annotate with another geom, pass the name of the geom as the first argument. For example, the code below draws a rectangle around the text.\n\np + annotate(\"rect\", xmin=170, xmax=190, ymin=5500, ymax=6000, color=\"blue\", fill=None)\n\n\n\n\n\n\n\n\nNote that annotate() takes the same arguments as the corresponding geom_*() class (in this case, geom_rect()).",
    "crumbs": [
      "Guide",
      "Polishing",
      "Annotations"
    ]
  },
  {
    "objectID": "guide/annotations.html#geom_textpath_effects...",
    "href": "guide/annotations.html#geom_textpath_effects...",
    "title": "Annotations",
    "section": "geom_text(path_effects=...)",
    "text": "geom_text(path_effects=...)\nUse the geom_text(path_effects=...) argument to add more complex styling to your text. This argument takes a list of objects created by the matplotlib.patheffects submodule.\n\nimport matplotlib.patheffects as pe\n\neffect = [\n    pe.PathPatchEffect(offset=(4, -4), hatch=\"xxxx\", facecolor=\"gray\"),\n    pe.PathPatchEffect(edgecolor=\"white\", linewidth=1.1, facecolor=\"black\"),\n]\n\n(\n    ggplot(penguins, aes(x=\"flipper_length_mm\", y=\"body_mass_g\"))\n    + geom_point()\n    + annotate(\"text\", x=180, y=5750, label=\"YO\", path_effects=effect, size=75)\n)",
    "crumbs": [
      "Guide",
      "Polishing",
      "Annotations"
    ]
  },
  {
    "objectID": "guide/annotations.html#geom_textadjust_text...",
    "href": "guide/annotations.html#geom_textadjust_text...",
    "title": "Annotations",
    "section": "geom_text(adjust_text=...)",
    "text": "geom_text(adjust_text=...)\nUse the geom_text(adjust_text=...) argument to adjust the position of text labels so they don’t overlap. This argument takes a dictionary that gets passed to the adjustText package’s adjust_text() function.\n\nfrom plotnine.data import mpg\n\n(\n    ggplot(mpg.drop_duplicates(\"model\"), aes(\"displ\", \"hwy\", label=\"model\"))\n    + geom_point()\n    + geom_text(adjust_text={\"arrowprops\": {\"arrowstyle\": \"-\"}})\n)\n\n0 [-0.44148583  0.9383059 ]\n37 [ 0.47179786 -0.16812717]\n35 [0.61017256 0.04058697]\n36 [0.24812797 0.69748401]",
    "crumbs": [
      "Guide",
      "Polishing",
      "Annotations"
    ]
  },
  {
    "objectID": "guide/annotations.html#styling-text",
    "href": "guide/annotations.html#styling-text",
    "title": "Annotations",
    "section": "Styling text",
    "text": "Styling text\nCurrently, styling text requires manually handling matplotlib objects (which plotnine builds on top of). See the blogpost “Annotated area charts with plotnine” for a walkthrough of creating custom text.",
    "crumbs": [
      "Guide",
      "Polishing",
      "Annotations"
    ]
  },
  {
    "objectID": "guide/annotations.html#emphasis-with-shading",
    "href": "guide/annotations.html#emphasis-with-shading",
    "title": "Annotations",
    "section": "Emphasis with shading",
    "text": "Emphasis with shading\n\nimport math\nimport pandas as pd\nfrom plotnine.data import huron\n\ndroughts = pd.DataFrame(\n    {\n        \"start\": [1930, 1960],\n        \"stop\": [1937, 1967],\n    }\n)\n\n(\n    ggplot(huron)\n    + geom_line(aes(\"year\", \"level\"))\n    + geom_rect(\n        aes(xmin=\"start\", xmax=\"stop\"),\n        ymin=-math.inf,\n        ymax=math.inf,\n        alpha=0.2,\n        fill=\"red\",\n        data=droughts,\n    )\n    + labs(\n        title=\"Lake Huron Water Levels\",\n        subtitle=\"(famous droughts marked in red)\",\n    )\n)",
    "crumbs": [
      "Guide",
      "Polishing",
      "Annotations"
    ]
  },
  {
    "objectID": "guide/annotations.html#emphasis-with-arrows",
    "href": "guide/annotations.html#emphasis-with-arrows",
    "title": "Annotations",
    "section": "Emphasis with arrows",
    "text": "Emphasis with arrows\n\nfrom plotnine.data import economics\n\n(\n    ggplot(economics, aes(\"date\", \"unemploy\"))\n    + geom_line()\n    + scale_x_date(breaks=\"10 years\")\n    + annotate(\n        \"segment\",\n        x=\"2004-01-01\",\n        y=13000,\n        xend=\"2007-01-01\",\n        yend=7600,\n        color=\"red\",\n        arrow=arrow(length=0.2),\n    )\n    + annotate(\n        \"text\",\n        x=\"2004-01-01\",\n        y=13000,\n        label=\"Great Recession\",\n        color=\"red\",\n        size=20,\n        ha=\"right\",\n        nudge_x=-100,\n    )\n)",
    "crumbs": [
      "Guide",
      "Polishing",
      "Annotations"
    ]
  },
  {
    "objectID": "guide/case-study2.html",
    "href": "guide/case-study2.html",
    "title": "Case study 2",
    "section": "",
    "text": "Something similar to https://github.com/machow/coffee-sales-data, designed to show something compelling, that is a good intro to some facet of using plotnine."
  },
  {
    "objectID": "guide/coordinate-systems.html",
    "href": "guide/coordinate-systems.html",
    "title": "Coordinate systems",
    "section": "",
    "text": "Coordinate systems determine how the x- and y-axes of a plot are drawn. For example, coord_flip() switches the x- and y-axes, while coord_fixed() ensures they have the same spacing.",
    "crumbs": [
      "Guide",
      "Basics",
      "Coordinate systems"
    ]
  },
  {
    "objectID": "guide/coordinate-systems.html#setup",
    "href": "guide/coordinate-systems.html#setup",
    "title": "Coordinate systems",
    "section": "Setup",
    "text": "Setup\n\nfrom plotnine import *\nfrom plotnine.data import diamonds, mpg",
    "crumbs": [
      "Guide",
      "Basics",
      "Coordinate systems"
    ]
  },
  {
    "objectID": "guide/coordinate-systems.html#coord_flip",
    "href": "guide/coordinate-systems.html#coord_flip",
    "title": "Coordinate systems",
    "section": "coord_flip()",
    "text": "coord_flip()\nUse coord_flip() to switch the x- and y-axes of your plot.\np = ggplot(diamonds, aes(\"cut\")) + geom_bar()\n\np\np + coord_flip()\n\n\n\n\n\n\n\n\n\n\nNotice that cut is the x-axis on the default plot (left), but the y-axis of the flipped one (right). This can be helpful for barplots with many individually labeled bars, since the labels won’t overlap with eachother. It can also be useful for taking advantage of wider plots.\nFlipped plots use the original axis names for setting titles and scales, but the final plot axis names for theme options.\n\n(\n    ggplot(diamonds, aes(\"cut\"))\n    + geom_bar()\n    + coord_flip()\n\n    # labs and scales are based on original, non-flipped plot\n    + labs(x = \"Diamond Cut\", y = \"Count\")\n    + scale_y_continuous(breaks = [0, 10_000, 20_000])\n\n    # theme options are based on the flipped plot\n    + theme(axis_line_x=element_line(color=\"purple\"))\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Coordinate systems"
    ]
  },
  {
    "objectID": "guide/coordinate-systems.html#coord_cartesian",
    "href": "guide/coordinate-systems.html#coord_cartesian",
    "title": "Coordinate systems",
    "section": "coord_cartesian()",
    "text": "coord_cartesian()\nUse coord_cartesian() to zoom in on a plot.\np = ggplot(diamonds, aes(\"cut\", \"price\")) + geom_boxplot()\n\np\np + coord_cartesian(ylim = [5000, None])\n\n\n\n\n\n\n\n\n\n\nNotice that the second plot is zoomed in, so the y-axis starts at the top of the boxplots. Importantly, coord_cartesian() doesn’t affect any statistical calculations.\nBy contrast, setting limits in scales excludes any data outside those limits.\n\np + scale_y_continuous(limits = [5000, None])\n\n\n\n\n\n\n\n\nNotice that in the plot above, scale_y_continuous excluded y-values under 5,000 from being used in calculating the boxplot.",
    "crumbs": [
      "Guide",
      "Basics",
      "Coordinate systems"
    ]
  },
  {
    "objectID": "guide/coordinate-systems.html#coord_fixed",
    "href": "guide/coordinate-systems.html#coord_fixed",
    "title": "Coordinate systems",
    "section": "coord_fixed()",
    "text": "coord_fixed()\nUse coord_fixed() to ensure the x- and y-axes have the same spacing.\n\n(\n    ggplot(mpg, aes(\"cty\", \"hwy\"))\n    + coord_fixed(xlim=[0, None], ylim=[0,None])\n    + geom_point()\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Coordinate systems"
    ]
  },
  {
    "objectID": "guide/coordinate-systems.html#cartographic-maps",
    "href": "guide/coordinate-systems.html#cartographic-maps",
    "title": "Coordinate systems",
    "section": "Cartographic maps",
    "text": "Cartographic maps\nWhile currently not available as a coordinate system, Plotnine supports maps using geom_map(). In the future, maps will have a coord_map() function.\nHere is an example which uses geopandas to plot grocery stores in Chicago.\n\nimport geopandas as gp\nimport geodatasets\n\nchicago = gp.read_file(geodatasets.get_path(\"geoda.chicago_commpop\"))\ngroceries = gp.read_file(geodatasets.get_path(\"geoda.groceries\"))\n\n(\n    ggplot(chicago)\n    + geom_map(fill=None)\n    + theme_void()\n    + coord_fixed()\n)\n\n\n\n\n\n\n\n\nNotice that coord_fixed() was used to avoid stretching the map along the x- or y-axis. In addition, theme_void() removed the x- and y- tick marks, and labels.\nYou can plot multiple layers on the same map by using multiple geom_map() calls with different data= arguments.\n\ncrs_groceries = groceries.to_crs(chicago.crs)\n\n(\n    ggplot()\n    + geom_map(data=chicago, fill=None)\n    + geom_map(data=crs_groceries, color=\"green\")\n    + theme_void()\n    + coord_fixed()\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Coordinate systems"
    ]
  },
  {
    "objectID": "guide/facets.html",
    "href": "guide/facets.html",
    "title": "Facets (subplots)",
    "section": "",
    "text": "Facets split a plot into multiple subplots, based on one or more variables. facet_wrap() creates a sequence of subplots, while facet_grid() creates a matrix of subplots.",
    "crumbs": [
      "Guide",
      "Basics",
      "Facets (subplots)"
    ]
  },
  {
    "objectID": "guide/facets.html#setup",
    "href": "guide/facets.html#setup",
    "title": "Facets (subplots)",
    "section": "Setup",
    "text": "Setup\n\nfrom plotnine import *\nfrom plotnine.data import mpg, penguins\n\nHere is a single big plot that you might want to split into subplots.\n\n(\n    ggplot(mpg, aes(\"displ\", \"hwy\", color=\"class\")) + geom_point()\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Facets (subplots)"
    ]
  },
  {
    "objectID": "guide/facets.html#facet_wrap-subplot-sequence",
    "href": "guide/facets.html#facet_wrap-subplot-sequence",
    "title": "Facets (subplots)",
    "section": "facet_wrap(): subplot sequence",
    "text": "facet_wrap(): subplot sequence\nUse facet_wrap() to create a sequence of subplots. It accepts as its first argument the name of the column that should be used to split the data for subplots.\n\n(\n    ggplot(mpg, aes(\"displ\", \"hwy\", color=\"class\"))\n    + geom_point(show_legend=False)\n    + facet_wrap(\"class\")\n)\n\n\n\n\n\n\n\n\nNote that by default facet_wrap() fills row-by-row, with defaults for the number of subplots per row and column. Use either the ncol= or nrow= argument to fix the number of plots per column or row, respectively.\n\n(\n    ggplot(mpg, aes(\"displ\", \"hwy\", color=\"class\"))\n    + geom_point(show_legend=False)\n    + facet_wrap(\"class\", ncol=2)\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Facets (subplots)"
    ]
  },
  {
    "objectID": "guide/facets.html#facet_grid-subplot-matrix",
    "href": "guide/facets.html#facet_grid-subplot-matrix",
    "title": "Facets (subplots)",
    "section": "facet_grid(): subplot matrix",
    "text": "facet_grid(): subplot matrix\nUse facet_grid() to create a matrix of subplots. It accepts two column names as arguments, the first for the rows and the second for the columns.\n\n(ggplot(mpg, aes(\"displ\", \"hwy\")) + geom_point() + facet_grid(\"cyl\", \"year\"))",
    "crumbs": [
      "Guide",
      "Basics",
      "Facets (subplots)"
    ]
  },
  {
    "objectID": "guide/facets.html#facetting-syntax",
    "href": "guide/facets.html#facetting-syntax",
    "title": "Facets (subplots)",
    "section": "facetting syntax",
    "text": "facetting syntax\nBoth facet_wrap() and facet_grid() support a special syntax for defining subplots. It takes the form \"var1 ~ var2 + var3\"\n\n(ggplot(mpg, aes(\"displ\", \"hwy\")) + geom_point() + facet_grid(\"cyl ~ year\"))\n\n\n\n\n\n\n\n\nNotice that cyl values (e.g. 4, 5, 6, 8) are on the rows, while year values are on the columns.\nThe column names to the left of the tilde (~) define subplot rows, while those to the right define subplot columns. The plus sign (+) groups variables for creating subplots.",
    "crumbs": [
      "Guide",
      "Basics",
      "Facets (subplots)"
    ]
  },
  {
    "objectID": "guide/facets.html#scales-for-freeing-axes",
    "href": "guide/facets.html#scales-for-freeing-axes",
    "title": "Facets (subplots)",
    "section": "scales= for freeing axes",
    "text": "scales= for freeing axes\nBy default, the x- and y-axes of each subplot have the same range. Use the scales= argument to allow each row or column to have its own range.\n\n(\n    ggplot(mpg, aes(\"displ\", \"hwy\"))\n    + geom_point()\n    + facet_grid(\"cyl ~ year\", scales=\"free_y\")\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Facets (subplots)"
    ]
  },
  {
    "objectID": "guide/geom-cheatsheet.html",
    "href": "guide/geom-cheatsheet.html",
    "title": "plotnine {{< var version >}}",
    "section": "",
    "text": "from https://ggplot2-book.org/layers.html#sec-position\n\nGraphical primitives:\n\ngeom_blank(): display nothing. Most useful for adjusting axes limits using data.\ngeom_point(): points.\ngeom_path(): paths.\ngeom_ribbon(): ribbons, a path with vertical thickness.\ngeom_segment(): a line segment, specified by start and end position.\ngeom_rect(): rectangles.\ngeom_polygon(): filled polygons.\ngeom_text(): text.\n\nOne variable:\n\nDiscrete:\n\ngeom_bar(): display distribution of discrete variable.\n\nContinuous:\n\ngeom_histogram(): bin and count continuous variable, display with bars.\ngeom_density(): smoothed density estimate.\ngeom_dotplot(): stack individual points into a dot plot.\ngeom_freqpoly(): bin and count continuous variable, display with lines.\n\n\nTwo variables:\n\nBoth continuous:\n\ngeom_point(): scatterplot.\ngeom_quantile(): smoothed quantile regression.\ngeom_rug(): marginal rug plots.\ngeom_smooth(): smoothed line of best fit.\ngeom_text(): text labels.\nShow distribution:\ngeom_bin2d(): bin into rectangles and count.\ngeom_density2d(): smoothed 2d density estimate.\ngeom_hex(): bin into hexagons and count.\n\nAt least one discrete:\n\ngeom_count(): count number of point at distinct locations\ngeom_jitter(): randomly jitter overlapping points.\nOne continuous, one discrete:\ngeom_bar(stat = “identity”): a bar chart of precomputed summaries.\ngeom_boxplot(): boxplots.\ngeom_violin(): show density of values in each group.\n\nOne time, one continuous:\n\ngeom_area(): area plot.\ngeom_line(): line plot.\ngeom_step(): step plot.\n\n\nDisplay uncertainty:\n\ngeom_crossbar(): vertical bar with center.\ngeom_errorbar(): error bars.\ngeom_linerange(): vertical line.\ngeom_pointrange(): vertical line with center.\n\nSpatial:\n\ngeom_map(): fast version of geom_polygon() for map data.\n\nThree variables:\n\ngeom_contour(): contours.\ngeom_tile(): tile the plane with rectangles.\ngeom_raster(): fast version of geom_tile() for equal sized tiles."
  },
  {
    "objectID": "guide/install.html",
    "href": "guide/install.html",
    "title": "Installation",
    "section": "",
    "text": "For most users, we recommend installing the official release of Plotnine.\n\nInstalling the official release\nThe official release can be installed from the command line using either pip, uv, or conda:\n# Using pip:\n$ pip install plotnine\n\n# Using uv:\n$ uv pip install plotnine\n\n# Using conda:\n$ conda install -c conda-forge plotnine\n\n\n\n\n\n\nNote\n\n\n\nFor uv you need to have a virtual environment, which you can create using uv venv. Read more information about installing and using uv.\n\n\nFor some functionality you may need to install extra packages. Those packages include:\n\nadjustText: For automatic label placement\ngeopandas: For working with for geographic data\nscikit-learn: For Gaussian Process smoothing\nscikit-misc: For LOESS smoothing\n\nThese four packages can be installed in one go by specifying 'plotnine[extra]' instead of plotnine:\n# Using pip:\n$ pip install 'plotnine[extra]'\n\n# Using uv:\n$ uv pip install 'plotnine[extra]'\n\n# Using conda:\n$ conda install -c conda-forge 'plotnine[extra]'\n\n\nInstalling the development version\nPlotnine is under active development. It may happen that a bugfix or new feature is not yet available in the official release. In those cases you can install the latest development version from GitHub:\n# Using pip:\n$ pip install git+https://github.com/has2k1/plotnine.git\n\n# Using uv:\n$ uv pip install git+https://github.com/has2k1/plotnine.git\nTo contribute to Plotnine’s source code, you have to clone the Plotnine source repository and install the package in development mode:\n$ git clone https://github.com/has2k1/plotnine.git\n$ cd plotnine\n$ pip install -e .",
    "crumbs": [
      "Guide",
      "Miscellaneous",
      "Installation"
    ]
  },
  {
    "objectID": "guide/labels.html",
    "href": "guide/labels.html",
    "title": "Labels and titles",
    "section": "",
    "text": "You will learn\n\n\n\n\nHow to categorize the three kinds of labels in a plot.\nHow to set each kind of label.\nHow to style labels (e.g. with color).",
    "crumbs": [
      "Guide",
      "Polishing",
      "Labels and titles"
    ]
  },
  {
    "objectID": "guide/labels.html#setup",
    "href": "guide/labels.html#setup",
    "title": "Labels and titles",
    "section": "Setup",
    "text": "Setup\n\nfrom plotnine import *\nfrom plotnine.data import penguins\n\np = (\n    ggplot(penguins, aes(\"flipper_length_mm\", \"body_mass_g\", color=\"species\"))\n    + geom_point()\n)",
    "crumbs": [
      "Guide",
      "Polishing",
      "Labels and titles"
    ]
  },
  {
    "objectID": "guide/labels.html#three-kinds-of-labels",
    "href": "guide/labels.html#three-kinds-of-labels",
    "title": "Labels and titles",
    "section": "Three kinds of labels",
    "text": "Three kinds of labels\nHere is a plot, with the three kinds of labels marked.\n\n\nPlot labels: titles, subtitles, captions. (Shown in purple).\nGuide names: axis labels, legend titles. (Shown in red).\nScale breaks: tick labels, color glyph labels. (Shown in orange).\n\nIn the following sections, we’ll cover how the first two kinds of labels can quickly be set with the labs() function, and how scale breaks can be labeled using scale_*() functions.",
    "crumbs": [
      "Guide",
      "Polishing",
      "Labels and titles"
    ]
  },
  {
    "objectID": "guide/labels.html#labelling-quickly-with-labs",
    "href": "guide/labels.html#labelling-quickly-with-labs",
    "title": "Labels and titles",
    "section": "Labelling quickly with labs()",
    "text": "Labelling quickly with labs()\nUse the labs() function to quickly set plot labels and guide names.\n\np + labs(\n    title=\"Penguin flipper length vs body mass\",\n    x=\"Flipper length (mm)\",\n    y=\"Body mass (g)\",\n    color=\"SPECIES\",\n)\n\n\n\n\n\n\n\n\nNotice that the only piece it can’t set is the break labels (e.g. the x-axis tick labels), which is often enough for most plots.",
    "crumbs": [
      "Guide",
      "Polishing",
      "Labels and titles"
    ]
  },
  {
    "objectID": "guide/labels.html#styling-labels-with-theme",
    "href": "guide/labels.html#styling-labels-with-theme",
    "title": "Labels and titles",
    "section": "Styling labels with theme()",
    "text": "Styling labels with theme()\nUse the theme() function to style labels. For example, by changing their color or size.\n\n(\n    ggplot(penguins, aes(\"flipper_length_mm\", \"body_mass_g\"))\n    + geom_point()\n    + theme(\n        axis_text_x=element_text(color=\"orange\"),\n        axis_title_x=element_text(color=\"blue\", size=16),\n    )\n)",
    "crumbs": [
      "Guide",
      "Polishing",
      "Labels and titles"
    ]
  },
  {
    "objectID": "guide/labels.html#scale-breaks-labels",
    "href": "guide/labels.html#scale-breaks-labels",
    "title": "Labels and titles",
    "section": "Scale breaks labels",
    "text": "Scale breaks labels\nUse the labels= arguments to the appropriate scale_*() function, in order to customize break labels.\nFor example, the code below changes the y-axis labels from grams to kilograms.\n\n(\n    p\n    + scale_y_continuous(labels=lambda x: [val / 1_000 for val in x])\n    + labs(y=\"Body mass (kg)\")\n)\n\n\n\n\n\n\n\n\nSee Scale basics for more on setting break labels.",
    "crumbs": [
      "Guide",
      "Polishing",
      "Labels and titles"
    ]
  },
  {
    "objectID": "guide/overview.html",
    "href": "guide/overview.html",
    "title": "Overview",
    "section": "",
    "text": "This page provides an overview of Plotnine’s most important concepts and corresponding syntax. Throughout this overview, we’ll focus on reproducing the plot below, which looks at city (cty) versus highway mileage (hwy) across different years of cars:\nCode\nfrom plotnine import *\nfrom plotnine.data import mpg\n\n(\n    ggplot(mpg, aes(\"cty\", \"hwy\"))\n    + geom_point(mapping=aes(colour=\"displ\"))\n    + geom_smooth(method=\"lm\", color=\"blue\")\n    + scale_color_continuous(cmap_name=\"viridis\")\n    + facet_grid(\"year ~ drv\")\n    + coord_fixed()\n    + theme_minimal()\n    + theme(panel_grid_minor=element_blank())\n)",
    "crumbs": [
      "Guide",
      "Overview"
    ]
  },
  {
    "objectID": "guide/overview.html#specifying-data",
    "href": "guide/overview.html#specifying-data",
    "title": "Overview",
    "section": "Specifying data",
    "text": "Specifying data\nEvery plot in Plotnine starts with passing data to the ggplot() function. The data can be a Pandas or Polars DataFrame. Plotnine works best when the data is in a tidy format, which tends to be longer—with more rows and fewer columns.\n\nfrom plotnine import *\nfrom plotnine.data import mpg\n\nggplot(data=mpg)",
    "crumbs": [
      "Guide",
      "Overview"
    ]
  },
  {
    "objectID": "guide/overview.html#aes-mapping",
    "href": "guide/overview.html#aes-mapping",
    "title": "Overview",
    "section": "aes() mapping",
    "text": "aes() mapping\nThe aes() function maps columns of data onto graphical attributes–such as colors, shapes, or x and y coordinates. (The name aes() is short for aesthetic.)\nWe can map the cty and hwy columns to the x- and y- coordinates in the plot using the code below:\n\nggplot(data=mpg, mapping = aes(x = \"cty\", y = \"hwy\"))",
    "crumbs": [
      "Guide",
      "Overview"
    ]
  },
  {
    "objectID": "guide/overview.html#geom_-objects",
    "href": "guide/overview.html#geom_-objects",
    "title": "Overview",
    "section": "geom_*() objects",
    "text": "geom_*() objects\nFunctions starting with geom_*() specify geometric objects (geoms) to add to the plot. Geoms determine how to turn mapped data into visual elements–such as points, lines, or even boxplots.\nHere is how we can map the cty and hwy columns to points with a smooth trend line on top:\n\n(\n    ggplot(mpg, aes(\"cty\", \"hwy\"))\n    # to create a scatterplot\n    + geom_point()\n    # to fit and overlay a loess trendline\n    + geom_smooth(method=\"lm\", color=\"blue\")\n)",
    "crumbs": [
      "Guide",
      "Overview"
    ]
  },
  {
    "objectID": "guide/overview.html#scale_-translations",
    "href": "guide/overview.html#scale_-translations",
    "title": "Overview",
    "section": "scale_*() translations",
    "text": "scale_*() translations\nThe scale_*() functions customize the styling of visual elements from a data mapping. This includes color palettes, axis spacing (e.g. log scale), axis limits, and more. Scales can set the names on guides like axes, legends, and colorbars.\nThe names of scales follow the pattern scale_&lt;aesthetic&gt;_&lt;type&gt;, where &lt;aesthetic&gt; is the name of an aesthetic attribute, like x, y, or color. If we want to use the plasma palette for color, we can use the code below:\n\n(\n    ggplot(mpg, aes(\"cty\", \"hwy\", color=\"displ\"))\n    + geom_point()\n    + scale_color_continuous(name=\"displ (VIRIDIS)\", cmap_name=\"viridis\")\n)",
    "crumbs": [
      "Guide",
      "Overview"
    ]
  },
  {
    "objectID": "guide/overview.html#position_-adjustments",
    "href": "guide/overview.html#position_-adjustments",
    "title": "Overview",
    "section": "position_*() adjustments",
    "text": "position_*() adjustments\nThe position_*() functions adjust the position of elements in the plot. For example, by adding a small amount of random noise (jitter) to the x- and y- coordinates of points, so they don’t cover each other.\n\n(\n    ggplot(mpg, aes(\"cty\", \"hwy\", color=\"displ\"))\n    # add a small amount of jitter\n    + geom_point(position=position_jitter())\n)",
    "crumbs": [
      "Guide",
      "Overview"
    ]
  },
  {
    "objectID": "guide/overview.html#facet_-subplots",
    "href": "guide/overview.html#facet_-subplots",
    "title": "Overview",
    "section": "facet_*() subplots",
    "text": "facet_*() subplots\nFacets split a plot into multiple subplots. The two facet functions, facet_grid() and facet_wrap(), determine how to split the data. For example, we can create a grid of plots based on the year and drv columns:\n\n(\n    ggplot(mpg, aes(\"cty\", \"hwy\"))\n    + geom_point()\n    # facet into subplots\n    + facet_grid(\"year ~ drv\")\n)",
    "crumbs": [
      "Guide",
      "Overview"
    ]
  },
  {
    "objectID": "guide/overview.html#coord_-projections",
    "href": "guide/overview.html#coord_-projections",
    "title": "Overview",
    "section": "coord_*() projections",
    "text": "coord_*() projections\nThe coord_*() functions specify the coordinate system of the plot. Currently, only a few coordinate systems are available. However, in the future systems like coord_polar() will allow for plotting using polar coordinates.\nThe code below uses coord_fixed() to ensure that the x- and y- axes have the same spacing.\n\n(\n    ggplot(mpg, aes(\"cty\", \"hwy\"))\n    + geom_point()\n    + coord_fixed(xlim=[0, 40], ylim=[0, 40])\n)",
    "crumbs": [
      "Guide",
      "Overview"
    ]
  },
  {
    "objectID": "guide/overview.html#theme_-styling",
    "href": "guide/overview.html#theme_-styling",
    "title": "Overview",
    "section": "theme_*() styling",
    "text": "theme_*() styling\nThemes control the style of all aspects of the plot that are not decided by the data. This includes the position of the legend, the color of the axes, the size of the text, and much more.\nUse the theme_*() functions to start with a pre-made theme, or the general theme() function to create a new custom theme. Use the element_*() functions to configure new theme settings.\n\n(\n    ggplot(mpg, aes(\"cty\", \"hwy\", colour=\"class\"))\n    + geom_point()\n    + theme_minimal()\n    + theme(\n        legend_position=\"top\",\n        axis_line=element_line(linewidth=0.75),\n        axis_line_x=element_line(colour=\"blue\"),\n    )\n)",
    "crumbs": [
      "Guide",
      "Overview"
    ]
  },
  {
    "objectID": "guide/overview.html#putting-it-together",
    "href": "guide/overview.html#putting-it-together",
    "title": "Overview",
    "section": "Putting it together",
    "text": "Putting it together\nFinally, we put all the pieces together into the original plot:\n\n(\n    ggplot(mpg, aes(\"cty\", \"hwy\"))\n    + geom_point(mapping=aes(colour=\"displ\"))\n    + geom_smooth(method=\"lm\", color=\"blue\")\n    + scale_color_continuous(cmap_name=\"viridis\")\n    + facet_grid(\"year ~ drv\")\n    + coord_fixed()\n    + theme_minimal()\n    + theme(panel_grid_minor=element_blank())\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis tutorial was adapted from the ggplot2 “Getting Started” tutorial",
    "crumbs": [
      "Guide",
      "Overview"
    ]
  },
  {
    "objectID": "guide/scale-basics.html",
    "href": "guide/scale-basics.html",
    "title": "Scales, legends, and guides",
    "section": "",
    "text": "Scales specify how aesthetic mappings are ultimately styled as colors, shapes, positions, sizes, and more. This includes choosing the colors used or scaling the size of points based on values of data.\nScale functions follow the naming pattern scale_{aesthetic}_{type}, where aesthetic is the name of the mapping (e.g. x, y, fill, shape), and type is the type of scale (e.g. continuous, discrete, color, shape).\nPlotnine produces a legend automatically, which tells viewers how to map scale values back to the underlying data. These mappings back to data are called guides.",
    "crumbs": [
      "Guide",
      "Basics",
      "Scales, legends, and guides"
    ]
  },
  {
    "objectID": "guide/scale-basics.html#setup",
    "href": "guide/scale-basics.html#setup",
    "title": "Scales, legends, and guides",
    "section": "Setup",
    "text": "Setup\n\nfrom plotnine import *\nfrom plotnine.data import mpg",
    "crumbs": [
      "Guide",
      "Basics",
      "Scales, legends, and guides"
    ]
  },
  {
    "objectID": "guide/scale-basics.html#scale-basics",
    "href": "guide/scale-basics.html#scale-basics",
    "title": "Scales, legends, and guides",
    "section": "Scale basics",
    "text": "Scale basics\nIn order to illustrate scales, we’ll show two very different uses: manually mapping values of data to colors, and selecting a color palette.\nFor manually mapping values to colors, we can use a manual type scale. For example, the code below uses scale_color_manual() to map two values in the class column to classes to red and blue.\n\n(\n    ggplot(mpg, aes(\"displ\", \"hwy\", color=\"class\"))\n    + geom_point()\n    + scale_color_manual(\n        name=\"Car class\",\n        breaks=[\"2seater\", \"compact\"],\n        values=[\"red\", \"blue\"],\n    )\n)\n\n\n\n\n\n\n\n\nNotice that “2seater” is red, “compact” is blue, and all other points are grey. The box on the right side of the plot with “Car class” in it is the legend. The piece inside it showing the colors with “2seater” and “compact” labeled is called a guide.\nGenerally, when using scales you’ll often want to use a scale that can automatically map values to colors. For example, scale_color_brewer() automatically applies a ColorBrewer palette.\n\n(\n    ggplot(mpg, aes(\"displ\", \"hwy\", color=\"class\"))\n    + geom_point()\n    + scale_color_brewer(type=\"qual\", palette=2)\n)\n\n\n\n\n\n\n\n\nNotice that there are 7 colors in the plot, one for each level of the class column.",
    "crumbs": [
      "Guide",
      "Basics",
      "Scales, legends, and guides"
    ]
  },
  {
    "objectID": "guide/scale-basics.html#scale-parts",
    "href": "guide/scale-basics.html#scale-parts",
    "title": "Scales, legends, and guides",
    "section": "Scale parts",
    "text": "Scale parts\nScales have many parts, including the overall guide, breaks, break labels, and break values (shown below).\n\nNotice the pieces marked in the diagram above:\n\nGuide: the x-axis, y-axis, and the color guide on the right.\nBreaks: the data points where pieces like labels are applied.\nBreak labels: the text displayed for each break.\nBreak values: pieces like the position on the axis, or key color in the color guide for a break.",
    "crumbs": [
      "Guide",
      "Basics",
      "Scales, legends, and guides"
    ]
  },
  {
    "objectID": "guide/scale-basics.html#varieties-of-scales",
    "href": "guide/scale-basics.html#varieties-of-scales",
    "title": "Scales, legends, and guides",
    "section": "Varieties of scales",
    "text": "Varieties of scales\n\nDefault scales\nDifferent scale types are applied by default, depending on the kind of data being mapped. For example, scale_color_continuous() is the default for numeric data, but scale_color_discrete() is the default for string data.\nThe plots below illustrate this for the continuous cyl column, by plotting it as is on the left, and using the special \"factor(cyl)\" syntax to cast it to discrete on the right.\np = ggplot(mpg, aes(\"displ\", \"hwy\")) + theme_grey(base_size=20)\n\n# defaults to scale_color_continuous\np + geom_point(aes(color=\"cyl\"))\n\n# defaults to scale_color_discrete\np + geom_point(aes(color=\"factor(cyl)\"))\n\n\n\n\n\n\n\n\n\n\n\n\nPosition scales\nThe position scales for the x- and y-axis also have many extra transformations available. For example, reversing or log transforming.\n\n(ggplot(mpg, aes(\"displ\", \"hwy\")) + geom_point() + scale_x_reverse() + scale_y_log10())\n\n\n\n\n\n\n\n\n\n\nIdentity type\nFinally, the scale identity type uses the values of the data as styles directly. For example, the code below sets the color of points to the values in the my_color column.\n\nimport pandas as pd\n\ndf = pd.DataFrame(\n    {\n        \"x\": [1, 2, 3],\n        \"y\": [1, 2, 3],\n        \"my_color\": [\"red\", \"blue\", \"green\"],\n    }\n)\n\n(ggplot(df, aes(\"x\", \"y\", color=\"my_color\")) + geom_point(size=5) + scale_color_identity())",
    "crumbs": [
      "Guide",
      "Basics",
      "Scales, legends, and guides"
    ]
  },
  {
    "objectID": "guide/scale-basics.html#name-to-set-guide-legend-labels",
    "href": "guide/scale-basics.html#name-to-set-guide-legend-labels",
    "title": "Scales, legends, and guides",
    "section": "name= to set guide (legend) labels",
    "text": "name= to set guide (legend) labels\nUse the name= argument to scale functions to set the label of that scale’s guide.\n\n(\n    ggplot(mpg, aes(\"displ\", \"hwy\", color=\"class\"))\n    + geom_point()\n    + scale_x_continuous(name=\"Engine displacement (litres)\")\n    + scale_y_continuous(name=\"Highway miles per gallon\")\n    + scale_color_discrete(name=\"Car class\")\n)\n\n\n\n\n\n\n\n\nNotice that the x-axis, y-axis, and color guides all have names set. While the guide color is in the legend on the right, the x- and y-axis guides are on the bottom and left of the plot.\n\n\n\n\n\n\nlabs() shortcut\n\n\n\nThe labs() function is a convenient way to set names for guides in one place, along with other pieces like a title.\n\n(\n    ggplot(mpg, aes(\"displ\", \"hwy\", color=\"class\"))\n    + geom_point()\n    + labs(\n        title = \"Use labs() to quickly set labels\",\n        x = \"Engine displacement (litres)\",\n        y = \"Highway miles per gallon\",\n        color = \"Car class\"\n    )\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Scales, legends, and guides"
    ]
  },
  {
    "objectID": "guide/scale-basics.html#values-for-manual-styles",
    "href": "guide/scale-basics.html#values-for-manual-styles",
    "title": "Scales, legends, and guides",
    "section": "values= for manual styles",
    "text": "values= for manual styles\nUse the values= argument to manually specify stylings like colors, shapes, or sizes of the scale. For example, the plot below manually sets point shapes (see the aesthetic specification for shape value options).\n\nkeep_classes = [\"2seater\", \"compact\", \"midsize\"]\n\n(\n    mpg[mpg[\"class\"].isin(keep_classes)]\n    &gt;&gt; ggplot(aes(\"displ\", \"hwy\", shape=\"factor(cyl)\"))\n    + geom_point()\n    + scale_shape_manual(values=[\".\", \"o\", \"v\", \"&gt;\"])\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Scales, legends, and guides"
    ]
  },
  {
    "objectID": "guide/scale-basics.html#breaks-for-axis-ticks-color-bins",
    "href": "guide/scale-basics.html#breaks-for-axis-ticks-color-bins",
    "title": "Scales, legends, and guides",
    "section": "breaks= for axis ticks, color bins",
    "text": "breaks= for axis ticks, color bins\n\np = ggplot(mpg, aes(\"displ\", \"hwy\", color=\"class\")) + geom_point()\n\np + scale_x_continuous(breaks = [4, 4.5, 5, 5.5])",
    "crumbs": [
      "Guide",
      "Basics",
      "Scales, legends, and guides"
    ]
  },
  {
    "objectID": "guide/scale-basics.html#limits-for-restricting-data-range",
    "href": "guide/scale-basics.html#limits-for-restricting-data-range",
    "title": "Scales, legends, and guides",
    "section": "limits= for restricting data range",
    "text": "limits= for restricting data range\nfrom plotnine.data import huron\n\n\np = ggplot(huron, aes(\"year\", \"level\")) + geom_line() + theme_grey(base_size=26)\n\np + labs(title=\"default\")\np + scale_x_continuous(limits=[1950, 1960]) + labs(title=\"zoom in\")\np + scale_x_continuous(limits=[1800, 2000]) + labs(title=\"zoom out\")\n\n\n\n\n\n\n\n\n\n\n\n\n\np = ggplot(huron, aes(\"year\", \"level\", color=\"year\")) + geom_line() \n\np\np + scale_color_continuous(limits=[None, 1900])",
    "crumbs": [
      "Guide",
      "Basics",
      "Scales, legends, and guides"
    ]
  },
  {
    "objectID": "guide/scale-basics.html#labels-for-break-labels",
    "href": "guide/scale-basics.html#labels-for-break-labels",
    "title": "Scales, legends, and guides",
    "section": "labels= for break labels",
    "text": "labels= for break labels\nUse the labels= argument to set custom labels for breaks. This argument supports either a function that operates on a list of breaks, or a list of labels.\nFor example, the plot below sets the color labels to uppercase.\n\np = ggplot(mpg, aes(\"displ\", \"hwy\", color=\"class\")) + geom_point()\n\np + scale_color_discrete(labels=lambda breaks: [s.upper() for s in breaks])\n\n\n\n\n\n\n\n\nThe plot below manually sets the x-axis breaks and labels.\n\np + scale_x_continuous(breaks = [2, 4, 6], labels = [\"TWO\", \"FOUR\", \"SIX\"])",
    "crumbs": [
      "Guide",
      "Basics",
      "Scales, legends, and guides"
    ]
  },
  {
    "objectID": "guide/scale-basics.html#legend-merging",
    "href": "guide/scale-basics.html#legend-merging",
    "title": "Scales, legends, and guides",
    "section": "Legend merging",
    "text": "Legend merging\nSometimes aesthetics mapped to the same variable have their guides merged. For example, color and shape might be shown on the same guide. To split a merged guide, give the scales their own names.\np = (\n    ggplot(mpg, aes(\"displ\", \"hwy\", color=\"factor(cyl)\", shape=\"factor(cyl)\"))\n    + geom_point()\n    + theme_grey(base_size=20)\n)\n\np + labs(title=\"Unmerged\")\np + labs(title=\"Merged\") + scale_shape_discrete(name=\"Shape\")",
    "crumbs": [
      "Guide",
      "Basics",
      "Scales, legends, and guides"
    ]
  },
  {
    "objectID": "guide/scale-basics.html#legend-position",
    "href": "guide/scale-basics.html#legend-position",
    "title": "Scales, legends, and guides",
    "section": "Legend position",
    "text": "Legend position\nUse theme(legend_position=...) argument to set the position of the legend in a plot. The options are \"none\", \"left\", \"right\", \"top\", and \"bottom\".\np = (\n    ggplot(mpg, aes(\"displ\", \"hwy\", color=\"factor(cyl)\", shape=\"factor(cyl)\"))\n    + geom_point()\n)\n\np + theme(legend_position=\"top\")\np + theme(legend_position=\"none\")",
    "crumbs": [
      "Guide",
      "Basics",
      "Scales, legends, and guides"
    ]
  },
  {
    "objectID": "guide/scale-basics.html#guide-customization",
    "href": "guide/scale-basics.html#guide-customization",
    "title": "Scales, legends, and guides",
    "section": "Guide customization",
    "text": "Guide customization\nCustomize guides by passing arguments like guide_colorbar() or guide_legend() to the guides() function.\nThe example below uses guide_colorbar() to reverse the colorbar (in the legend on the right; note the styles are the same, but the way the guide colorbar is shown is reversed).\np = (\n    ggplot(mpg, aes(\"displ\", \"hwy\", color=\"cyl\"))\n    + geom_point()\n    + theme(legend_key_size=30)\n)\np\np + guides(color=guide_colorbar(reverse=True))\n\n\n\n\n\n\n\n\n\n\nHere’s a funky example that merges guides for color, size, and shape by giving them all the same title in the legend.\n\nimport pandas as pd\nfrom plotnine import *\n\nser = list(map(str, range(5)))\ndf = pd.DataFrame({\"x\": ser, \"y\": ser, \"p\": ser, \"q\": ser, \"r\": ser})\n\n(\n    ggplot(df, aes(\"x\", \"y\", color=\"p\", size=\"q\", shape=\"r\"))\n    + geom_point()\n    + labs(title=\"Merged color, size, and shape guides\")\n    + guides(\n        color=guide_legend(\"THE GUIDE\"),\n        size=guide_legend(\"THE GUIDE\"),\n        shape=guide_legend(\"THE GUIDE\"),\n    )\n)",
    "crumbs": [
      "Guide",
      "Basics",
      "Scales, legends, and guides"
    ]
  },
  {
    "objectID": "guide/scale-color-fill.html",
    "href": "guide/scale-color-fill.html",
    "title": "Scale color and fill",
    "section": "",
    "text": "from plotnine.data import penguins\nfrom plotnine import *\n\np = (\n    ggplot(penguins, aes(\"bill_length_mm\", \"bill_depth_mm\", color=\"species\"))\n    + geom_point()\n)"
  },
  {
    "objectID": "guide/scale-color-fill.html#choosing-between-color-and-fill",
    "href": "guide/scale-color-fill.html#choosing-between-color-and-fill",
    "title": "Scale color and fill",
    "section": "Choosing between color and fill",
    "text": "Choosing between color and fill"
  },
  {
    "objectID": "guide/scale-color-fill.html#specifying-a-continuous-palette",
    "href": "guide/scale-color-fill.html#specifying-a-continuous-palette",
    "title": "Scale color and fill",
    "section": "Specifying a continuous palette",
    "text": "Specifying a continuous palette"
  },
  {
    "objectID": "guide/scale-color-fill.html#specifying-a-discrete-palette",
    "href": "guide/scale-color-fill.html#specifying-a-discrete-palette",
    "title": "Scale color and fill",
    "section": "Specifying a discrete palette",
    "text": "Specifying a discrete palette\n\np + scale_color_brewer(\"qualitative\", palette=\"Dark2\")\n\n\n\n\n\n\n\n\n\nqualitative\nsequential\ndiverging\n\n(short codes)\n\n# p + scale_color_hue(=280 / 360, 1, .5)\n\n\n(\n    p\n    + scale_color_manual(\n        breaks=[\"Adelie\", \"Gentoo\", \"Chinstrap\"], values=[\"blue\", \"orange\", \"green\"]\n    )\n)"
  },
  {
    "objectID": "guide/scale-color-fill.html#setting-alpha-transparency",
    "href": "guide/scale-color-fill.html#setting-alpha-transparency",
    "title": "Scale color and fill",
    "section": "Setting alpha transparency",
    "text": "Setting alpha transparency"
  },
  {
    "objectID": "guide/scale-color-fill.html#ordering-levels",
    "href": "guide/scale-color-fill.html#ordering-levels",
    "title": "Scale color and fill",
    "section": "Ordering levels",
    "text": "Ordering levels"
  },
  {
    "objectID": "guide/scale-color-fill.html#grouping-levels",
    "href": "guide/scale-color-fill.html#grouping-levels",
    "title": "Scale color and fill",
    "section": "Grouping levels",
    "text": "Grouping levels"
  },
  {
    "objectID": "guide/scale-x-and-y.html",
    "href": "guide/scale-x-and-y.html",
    "title": "Scale x and y",
    "section": "",
    "text": "continuous\ndiscrete\ndate, datetime, timedelta\nlog10, sqrt, symlog\nreverse\nCommon formatting:\nfrom plotnine import *\nfrom plotnine.data import economics\n\np = ggplot(economics, aes(\"date\", \"psavert\")) + geom_line()"
  },
  {
    "objectID": "guide/scale-x-and-y.html#full-example",
    "href": "guide/scale-x-and-y.html#full-example",
    "title": "Scale x and y",
    "section": "Full example",
    "text": "Full example\n\nfrom mizani.labels import percent_format\n\n(\n    ggplot(economics, aes(\"date\", \"psavert\"))\n    + geom_line()\n    + labs(title=\"\")\n    + scale_y_continuous(\n        name=\"Personal savings rate\",\n        limits=[0, None],\n        labels=percent_format(scale=1),\n    )\n    + scale_x_date(\n        name=\"Date\",\n        date_breaks=\"10 years\",\n        date_minor_breaks=\"5 year\",\n    )\n)"
  },
  {
    "objectID": "guide/scale-x-and-y.html#expanding-limits-to-include-zero",
    "href": "guide/scale-x-and-y.html#expanding-limits-to-include-zero",
    "title": "Scale x and y",
    "section": "Expanding limits to include zero",
    "text": "Expanding limits to include zero\n\np + scale_y_continuous(limits=[0, None])"
  },
  {
    "objectID": "guide/scale-x-and-y.html#labelling-percentages",
    "href": "guide/scale-x-and-y.html#labelling-percentages",
    "title": "Scale x and y",
    "section": "Labelling percentages",
    "text": "Labelling percentages\n\n(\n    ggplot(economics, aes(\"date\", \"psavert\"))\n    + geom_line()\n    + scale_y_continuous(labels=lambda arr: [f\"{x}%\" for x in arr])\n)\n\n\n\n\n\n\n\n\n\nfrom mizani.labels import percent_format\n\n(\n    ggplot(economics, aes(\"date\", \"psavert\"))\n    + geom_line()\n    + scale_y_continuous(labels=percent_format(scale=1))\n)"
  },
  {
    "objectID": "guide/scale-x-and-y.html#specifying-date-breaks",
    "href": "guide/scale-x-and-y.html#specifying-date-breaks",
    "title": "Scale x and y",
    "section": "Specifying date breaks",
    "text": "Specifying date breaks\n\n(\n    ggplot(economics, aes(\"date\", \"psavert\"))\n    + geom_line()\n    + scale_x_date(date_breaks=\"10 years\", date_minor_breaks=\"5 year\")\n)"
  },
  {
    "objectID": "guide/scale-x-and-y.html#applying-log-scale",
    "href": "guide/scale-x-and-y.html#applying-log-scale",
    "title": "Scale x and y",
    "section": "Applying log scale",
    "text": "Applying log scale\np = ggplot(economics, aes(\"date\", \"pce\")) + geom_line()\n\np\np + scale_y_log10()"
  },
  {
    "objectID": "guide/themes-basics.html",
    "href": "guide/themes-basics.html",
    "title": "Theme basics",
    "section": "",
    "text": "The theme() function customizes the style of plot elements—like the background color, grid lines, tick mark length, and much more. Premade themes like theme_minimal() and theme_538() allow for quick theming.",
    "crumbs": [
      "Guide",
      "Theming",
      "Theme basics"
    ]
  },
  {
    "objectID": "guide/themes-basics.html#setup",
    "href": "guide/themes-basics.html#setup",
    "title": "Theme basics",
    "section": "Setup",
    "text": "Setup\n\nfrom plotnine import *\nfrom plotnine.data import penguins",
    "crumbs": [
      "Guide",
      "Theming",
      "Theme basics"
    ]
  },
  {
    "objectID": "guide/themes-basics.html#premade-themes",
    "href": "guide/themes-basics.html#premade-themes",
    "title": "Theme basics",
    "section": "Premade themes",
    "text": "Premade themes\nThe quickest way to explore themes is by applying a premade one. These start with theme_*(), and include theme_minimal(), theme_bw(), and theme_538().\np = (\n    ggplot(penguins, aes(x=\"flipper_length_mm\", y=\"body_mass_g\", color=\"species\"))\n    + labs(title=\"Penguins (538 Theme)\", subtitle=\"Very cool\")\n    + geom_point()\n)\n\np\np + theme_538()",
    "crumbs": [
      "Guide",
      "Theming",
      "Theme basics"
    ]
  },
  {
    "objectID": "guide/themes-basics.html#basic-theme-use",
    "href": "guide/themes-basics.html#basic-theme-use",
    "title": "Theme basics",
    "section": "Basic theme() use",
    "text": "Basic theme() use\nUse the theme() function to customize many aspects of a plot’s appearance. This function often takes an element object, like element_text(), which specifies properties like font size and color.\nFor example, the code below sets the x-axis text to be purple and rotated 90 degrees.\n\n(\n    ggplot(penguins, aes(x=\"flipper_length_mm\", y=\"body_mass_g\"))\n    + geom_point()\n    + theme(\n        axis_text_x=element_text(angle=90, color=\"purple\"),\n    )\n)\n\n\n\n\n\n\n\n\nThe element_line() function can be used to customize pieces like tick marks. This is shown below.\n\n(\n    ggplot(penguins, aes(x=\"flipper_length_mm\", y=\"body_mass_g\"))\n    + geom_point()\n    + theme(\n        axis_ticks_major_y=element_line(color=\"red\", size=5),\n        axis_ticks_length_major_y=10,\n    )\n)",
    "crumbs": [
      "Guide",
      "Theming",
      "Theme basics"
    ]
  },
  {
    "objectID": "guide/themes-basics.html#five-main-theme-areas",
    "href": "guide/themes-basics.html#five-main-theme-areas",
    "title": "Theme basics",
    "section": "Five main theme areas",
    "text": "Five main theme areas\nThere are five main areas of a plot that can be customized—axis, legend, panel, plot, and strip. These are colored in the plot below.\n\n(\n    ggplot(penguins, aes(x=\"flipper_length_mm\", y=\"body_mass_g\", shape=\"species\"))\n    + geom_point()\n    + facet_wrap(\"~species\")\n    + theme(\n        axis_title=element_text(size=20, color=\"purple\"),\n        legend_background=element_rect(fill=\"lightblue\"),\n        panel_background=element_rect(fill=\"lightgreen\"),\n        plot_background=element_rect(fill=\"lightyellow\"),\n        strip_background=element_rect(fill=\"lightpink\"),\n    )\n    + theme()\n)\n\n\n\n\n\n\n\n\nEach of these areas contains many specific pieces that can be customized. For example, the legend margin, panel grid lines, or plot title style. There are over 100 theme arguments available in theme()!",
    "crumbs": [
      "Guide",
      "Theming",
      "Theme basics"
    ]
  },
  {
    "objectID": "guide/themes-basics.html#blanking-elements",
    "href": "guide/themes-basics.html#blanking-elements",
    "title": "Theme basics",
    "section": "Blanking elements",
    "text": "Blanking elements\nUse element_blank() to remove theme elements from a plot.\nThe code below removes the x- and y-axis text and tick marks.\n\n(\n    ggplot(penguins, aes(x=\"flipper_length_mm\", y=\"body_mass_g\"))\n    + geom_point()\n    + theme(\n        axis_text=element_blank(),\n        axis_ticks=element_blank(),\n    )\n)",
    "crumbs": [
      "Guide",
      "Theming",
      "Theme basics"
    ]
  },
  {
    "objectID": "guide/themes-basics.html#inherited-elements",
    "href": "guide/themes-basics.html#inherited-elements",
    "title": "Theme basics",
    "section": "Inherited elements",
    "text": "Inherited elements\nSome arguments like theme(axis_text=...) set the default for multiple pieces (in this case axis_text_x and axis_text_y). For example, the code below blanks out the x- and y-axis text by default, but then sets the x-axis text to be purple.\n\n(\n    ggplot(penguins, aes(x=\"flipper_length_mm\", y=\"body_mass_g\"))\n    + geom_point()\n    + theme(\n        axis_text=element_blank(),\n        axis_text_x=element_text(angle=90, color=\"purple\"),\n    )\n)",
    "crumbs": [
      "Guide",
      "Theming",
      "Theme basics"
    ]
  },
  {
    "objectID": "guide/themes-basics.html#creating-a-custom-theme",
    "href": "guide/themes-basics.html#creating-a-custom-theme",
    "title": "Theme basics",
    "section": "Creating a custom theme",
    "text": "Creating a custom theme\n\nUsing a variable\nSave the result of theme() to a variable to reuse it across plots.\n\nmy_theme = theme(\n    panel_background=element_rect(fill=\"white\"),\n    panel_grid_major=element_line(color=\"#F0F0F0\"),\n)\n\n(\n    ggplot(penguins, aes(x=\"flipper_length_mm\", y=\"body_mass_g\"))\n    + geom_point()\n    + my_theme\n)\n\n\n\n\n\n\n\n\n\n\nSubclassing premade themes\nNote that many premade classes use a convenient base_size= argument, to apply a base size to many text elements. Sometimes it’s useful to subclass these premades, and then add your own customizations.\nclass custom_theme(theme_gray):\n    def __init__(self, base_size=11, base_family=None):\n        super().__init__(base_size=base_size, base_family=base_family)\n        self += theme(axis_text_x=element_text(angle=90, color=\"purple\"))\n\n\np = ggplot(penguins, aes(x=\"flipper_length_mm\", y=\"body_mass_g\")) + geom_point()\n\np + custom_theme()\np + custom_theme(base_size=24)",
    "crumbs": [
      "Guide",
      "Theming",
      "Theme basics"
    ]
  },
  {
    "objectID": "guide/themes-premade.html",
    "href": "guide/themes-premade.html",
    "title": "Premade themes",
    "section": "",
    "text": "Premade themes begin with theme_*(). For convenience, this page displays 10 premade themes that come with plotnine. By default, plotnine uses theme_gray().",
    "crumbs": [
      "Guide",
      "Theming",
      "Premade themes"
    ]
  },
  {
    "objectID": "guide/themes-premade.html#setup",
    "href": "guide/themes-premade.html#setup",
    "title": "Premade themes",
    "section": "Setup",
    "text": "Setup\n\nfrom plotnine import *\nfrom plotnine.data import penguins\n\np = (\n    ggplot(penguins, aes(x=\"flipper_length_mm\", y=\"body_mass_g\", color=\"species\"))\n    + geom_point()\n    + scale_x_continuous(breaks=range(150, 250, 30))\n    + facet_wrap(\"~species\")\n    + labs(subtitle=\"I am a subtitle\")\n)",
    "crumbs": [
      "Guide",
      "Theming",
      "Premade themes"
    ]
  },
  {
    "objectID": "guide/themes-premade.html#bw",
    "href": "guide/themes-premade.html#bw",
    "title": "Premade themes",
    "section": "BW",
    "text": "BW\n\np + theme_bw() + labs(title=\"theme_bw()\")",
    "crumbs": [
      "Guide",
      "Theming",
      "Premade themes"
    ]
  },
  {
    "objectID": "guide/themes-premade.html#classical",
    "href": "guide/themes-premade.html#classical",
    "title": "Premade themes",
    "section": "Classical",
    "text": "Classical\n\np + theme_classic() + labs(title=\"theme_classic()\")",
    "crumbs": [
      "Guide",
      "Theming",
      "Premade themes"
    ]
  },
  {
    "objectID": "guide/themes-premade.html#gray",
    "href": "guide/themes-premade.html#gray",
    "title": "Premade themes",
    "section": "Gray",
    "text": "Gray\n\np + theme_gray() + labs(title=\"theme_gray()\")",
    "crumbs": [
      "Guide",
      "Theming",
      "Premade themes"
    ]
  },
  {
    "objectID": "guide/themes-premade.html#lightdark",
    "href": "guide/themes-premade.html#lightdark",
    "title": "Premade themes",
    "section": "Light/Dark",
    "text": "Light/Dark\np + theme_light() + labs(title=\"theme_light()\")\np + theme_dark() + labs(title=\"theme_dark()\")",
    "crumbs": [
      "Guide",
      "Theming",
      "Premade themes"
    ]
  },
  {
    "objectID": "guide/themes-premade.html#matplotlib",
    "href": "guide/themes-premade.html#matplotlib",
    "title": "Premade themes",
    "section": "Matplotlib",
    "text": "Matplotlib\n\np + theme_matplotlib() + labs(title=\"theme_matplotlib()\")",
    "crumbs": [
      "Guide",
      "Theming",
      "Premade themes"
    ]
  },
  {
    "objectID": "guide/themes-premade.html#minimal",
    "href": "guide/themes-premade.html#minimal",
    "title": "Premade themes",
    "section": "Minimal",
    "text": "Minimal\n\np + theme_minimal() + labs(title=\"theme_minimal()\")",
    "crumbs": [
      "Guide",
      "Theming",
      "Premade themes"
    ]
  },
  {
    "objectID": "guide/themes-premade.html#seaborn",
    "href": "guide/themes-premade.html#seaborn",
    "title": "Premade themes",
    "section": "Seaborn",
    "text": "Seaborn\n\np + theme_seaborn() + labs(title=\"theme_seaborn()\")",
    "crumbs": [
      "Guide",
      "Theming",
      "Premade themes"
    ]
  },
  {
    "objectID": "guide/themes-premade.html#tufte",
    "href": "guide/themes-premade.html#tufte",
    "title": "Premade themes",
    "section": "Tufte",
    "text": "Tufte\n\np + theme_tufte() + labs(title=\"theme_tufte()\")",
    "crumbs": [
      "Guide",
      "Theming",
      "Premade themes"
    ]
  },
  {
    "objectID": "guide/themes-premade.html#section",
    "href": "guide/themes-premade.html#section",
    "title": "Premade themes",
    "section": "538",
    "text": "538\n\np + theme_538() + labs(title=\"theme_538()\")",
    "crumbs": [
      "Guide",
      "Theming",
      "Premade themes"
    ]
  },
  {
    "objectID": "license.html",
    "href": "license.html",
    "title": "The MIT License (MIT)",
    "section": "",
    "text": "Copyright (c) 2022 Hassan Kibirige\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "reference/aes.html",
    "href": "reference/aes.html",
    "title": " plotnine.aes",
    "section": "",
    "text": "aes(x=None, y=None, kwargs={})"
  },
  {
    "objectID": "reference/aes.html#parameters",
    "href": "reference/aes.html#parameters",
    "title": " plotnine.aes",
    "section": "Parameters",
    "text": "Parameters\n\n\nx : str | array_like | scalar = None\n\nx aesthetic mapping\n\ny : str | array_like | scalar = None\n\ny aesthetic mapping\n\n**kwargs : Any = {}\n\nOther aesthetic mappings"
  },
  {
    "objectID": "reference/aes.html#notes",
    "href": "reference/aes.html#notes",
    "title": " plotnine.aes",
    "section": "Notes",
    "text": "Notes\nOnly the x and y aesthetic mappings can be specified as positional arguments. All the rest must be keyword arguments.\nThe value of each mapping must be one of:\n\nstr\n import pandas as pd\n import numpy as np\n\n arr = [11, 12, 13]\n df = pd.DataFrame({\n     \"alpha\": [1, 2, 3],\n     \"beta\": [1, 2, 3],\n     \"gam ma\": [1, 2, 3]\n })\n\n # Refer to a column in a dataframe\n ggplot(df, aes(x=\"alpha\", y=\"beta\"))\narray_like\n# A variable\nggplot(df, aes(x=\"alpha\", y=arr))\n\n# or an inplace list\nggplot(df, aes(x=\"alpha\", y=[4, 5, 6]))\nscalar\n# A scalar value/variable\nggplot(df, aes(x=\"alpha\", y=4))\n\n# The above statement is equivalent to\nggplot(df, aes(x=\"alpha\", y=[4, 4, 4]))\nString expression\nggplot(df, aes(x=\"alpha\", y=\"2*beta\"))\nggplot(df, aes(x=\"alpha\", y=\"np.sin(beta)\"))\nggplot(df, aes(x=\"df.index\", y=\"beta\"))\n\n# If `count` is an aesthetic calculated by a stat\nggplot(df, aes(x=\"alpha\", y=after_stat(\"count\")))\nggplot(df, aes(x=\"alpha\", y=after_stat(\"count/np.max(count)\")))\nThe strings in the expression can refer to;\n\ncolumns in the dataframe\nvariables in the namespace\naesthetic values (columns) calculated by the stat\n\nwith the column names having precedence over the variables. For expressions, columns in the dataframe that are mapped to must have names that would be valid python variable names.\nThis is okay:\n# \"gam ma\" is a column in the dataframe\nggplot(df, aes(x=\"df.index\", y=\"gam ma\"))\nWhile this is not:\n# \"gam ma\" is a column in the dataframe, but not\n# valid python variable name\nggplot(df, aes(x=\"df.index\", y=\"np.sin(gam ma)\"))\n\naes has 2 internal functions that you can use in your expressions when transforming the variables.\n\nfactor\nreorder\n\nThe group aesthetic\ngroup is a special aesthetic that the user can map to. It is used to group the plotted items. If not specified, it is automatically computed and in most cases the computed groups are sufficient. However, there may be cases were it is handy to map to it."
  },
  {
    "objectID": "reference/aes.html#see-also",
    "href": "reference/aes.html#see-also",
    "title": " plotnine.aes",
    "section": "See Also",
    "text": "See Also\n\nafter_stat\n\nFor how to map aesthetics to variable calculated by the stat\n\nafter_scale\n\nFor how to alter aesthetics after the data has been mapped by the scale.\n\nstage\n\nFor how to map to evaluate the mapping to aesthetics at more than one stage of the plot building pipeline."
  },
  {
    "objectID": "reference/aes.html#examples",
    "href": "reference/aes.html#examples",
    "title": " plotnine.aes",
    "section": "Examples",
    "text": "Examples\n\n\nimport pandas as pd\nimport numpy as np\n\nfrom plotnine import ggplot, aes, geom_point\n\n\naes\nMapping variables to the visual properties of a plot.\n\ndf = pd.DataFrame({\n    \"col1\": np.arange(11),\n    \"col2\": np.arange(11)\n})\n\n(\n    ggplot(df, aes(x=\"col1\", y=\"col2\"))\n    + geom_point()\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(df, aes(x=\"col1\", y=\"col2 ** 2\"))\n    + geom_point()\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(df, aes(x=\"col1\", y=\"np.square(col2)\"))\n    + geom_point()\n)\n\n\n\n\n\n\n\n\nThe first two positional arguments are x and y aesthetics. Any other aesthetic must be mapped with a keyword argument.\n\n(\n    ggplot(df, aes(\"col1\", \"np.square(col2)\", color=\"col2\"))\n    + geom_point(size=3)\n)\n\n\n\n\n\n\n\n\n\nSource: aes"
  },
  {
    "objectID": "reference/after_stat.html",
    "href": "reference/after_stat.html",
    "title": " plotnine.after_stat",
    "section": "",
    "text": "after_stat(x)"
  },
  {
    "objectID": "reference/after_stat.html#parameters",
    "href": "reference/after_stat.html#parameters",
    "title": " plotnine.after_stat",
    "section": "Parameters",
    "text": "Parameters\n\n\nx : str\n\nAn expression"
  },
  {
    "objectID": "reference/after_stat.html#see-also",
    "href": "reference/after_stat.html#see-also",
    "title": " plotnine.after_stat",
    "section": "See Also",
    "text": "See Also\n\nafter_scale\n\n\n\nstage"
  },
  {
    "objectID": "reference/after_stat.html#examples",
    "href": "reference/after_stat.html#examples",
    "title": " plotnine.after_stat",
    "section": "Examples",
    "text": "Examples\n\n\nimport pandas as pd\nimport numpy as np\n\nfrom plotnine import ggplot, aes, after_stat, geom_bar, labs\n\n\nafter_stat\ngeom_bar uses stat_count which by default maps the y aesthetic to the count which is the number of observations at a position.\n\ndf = pd.DataFrame({\n    \"var1\": [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]\n})\n\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar()\n)\n\n\n\n\n\n\n\n\nUsing the after_stat function, we can instead map to the prop which is the ratio of points in the panel at a position.\n\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar(aes(y=after_stat(\"prop\")))  # default is after_stat('count')\n)\n\n\n\n\n\n\n\n\nWith after_stat you can used the variables calculated by the stat in expressions. For example we use the count to calculated the prop.\n\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar(aes(y=after_stat(\"count / np.sum(count)\")))\n    + labs(y=\"prop\")\n)\n\n\n\n\n\n\n\n\nBy default geom_bar uses stat_count to compute a frequency table with the x aesthetic as the key column. As a result, any mapping (other than the x aesthetic is lost) to a continuous variable is lost (if you have a classroom and you compute a frequency table of the gender, you lose any other information like height of students).\nFor example, below fill='var1' has no effect, but the var1 variable has not been lost it has been turned into x aesthetic.\n\n(ggplot(df, aes(\"var1\")) + geom_bar(aes(fill=\"var1\")))\n\n\n\n\n\n\n\n\nWe use after_stat to map fill to the x aesthetic after it has been computed.\n\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar(aes(fill=after_stat(\"x\")))\n    + labs(fill=\"var1\")\n)\n\n\n\n\n\n\n\n\n\nSource: after_stat"
  },
  {
    "objectID": "reference/annotation_logticks.html",
    "href": "reference/annotation_logticks.html",
    "title": " plotnine.annotation_logticks",
    "section": "",
    "text": "annotation_logticks(\n    sides=\"bl\",\n    alpha=1,\n    color=\"black\",\n    size=0.5,\n    linetype=\"solid\",\n    lengths=(0.036, 0.0225, 0.012),\n    base=None\n)"
  },
  {
    "objectID": "reference/annotation_logticks.html#parameters",
    "href": "reference/annotation_logticks.html#parameters",
    "title": " plotnine.annotation_logticks",
    "section": "Parameters",
    "text": "Parameters\n\n\nsides : str = \"bl\"\n\nSides onto which to draw the marks. Any combination chosen from the characters btlr, for bottom, top, left or right side marks. If coord_flip() is used, these are the sides after the flip.\n\nalpha : float = 1\n\nTransparency of the ticks\n\ncolor : str | tuple[float, float, float] | tuple[float, float, float, float] = \"black\"\n\nColour of the ticks\n\nsize : float = 0.5\n\nThickness of the ticks\n\nlinetype : Literal[\"solid\", \"dashed\", \"dashdot\", \"dotted\"] | Sequence[float] = \"solid\"\n\nType of line\n\nlengths : tuple[float, float, float] = (0.036, 0.0225, 0.012)\n\nlength of the ticks drawn for full / half / tenth ticks relative to panel size\n\nbase : float | None = None\n\nBase of the logarithm in which the ticks will be calculated. If None, the base used to log transform the scale will be used."
  },
  {
    "objectID": "reference/anscombe_quartet.html",
    "href": "reference/anscombe_quartet.html",
    "title": " plotnine.data.anscombe_quartet",
    "section": "",
    "text": "anscombe_quartet = pd.read_csv(DATA_DIR / \"anscombe-quartet.csv\")"
  },
  {
    "objectID": "reference/anscombe_quartet.html#description",
    "href": "reference/anscombe_quartet.html#description",
    "title": " plotnine.data.anscombe_quartet",
    "section": "Description",
    "text": "Description\nA dataset by Statistician Francis Anscombe that challenged the commonly held belief that “numerical calculations are exact, but graphs are rough” (Anscombe, 1973).\nIt comprises of 4 (the quartet!) small sub-datasets, each with 11 points that have different distributions but nearly identical descriptive statistics. It is perhaps the best argument for visualising data."
  },
  {
    "objectID": "reference/anscombe_quartet.html#format",
    "href": "reference/anscombe_quartet.html#format",
    "title": " plotnine.data.anscombe_quartet",
    "section": "Format",
    "text": "Format\nA dataframe with 44 rows and 3 variables\n\n\n\nColumn\nDescription\n\n\n\n\ndataset\nThe Dataset\n\n\nx\nx\n\n\ny\ny"
  },
  {
    "objectID": "reference/anscombe_quartet.html#references",
    "href": "reference/anscombe_quartet.html#references",
    "title": " plotnine.data.anscombe_quartet",
    "section": "References",
    "text": "References\nAnscombe, F. J. (1973). “Graphs in Statistical Analysis”. American Statistician. 27 (1): 17–21."
  },
  {
    "objectID": "reference/as_labeller.html",
    "href": "reference/as_labeller.html",
    "title": " plotnine.as_labeller",
    "section": "",
    "text": "as_labeller(x=None, default=label_value, multi_line=True)"
  },
  {
    "objectID": "reference/as_labeller.html#parameters",
    "href": "reference/as_labeller.html#parameters",
    "title": " plotnine.as_labeller",
    "section": "Parameters",
    "text": "Parameters\n\n\nx : callable | dict = None\n\nObject to coerce\n\ndefault : str | callable = label_value\n\nDefault labeller. If it is a string, it should be the name of one the labelling functions provided by plotnine.\n\nmulti_line : bool = True\n\nWhether to place each variable on a separate line"
  },
  {
    "objectID": "reference/as_labeller.html#returns",
    "href": "reference/as_labeller.html#returns",
    "title": " plotnine.as_labeller",
    "section": "Returns",
    "text": "Returns\n\n\nout : labeller\n\nLabelling function"
  },
  {
    "objectID": "reference/axis_line.html",
    "href": "reference/axis_line.html",
    "title": " plotnine.themes.themeable.axis_line",
    "section": "",
    "text": "axis_line(theme_element)"
  },
  {
    "objectID": "reference/axis_line.html#parameters",
    "href": "reference/axis_line.html#parameters",
    "title": " plotnine.themes.themeable.axis_line",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/axis_line_y.html",
    "href": "reference/axis_line_y.html",
    "title": " plotnine.themes.themeable.axis_line_y",
    "section": "",
    "text": "axis_line_y(theme_element)"
  },
  {
    "objectID": "reference/axis_line_y.html#parameters",
    "href": "reference/axis_line_y.html#parameters",
    "title": " plotnine.themes.themeable.axis_line_y",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/axis_line_y.html#attributes",
    "href": "reference/axis_line_y.html#attributes",
    "title": " plotnine.themes.themeable.axis_line_y",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nposition\nstr(object=’’) -&gt; str\n\n\n\n\n position\n\nposition = \"left\"\n\n\nstr(object=’’) -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str\nCreate a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to ‘strict’."
  },
  {
    "objectID": "reference/axis_text_x.html",
    "href": "reference/axis_text_x.html",
    "title": " plotnine.themes.themeable.axis_text_x",
    "section": "",
    "text": "axis_text_x(theme_element)"
  },
  {
    "objectID": "reference/axis_text_x.html#parameters",
    "href": "reference/axis_text_x.html#parameters",
    "title": " plotnine.themes.themeable.axis_text_x",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/axis_text_x.html#notes",
    "href": "reference/axis_text_x.html#notes",
    "title": " plotnine.themes.themeable.axis_text_x",
    "section": "Notes",
    "text": "Notes\nUse the margin to control the gap between the ticks and the text. e.g.\ntheme(axis_text_x=element_text(margin={\"t\": 5, \"units\": \"pt\"}))\ncreates a margin of 5 points."
  },
  {
    "objectID": "reference/axis_ticks.html",
    "href": "reference/axis_ticks.html",
    "title": " plotnine.themes.themeable.axis_ticks",
    "section": "",
    "text": "axis_ticks(theme_element)"
  },
  {
    "objectID": "reference/axis_ticks.html#parameters",
    "href": "reference/axis_ticks.html#parameters",
    "title": " plotnine.themes.themeable.axis_ticks",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/axis_ticks_length_major.html",
    "href": "reference/axis_ticks_length_major.html",
    "title": " plotnine.themes.themeable.axis_ticks_length_major",
    "section": "",
    "text": "axis_ticks_length_major(theme_element)"
  },
  {
    "objectID": "reference/axis_ticks_length_major.html#parameters",
    "href": "reference/axis_ticks_length_major.html#parameters",
    "title": " plotnine.themes.themeable.axis_ticks_length_major",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nValue in points. A negative value creates the ticks inside the plot panel. A complex value (e.g. 3j) creates ticks that span both in and out of the panel."
  },
  {
    "objectID": "reference/axis_ticks_length_major_y.html",
    "href": "reference/axis_ticks_length_major_y.html",
    "title": " plotnine.themes.themeable.axis_ticks_length_major_y",
    "section": "",
    "text": "axis_ticks_length_major_y(theme_element)"
  },
  {
    "objectID": "reference/axis_ticks_length_major_y.html#parameters",
    "href": "reference/axis_ticks_length_major_y.html#parameters",
    "title": " plotnine.themes.themeable.axis_ticks_length_major_y",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float | complex\n\nValue in points. A negative value creates the ticks inside the plot panel. A complex value (e.g. 3j) creates ticks that span both in and out of the panel."
  },
  {
    "objectID": "reference/axis_ticks_length_minor_x.html",
    "href": "reference/axis_ticks_length_minor_x.html",
    "title": " plotnine.themes.themeable.axis_ticks_length_minor_x",
    "section": "",
    "text": "axis_ticks_length_minor_x(theme_element)"
  },
  {
    "objectID": "reference/axis_ticks_length_minor_x.html#parameters",
    "href": "reference/axis_ticks_length_minor_x.html#parameters",
    "title": " plotnine.themes.themeable.axis_ticks_length_minor_x",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float | complex\n\nValue in points. A negative value creates the ticks inside the plot panel. A complex value (e.g. 3j) creates ticks that span both in and out of the panel."
  },
  {
    "objectID": "reference/axis_ticks_major.html",
    "href": "reference/axis_ticks_major.html",
    "title": " plotnine.themes.themeable.axis_ticks_major",
    "section": "",
    "text": "axis_ticks_major(theme_element)"
  },
  {
    "objectID": "reference/axis_ticks_major.html#parameters",
    "href": "reference/axis_ticks_major.html#parameters",
    "title": " plotnine.themes.themeable.axis_ticks_major",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/axis_ticks_major_y.html",
    "href": "reference/axis_ticks_major_y.html",
    "title": " plotnine.themes.themeable.axis_ticks_major_y",
    "section": "",
    "text": "axis_ticks_major_y(theme_element)"
  },
  {
    "objectID": "reference/axis_ticks_major_y.html#parameters",
    "href": "reference/axis_ticks_major_y.html#parameters",
    "title": " plotnine.themes.themeable.axis_ticks_major_y",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/axis_ticks_minor_x.html",
    "href": "reference/axis_ticks_minor_x.html",
    "title": " plotnine.themes.themeable.axis_ticks_minor_x",
    "section": "",
    "text": "axis_ticks_minor_x(theme_element)"
  },
  {
    "objectID": "reference/axis_ticks_minor_x.html#parameters",
    "href": "reference/axis_ticks_minor_x.html#parameters",
    "title": " plotnine.themes.themeable.axis_ticks_minor_x",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/axis_ticks_x.html",
    "href": "reference/axis_ticks_x.html",
    "title": " plotnine.themes.themeable.axis_ticks_x",
    "section": "",
    "text": "axis_ticks_x(theme_element)"
  },
  {
    "objectID": "reference/axis_ticks_x.html#parameters",
    "href": "reference/axis_ticks_x.html#parameters",
    "title": " plotnine.themes.themeable.axis_ticks_x",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/axis_title.html",
    "href": "reference/axis_title.html",
    "title": " plotnine.themes.themeable.axis_title",
    "section": "",
    "text": "axis_title(theme_element)"
  },
  {
    "objectID": "reference/axis_title.html#parameters",
    "href": "reference/axis_title.html#parameters",
    "title": " plotnine.themes.themeable.axis_title",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/axis_title_y.html",
    "href": "reference/axis_title_y.html",
    "title": " plotnine.themes.themeable.axis_title_y",
    "section": "",
    "text": "axis_title_y(theme_element)"
  },
  {
    "objectID": "reference/axis_title_y.html#parameters",
    "href": "reference/axis_title_y.html#parameters",
    "title": " plotnine.themes.themeable.axis_title_y",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/base_margin.html",
    "href": "reference/base_margin.html",
    "title": " plotnine.options.base_margin",
    "section": "",
    "text": "base_margin : float = 0.01\n\n\nA size that is proportional of the figure width and is used by some themes to determine other margins"
  },
  {
    "objectID": "reference/coord_cartesian.html",
    "href": "reference/coord_cartesian.html",
    "title": " plotnine.coord_cartesian",
    "section": "",
    "text": "coord_cartesian(xlim=None, ylim=None, expand=True)"
  },
  {
    "objectID": "reference/coord_cartesian.html#parameters",
    "href": "reference/coord_cartesian.html#parameters",
    "title": " plotnine.coord_cartesian",
    "section": "Parameters",
    "text": "Parameters\n\n\nxlim : tuple[Any, Any] | None = None\n\nLimits (in data type of the x-aesthetic) for x axis. If None, then they are automatically computed.\n\nylim : tuple[Any, Any] | None = None\n\nLimits (in data type of the x-aesthetic) for y axis. If None, then they are automatically computed.\n\nexpand : bool = True\n\nIf True, expand the coordinate axes by some factor. If False, use the limits from the data."
  },
  {
    "objectID": "reference/coord_fixed.html",
    "href": "reference/coord_fixed.html",
    "title": " plotnine.coord_fixed",
    "section": "",
    "text": "coord_fixed(ratio=1, xlim=None, ylim=None, expand=True)"
  },
  {
    "objectID": "reference/coord_fixed.html#parameters",
    "href": "reference/coord_fixed.html#parameters",
    "title": " plotnine.coord_fixed",
    "section": "Parameters",
    "text": "Parameters\n\n\nratio : float = 1\n\nDesired aspect_ratio (:math:y/x) of the panel(s).\n\nxlim : tuple[float, float] = None\n\nLimits for x axis. If None, then they are automatically computed.\n\nylim : tuple[float, float] = None\n\nLimits for y axis. If None, then they are automatically computed.\n\nexpand : bool = True\n\nIf True, expand the coordinate axes by some factor. If False, use the limits from the data."
  },
  {
    "objectID": "reference/coord_fixed.html#notes",
    "href": "reference/coord_fixed.html#notes",
    "title": " plotnine.coord_fixed",
    "section": "Notes",
    "text": "Notes\nTo specify aspect ratio of the visual size for the axes use the aspect_ratio themeable.\nggplot(data, aes('x', 'y')) + theme(aspect_ratio=0.5)\nWhen changing the aspect_ratio in either way, the width of the panel remains constant (as derived from the plotnine.themes.themeable.figure_size themeable) and the height is altered to achieve desired ratio."
  },
  {
    "objectID": "reference/coord_trans.html",
    "href": "reference/coord_trans.html",
    "title": " plotnine.coord_trans",
    "section": "",
    "text": "coord_trans(x=\"identity\", y=\"identity\", xlim=None, ylim=None, expand=True)"
  },
  {
    "objectID": "reference/coord_trans.html#parameters",
    "href": "reference/coord_trans.html#parameters",
    "title": " plotnine.coord_trans",
    "section": "Parameters",
    "text": "Parameters\n\n\nx : str | trans = \"identity\"\n\nName of transform or trans class to transform the x axis\n\ny : str | trans = \"identity\"\n\nName of transform or trans class to transform the y axis\n\nxlim : tuple[float, float] = None\n\nLimits for x axis. If None, then they are automatically computed.\n\nylim : tuple[float, float] = None\n\nLimits for y axis. If None, then they are automatically computed.\n\nexpand : bool = True\n\nIf True, expand the coordinate axes by some factor. If False, use the limits from the data."
  },
  {
    "objectID": "reference/diamonds.html",
    "href": "reference/diamonds.html",
    "title": " plotnine.data.diamonds",
    "section": "",
    "text": "diamonds = pd.read_csv(DATA_DIR / \"diamonds.csv\")"
  },
  {
    "objectID": "reference/diamonds.html#description",
    "href": "reference/diamonds.html#description",
    "title": " plotnine.data.diamonds",
    "section": "Description",
    "text": "Description\nA dataset containing the prices and other attributes of almost 54,000 diamonds. The variables are as follows:"
  },
  {
    "objectID": "reference/diamonds.html#format",
    "href": "reference/diamonds.html#format",
    "title": " plotnine.data.diamonds",
    "section": "Format",
    "text": "Format\nA data frame with 53940 rows and 10 variables:\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\nprice\nprice in US dollars ($326–$18,823)\n\n\ncarat\nweight of the diamond (0.2–5.01)\n\n\ncut\nquality of the cut (Fair, Good, Very Good, Premium, Ideal)\n\n\ncolor\ndiamond colour, from J (worst) to D (best)\n\n\nclarity\na measurement of how clear the diamond is (I1 (worst), SI1, SI2, VS1, VS2, VVS1, VVS2, IF (best))\n\n\nx\nlength in mm (0–10.74)\n\n\ny\nwidth in mm (0–58.9)\n\n\nz\ndepth in mm (0–31.8)\n\n\ndepth\ntotal depth percentage = z / mean(x, y) = 2 * z / (x + y) (43–79)\n\n\ntable\nwidth of top of diamond relative to widest point (43–95)"
  },
  {
    "objectID": "reference/economics.html",
    "href": "reference/economics.html",
    "title": " plotnine.data.economics",
    "section": "",
    "text": "economics = pd.read_csv(DATA_DIR / \"economics.csv\", parse_dates=[0])"
  },
  {
    "objectID": "reference/economics.html#description",
    "href": "reference/economics.html#description",
    "title": " plotnine.data.economics",
    "section": "Description",
    "text": "Description\nThis dataset was produced from US economic time series data available from http://research.stlouisfed.org/fred2. economics is in “wide” format, economics_long is in “long” format."
  },
  {
    "objectID": "reference/economics.html#format",
    "href": "reference/economics.html#format",
    "title": " plotnine.data.economics",
    "section": "Format",
    "text": "Format\nA data frame with 478 rows and 6 variables\n\n\n\nColumn\nDescription\n\n\n\n\ndate\nMonth of data collection\n\n\npsavert\npersonal savings rate 1\n\n\npce\npersonal consumption expenditures, in billions of dollars 2\n\n\nunemploy\nnumber of unemployed in thousands 3\n\n\nuempmed\nmedian duration of unemployment, in week 4\n\n\npop\ntotal population, in thousands 5"
  },
  {
    "objectID": "reference/economics.html#footnotes",
    "href": "reference/economics.html#footnotes",
    "title": " plotnine.data.economics",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttp://research.stlouisfed.org/fred2/series/PSAVERT↩︎\nhttp://research.stlouisfed.org/fred2/series/PCE↩︎\nhttp://research.stlouisfed.org/fred2/series/UNEMPLOY↩︎\nhttp://research.stlouisfed.org/fred2/series/UEMPMED↩︎\nhttp://research.stlouisfed.org/fred2/series/POP↩︎"
  },
  {
    "objectID": "reference/element_blank.html",
    "href": "reference/element_blank.html",
    "title": " plotnine.element_blank",
    "section": "",
    "text": "element_blank()\n\n\nTheme element: Blank"
  },
  {
    "objectID": "reference/element_rect.html",
    "href": "reference/element_rect.html",
    "title": " plotnine.element_rect",
    "section": "",
    "text": "element_rect(\n    fill=None, color=None, size=None, linetype=None, colour=None, kwargs={}\n)"
  },
  {
    "objectID": "reference/element_rect.html#parameters",
    "href": "reference/element_rect.html#parameters",
    "title": " plotnine.element_rect",
    "section": "Parameters",
    "text": "Parameters\n\n\nfill : str | tuple = None\n\nRectangle background color\n\ncolor : str | tuple = None\n\nLine color\n\ncolour : str | tuple = None\n\nAlias of color\n\nsize : float = None\n\nLine thickness\n\nkwargs : dict = {}\n\nParameters recognised by Rectangle. In some cases you can use the fancy parameters from FancyBboxPatch."
  },
  {
    "objectID": "reference/expand_limits.html",
    "href": "reference/expand_limits.html",
    "title": " plotnine.expand_limits",
    "section": "",
    "text": "expand_limits(kwargs={})"
  },
  {
    "objectID": "reference/expand_limits.html#parameters",
    "href": "reference/expand_limits.html#parameters",
    "title": " plotnine.expand_limits",
    "section": "Parameters",
    "text": "Parameters\n\n\nkwargs : dict | dataframe = {}\n\nData to use in expanding the limits. The keys should be aesthetic names e.g. x, y, colour, …"
  },
  {
    "objectID": "reference/facet_grid.html",
    "href": "reference/facet_grid.html",
    "title": " plotnine.facet_grid",
    "section": "",
    "text": "facet_grid(\n    rows=None,\n    cols=None,\n    *,\n    margins=False,\n    scales=\"fixed\",\n    space=\"fixed\",\n    shrink=True,\n    labeller=\"label_value\",\n    as_table=True,\n    drop=True\n)"
  },
  {
    "objectID": "reference/facet_grid.html#parameters",
    "href": "reference/facet_grid.html#parameters",
    "title": " plotnine.facet_grid",
    "section": "Parameters",
    "text": "Parameters\n\n\nrows : Optional[str | Sequence[str]] = None\n\nVariable expressions along the rows of the facets/panels. Each expression is evaluated within the context of the dataframe.\n\ncols : Optional[str | Sequence[str]] = None\n\nVariable expressions along the columns of the facets/panels. Each expression is evaluated within the context of the dataframe.\n\nmargins : bool | Sequence[str] = False\n\nvariable names to compute margins for. True will compute all possible margins.\n\nspace : Literal[\"fixed\", \"free\", \"free_x\", \"free_y\"] | FacetSpaceRatios = \"fixed\"\n\nControl the size of the x or y sides of the panels. The size also depends to the scales parameter.\nIf a string, it should be one of ['fixed', 'free', 'free_x', 'free_y'].\nIf a dict, it indicates the relative facet size ratios such as:\n{\"x\": [1, 2], \"y\": [3, 1, 1]}\nThis means that in the horizontal direction, the second panel will be twice the length of the first. In the vertical direction the top facet will be the 3 times longer then the second and third facets.\nNote that the number of dimensions in the list must equal the number of facets that will be produced.\n\nshrink : bool = True\n\nWhether to shrink the scales to the output of the statistics instead of the raw data.\n\nlabeller : Literal[\"label_value\", \"label_both\", \"label_context\"] = \"label_value\"\n\nHow to label the facets. A string value if it should be one of [\"label_value\", \"label_both\", \"label_context\"].\n\nas_table : bool = True\n\nIf True, the facets are laid out like a table with the highest values at the bottom-right. If False the facets are laid out like a plot with the highest value a the top-right\n\ndrop : bool = True\n\nIf True, all factor levels not used in the data will automatically be dropped. If False, all factor levels will be shown, regardless of whether or not they appear in the data."
  },
  {
    "objectID": "reference/facet_grid.html#examples",
    "href": "reference/facet_grid.html#examples",
    "title": " plotnine.facet_grid",
    "section": "Examples",
    "text": "Examples\n\n\n\nfrom plotnine import ggplot, aes, geom_point, labs, facet_grid, theme, element_text, element_rect\nfrom plotnine.data import mpg\n\n\nFacet grid\nfacet_grid() is used to form a grid of plots, where the rows and columns of the grid are set by the faceting variables. It is useful for visualising two discrete variables.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nBasic scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nFacet a discrete variable into rows:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid(\"drv\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nFacet a discrete variable into columns:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid(cols=\"cyl\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nFacet two discrete variables into rows and columns:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid(\"drv\", \"cyl\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nTo change the plot order of the rows or columns in the facet grid, reorder the levels of the faceting variable in the data.\n\n# re-order categories\nmpg[\"drv\"] = mpg[\"drv\"].cat.reorder_categories([\"f\", \"r\", \"4\"])\n\n\n# facet plot with reorded drv category\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid(\"drv\", \"cyl\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can choose if the scale of x- and y-axes are fixed or variable by using the scales argument within the facet_grid() command:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid(\"drv\", scales=\"free\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can add additional information to your facet labels, by using the labeller argument within the facet_grid() command. Below we use labeller = 'label_both' to include the column name in the facet label.\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid(\"drv\", labeller=\"label_both\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can add two discrete variables to a facet:\n\n# add additional column for plotting exercise\nmpg[\"transmission\"] = mpg[\"trans\"].map(\n    lambda x: \"auto\" if \"auto\" in x else \"man\" if \"man\" in x else \"\"\n)\n\n\n# inspect new column transmission which identifies cars as having an automatic or manual transmission\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\ntransmission\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\nauto\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\nman\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\nman\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\nauto\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\nauto\n\n\n\n\n\n\n\n\n# facet plot with two variables on one facet\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_grid([\"drv\", \"transmission\"])  # use a list to add additional faceting variables\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nFacet labels can be rotated to make them easier to read using strip_text_y = element_text(angle = 0) for row labels within the theme() command (use strip_text_x = element_text(angle = 0) for column labels).\nIf the labels do not fit in the strip, adjust the width of the strip using strip_background_y for rows (use strip_background_x for columns). You may also need to adjust the text position so it fits in the strip: adjust the horizontal text position in the strip by specifying ha in element_text()(specify va in element_text() to adjust the vertical text position).\nYou can also change the colour of the strip by specifying color in element_text() .\n\n(\n    ggplot(mpg, aes(x=\"drv\", y=\"model\"))\n    + geom_point()\n    + facet_grid(\"manufacturer\", scales=\"free\")\n    + theme(\n        strip_text_y=element_text(angle=0),   # change facet text angle\n        strip_background_y=element_rect(fill=\"#969dff\"),   # change background colour of facet background\n        figure_size=(6, 15),  # adjust width & height of figure to fit y-axis\n    )\n    + labs(x=\"displacement\", y=\"\")\n)\n\n\n\n\n\n\n\n\n\nSource: Facet grid"
  },
  {
    "objectID": "reference/facet_wrap.html",
    "href": "reference/facet_wrap.html",
    "title": " plotnine.facet_wrap",
    "section": "",
    "text": "facet_wrap(\n    facets=None,\n    *,\n    nrow=None,\n    ncol=None,\n    scales=\"fixed\",\n    shrink=True,\n    labeller=\"label_value\",\n    as_table=True,\n    drop=True,\n    dir=\"h\"\n)"
  },
  {
    "objectID": "reference/facet_wrap.html#parameters",
    "href": "reference/facet_wrap.html#parameters",
    "title": " plotnine.facet_wrap",
    "section": "Parameters",
    "text": "Parameters\n\n\nfacets : Optional[str | Sequence[str]] = None\n\nVariables to groupby and plot on different panels. If a string formula is used it should be right sided, e.g \"~ a + b\", (\"a\", \"b\")\n\nnrow : int = None\n\nNumber of rows\n\nncol : int = None\n\nNumber of columns\n\nscales : Literal[\"fixed\", \"free\", \"free_x\", \"free_y\"] = \"fixed\"\n\nWhether x or y scales should be allowed (free) to vary according to the data on each of the panel.\n\nshrink : bool = True\n\nWhether to shrink the scales to the output of the statistics instead of the raw data.\n\nlabeller : Literal[\"label_value\", \"label_both\", \"label_context\"] = \"label_value\"\n\nHow to label the facets. A string value if it should be one of [\"label_value\", \"label_both\", \"label_context\"].\n\nas_table : bool = True\n\nIf True, the facets are laid out like a table with the highest values at the bottom-right. If False the facets are laid out like a plot with the highest value a the top-right\n\ndrop : bool = True\n\nIf True, all factor levels not used in the data will automatically be dropped. If False, all factor levels will be shown, regardless of whether or not they appear in the data.\n\ndir : Literal[\"h\", \"v\"] = \"h\"\n\nDirection in which to layout the panels. h for horizontal and v for vertical."
  },
  {
    "objectID": "reference/facet_wrap.html#examples",
    "href": "reference/facet_wrap.html#examples",
    "title": " plotnine.facet_wrap",
    "section": "Examples",
    "text": "Examples\n\n\n\nfrom plotnine import ggplot, aes, geom_point, labs, facet_wrap, theme\nfrom plotnine.data import mpg\n\n\nFacet wrap\nfacet_wrap() creates a collection of plots (facets), where each plot is differentiated by the faceting variable. These plots are wrapped into a certain number of columns or rows as specified by the user.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nBasic scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nFacet a discrete variable using facet_wrap():\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\"class\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nControl the number of rows and columns with the options nrow and ncol:\n\n# Selecting the number of columns to display\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\n        \"class\",\n        ncol=4,  # change the number of columns\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\n\n# Selecting the number of rows to display\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\n        \"class\",\n        nrow=4,  # change the number of columns\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nTo change the plot order of the facets, reorder the levels of the faceting variable in the data.\n\n# re-order categories\nmpg[\"class\"] = mpg[\"class\"].cat.reorder_categories(\n    [\"pickup\", \"suv\", \"minivan\", \"midsize\", \"compact\", \"subcompact\", \"2seater\"]\n)\n\n\n# facet plot with reorded drv category\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\"class\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nOrdinarily the facets are arranged horizontally (left-to-right from top to bottom). However if you would prefer a vertical layout (facets are arranged top-to-bottom, from left to right) use the dir option:\n\n# Facet plot with vertical layout\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\n        \"class\",\n        dir=\"v\",  # change to a vertical layout\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can choose if the scale of x- and y-axes are fixed or variable. Set the scales argument to free-y, free_x or free for a free scales on the y-axis, x-axis or both axes respectively. You may need to add spacing between the facets to ensure axis ticks and values are easy to read.\nA fixed scale is the default and does not need to be specified.\n\n# facet plot with free scales\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\n        \"class\",\n        scales=\"free_y\",  # set scales so y-scale varies with the data\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can add additional information to your facet labels, by using the labeller argument within the facet_wrap() command. Below we use labeller = 'label_both' to include the column name in the facet label.\n\n# facet plot with labeller\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\"class\", labeller=\"label_both\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can add two discrete variables to a facet:\n\n# add additional column for plotting exercise\nmpg[\"transmission\"] = mpg[\"trans\"].map(\n    lambda x: \"auto\" if \"auto\" in x else \"man\" if \"man\" in x else \"\"\n)\n\n\n# inspect new column transmission which identifies cars as having an automatic or manual transmission\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\ntransmission\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\nauto\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\nman\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\nman\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\nauto\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\nauto\n\n\n\n\n\n\n\n\n# facet plot with two variables on one facet\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap([\"class\", \"transmission\"])  # use a list to add additional facetting variables\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\n\nSource: Facet wrap"
  },
  {
    "objectID": "reference/faithful.html",
    "href": "reference/faithful.html",
    "title": " plotnine.data.faithful",
    "section": "",
    "text": "faithful = pd.read_csv(DATA_DIR / \"faithful.csv\")"
  },
  {
    "objectID": "reference/faithful.html#description",
    "href": "reference/faithful.html#description",
    "title": " plotnine.data.faithful",
    "section": "Description",
    "text": "Description\nWaiting time between eruptions and the duration of the eruption for the Old Faithful geyser in Yellowstone National Park, Wyoming, USA."
  },
  {
    "objectID": "reference/faithful.html#format",
    "href": "reference/faithful.html#format",
    "title": " plotnine.data.faithful",
    "section": "Format",
    "text": "Format\nA data frame with 272 observations on 2 variables.\n\n\n\nColumn\nDescription\n\n\n\n\neruptions\nEruption time in mins\n\n\nwaiting W\naiting time to next eruption (in mins)"
  },
  {
    "objectID": "reference/faithful.html#details",
    "href": "reference/faithful.html#details",
    "title": " plotnine.data.faithful",
    "section": "Details",
    "text": "Details\nA closer look at faithful.eruptions reveals that these are heavily rounded times originally in seconds, where multiples of 5 are more frequent than expected under non-human measurement. For a better version of the eruption times, see the example below.\nThere are many versions of this dataset around: Azzalini and Bowman (1990) use a more complete version."
  },
  {
    "objectID": "reference/faithful.html#source",
    "href": "reference/faithful.html#source",
    "title": " plotnine.data.faithful",
    "section": "Source",
    "text": "Source\nW. Härdle."
  },
  {
    "objectID": "reference/faithful.html#references",
    "href": "reference/faithful.html#references",
    "title": " plotnine.data.faithful",
    "section": "References",
    "text": "References\nHärdle, W. (1991) Smoothing Techniques with Implementation in S. New York: Springer.\nAzzalini, A. and Bowman, A. W. (1990). A look at some data on the Old Faithful geyser. Applied Statistics 39, 357–365."
  },
  {
    "objectID": "reference/figure_format.html",
    "href": "reference/figure_format.html",
    "title": " plotnine.options.figure_format",
    "section": "",
    "text": "figure_format : Optional[FigureFormat] = None\n\n\nThe format for the inline figures outputted by the jupyter kernel.\nIf None, it is the value of\n%config InlineBackend.figure_format\nIf that has not been set, the default is “retina”. You can set it explicitly with:\n%config InlineBackend.figure_format = \"retina\""
  },
  {
    "objectID": "reference/geom.html",
    "href": "reference/geom.html",
    "title": " plotnine.geoms.geom.geom",
    "section": "",
    "text": "geom(mapping=None, data=None, kwargs={})"
  },
  {
    "objectID": "reference/geom.html#attributes",
    "href": "reference/geom.html#attributes",
    "title": " plotnine.geoms.geom.geom",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nDEFAULT_AES\ndict() -&gt; new empty dictionary\n\n\nDEFAULT_PARAMS\ndict() -&gt; new empty dictionary\n\n\nNON_MISSING_AES\nset() -&gt; new empty set object\n\n\nREQUIRED_AES\nset() -&gt; new empty set object\n\n\naes_params\ndict() -&gt; new empty dictionary\n\n\ndata\nGeom/layer specific dataframe\n\n\nlegend_geom\nstr(object=’’) -&gt; str\n\n\nmapping\nMappings i.e. aes(x=\"col1\", fill=\"col2\")\n\n\n\n\n DEFAULT_AES\n\nDEFAULT_AES : dict[str, Any] = {}\n\n\ndict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object’s (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)\n\n\n\n DEFAULT_PARAMS\n\nDEFAULT_PARAMS : dict[str, Any] = {}\n\n\ndict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object’s (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)\n\n\n\n NON_MISSING_AES\n\nNON_MISSING_AES : set[str] = set()\n\n\nset() -&gt; new empty set object set(iterable) -&gt; new set object\nBuild an unordered collection of unique elements.\n\n\n\n REQUIRED_AES\n\nREQUIRED_AES : set[str] = set()\n\n\nset() -&gt; new empty set object set(iterable) -&gt; new set object\nBuild an unordered collection of unique elements.\n\n\n\n aes_params\n\naes_params : dict[str, Any] = {ae: kwargs[ae]for ae in self.aesthetics() & set(kwargs)}\n\n\ndict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object’s (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)\n\n\n\n data\n\ndata : DataLike = kwargs[\"data\"]\n\n\nGeom/layer specific dataframe\n\n\n\n legend_geom\n\nlegend_geom : str = \"point\"\n\n\nstr(object=’’) -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str\nCreate a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to ‘strict’.\n\n\n\n mapping\n\nmapping : aes = kwargs[\"mapping\"]\n\n\nMappings i.e. aes(x=\"col1\", fill=\"col2\")"
  },
  {
    "objectID": "reference/geom.html#methods",
    "href": "reference/geom.html#methods",
    "title": " plotnine.geoms.geom.geom",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\naesthetics\nReturn all the aesthetics for this geom\n\n\ndraw_group\nPlot data belonging to a group.\n\n\ndraw_layer\nDraw layer across all panels\n\n\ndraw_legend\nDraw a rectangle in the box\n\n\ndraw_panel\nPlot all groups\n\n\ndraw_unit\nPlot data belonging to a unit.\n\n\nfrom_stat\nReturn an instantiated geom object\n\n\nhandle_na\nRemove rows with NaN values\n\n\nlegend_key_size\nCalculate the size of key that would fit the layer contents\n\n\nsetup_data\nModify the data before drawing takes place\n\n\nto_layer\nMake a layer that represents this geom\n\n\nuse_defaults\nCombine data with defaults and set aesthetics from parameters\n\n\n\n\n aesthetics \n\naesthetics()\n\n\nReturn all the aesthetics for this geom\ngeoms should not override this method.\n\n\n\n draw_group \n\ndraw_group(data, panel_params, coord, ax, params={})\n\n\nPlot data belonging to a group.\n\n\nParameters\n\n\ndata : pd.DataFrame\n\nData to be plotted by this geom. This is the dataframe created in the plot_build pipeline.\n\npanel_params : panel_view\n\nThe scale information as may be required by the axes. At this point, that information is about ranges, ticks and labels. Keys of interest to the geom are:\n\"x_range\"  # tuple\n\"y_range\"  # tuple\n\ncoord : coord\n\nCoordinate (e.g. coord_cartesian) system of the geom.\n\nax : axes\n\nAxes on which to plot.\n\nparams : dict = {}\n\nCombined parameters for the geom and stat. Also includes the zorder.\n\n\n\n\n\n\n draw_layer\n\ndraw_layer(data, layout, coord, params={})\n\n\nDraw layer across all panels\ngeoms should not override this method.\n\n\nParameters\n\n\ndata : pd.DataFrame\n\nDataFrame specific for this layer\n\nlayout : Layout\n\nLayout object created when the plot is getting built\n\ncoord : coord\n\nType of coordinate axes\n\nparams : Any = {}\n\nCombined geom and stat parameters. Also includes the stacking order of the layer in the plot (zorder)\n\n\n\n\n\n\n draw_legend \n\ndraw_legend(data, da, lyr)\n\n\nDraw a rectangle in the box\n\n\nParameters\n\n\ndata : pd.Series[Any]\n\nA row of the data plotted to this layer\n\nda : DrawingArea\n\nCanvas on which to draw\n\nlyr : layer\n\nLayer that the geom belongs to.\n\n\n\n\n\nReturns\n\n\nDrawingArea\n\nThe DrawingArea after a layer has been drawn onto it.\n\n\n\n\n\n\n draw_panel\n\ndraw_panel(data, panel_params, coord, ax, params={})\n\n\nPlot all groups\nFor efficiency, geoms that do not need to partition different groups before plotting should override this method and avoid the groupby.\n\n\nParameters\n\n\ndata : pd.DataFrame\n\nData to be plotted by this geom. This is the dataframe created in the plot_build pipeline.\n\npanel_params : panel_view\n\nThe scale information as may be required by the axes. At this point, that information is about ranges, ticks and labels. Attributes are of interest to the geom are:\n\"panel_params.x.range\"  # tuple\n\"panel_params.y.range\"  # tuple\n\ncoord : coord\n\nCoordinate (e.g. coord_cartesian) system of the geom.\n\nax : Axes\n\nAxes on which to plot.\n\nparams : Any = {}\n\nCombined parameters for the geom and stat. Also includes the zorder.\n\n\n\n\n\n\n draw_unit \n\ndraw_unit(data, panel_params, coord, ax, params={})\n\n\nPlot data belonging to a unit.\nA matplotlib plot function may require that an aethestic have a single unique value. e.g. linestyle=\"dashed\" and not linestyle=[\"dashed\", \"dotted\", ...]. A single call to such a function can only plot lines with the same linestyle. However, if the plot we want has more than one line with different linestyles, we need to group the lines with the same linestyle and plot them as one unit. In this case, draw_group calls this function to do the plotting. For an example see geom_point.\n\n\nParameters\n\n\ndata : pd.DataFrame\n\nData to be plotted by this geom. This is the dataframe created in the plot_build pipeline.\n\npanel_params : panel_view\n\nThe scale information as may be required by the axes. At this point, that information is about ranges, ticks and labels. Keys of interest to the geom are:\n\"x_range\"  # tuple\n\"y_range\"  # tuple\nIn rare cases a geom may need access to the x or y scales. Those are available at:\n\"scales\"   # SimpleNamespace\n\ncoord : coord\n\nCoordinate (e.g. coord_cartesian) system of the geom.\n\nax : Axes\n\nAxes on which to plot.\n\nparams : Any = {}\n\nCombined parameters for the geom and stat. Also includes the zorder.\n\n\n\n\n\n\n from_stat \n\nfrom_stat(stat)\n\n\nReturn an instantiated geom object\ngeoms should not override this method.\n\n\nParameters\n\n\nstat : stat\n\nstat\n\n\n\n\n\nReturns\n\n\ngeom\n\nA geom object\n\n\n\n\n\nRaises\n\n\nPlotnineError\n\nIf unable to create a geom.\n\n\n\n\n\n\n handle_na\n\nhandle_na(data)\n\n\nRemove rows with NaN values\ngeoms that infer extra information from missing values should override this method. For example geom_path.\n\n\nParameters\n\n\ndata : pd.DataFrame\n\nData\n\n\n\n\n\nReturns\n\n\npd.DataFrame\n\nData without the NaNs.\n\n\n\n\n\nNotes\nShows a warning if the any rows are removed and the na_rm parameter is False. It only takes into account the columns of the required aesthetics.\n\n\n\n legend_key_size \n\nlegend_key_size(data, min_size, lyr)\n\n\nCalculate the size of key that would fit the layer contents\n\n\nParameters\n\n\ndata : pd.Series[Any]\n\nA row of the data plotted to this layer\n\nmin_size : tuple[int, int]\n\nInitial size which should be expanded to fit the contents.\n\nlyr : layer\n\nLayer\n\n\n\n\n\n\n setup_data\n\nsetup_data(data)\n\n\nModify the data before drawing takes place\nThis function is called before position adjustments are done. It is used by geoms to create the final aesthetics used for drawing. The base class method does nothing, geoms can override this method for two reasons:\n\nThe stat does not create all the aesthetics (usually position aesthetics) required for drawing the geom, but those aesthetics can be computed from the available data. For example geom_boxplot and geom_violin.\nThe geom inherits from another geom (superclass) which does the drawing and the superclass requires certain aesthetics to be present in the data. For example geom_tile and geom_area.\n\n\n\nParameters\n\n\ndata : pd.DataFrame\n\nData used for drawing the geom.\n\n\n\n\n\nReturns\n\n\npd.DataFrame\n\nData used for drawing the geom.\n\n\n\n\n\n\n to_layer\n\nto_layer()\n\n\nMake a layer that represents this geom\n\n\nReturns\n\n\nlayer\n\nLayer\n\n\n\n\n\n\n use_defaults\n\nuse_defaults(data, aes_modifiers)\n\n\nCombine data with defaults and set aesthetics from parameters\ngeoms should not override this method.\n\n\nParameters\n\n\ndata : pd.DataFrame\n\nData used for drawing the geom.\n\naes_modifiers : dict[str, Any]\n\nAesthetics to evaluate\n\n\n\n\n\nReturns\n\n\npd.DataFrame\n\nData used for drawing the geom."
  },
  {
    "objectID": "reference/geom_area.html",
    "href": "reference/geom_area.html",
    "title": " plotnine.geom_area",
    "section": "",
    "text": "geom_area(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"stack\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    outline_type=\"upper\",\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_area.html#parameters",
    "href": "reference/geom_area.html#parameters",
    "title": " plotnine.geom_area",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\n'none'\n\n\nfill\n'#333333'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\nwhere\nTrue\n\n\n\nThe bold aesthetics are required.\nAesthetics Descriptions\n\nwhere\n\nDefine where to exclude horizontal regions from being filled. Regions between any two False values are skipped. For sensible demarcation the value used in the where predicate expression should match the ymin value or expression. i.e.\n aes(ymin=0, ymax=\"col1\", where=\"col1 &gt; 0\")  # good\n aes(ymin=0, ymax=\"col1\", where=\"col1 &gt; 10\")  # bad\n\n aes(ymin=col2, ymax=\"col1\", where=\"col1 &gt; col2\")  # good\n aes(ymin=col2, ymax=\"col1\", where=\"col1 &gt; col3\")  # bad\n\n\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"stack\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_area.html#see-also",
    "href": "reference/geom_area.html#see-also",
    "title": " plotnine.geom_area",
    "section": "See Also",
    "text": "See Also\n\ngeom_ribbon"
  },
  {
    "objectID": "reference/geom_area.html#examples",
    "href": "reference/geom_area.html#examples",
    "title": " plotnine.geom_area",
    "section": "Examples",
    "text": "Examples\n\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_area,\n    geom_line,\n    scale_x_date,\n    scale_y_continuous,\n    theme_linedraw,\n    theme_set,\n)\nfrom plotnine.data import economics\n\n# Set default theme\ntheme_set(theme_linedraw())\n\n\nArea Under Line\n\n# Gallery, areas\n(\n    ggplot(economics, aes(x=\"date\", y=\"unemploy\"))\n    + geom_line()\n    + geom_area(fill=\"#e5c8d6\", color=\"#9e2f68\")\n    + scale_x_date(expand=(0, 0), date_labels=\"%Y\")\n    + scale_y_continuous(expand=(0, 0, 0.1, 0))\n    + theme_linedraw()\n)\n\n\n\n\n\n\n\n\n\nSource: Set default theme"
  },
  {
    "objectID": "reference/geom_bin_2d.html",
    "href": "reference/geom_bin_2d.html",
    "title": " plotnine.geom_bin_2d",
    "section": "",
    "text": "geom_bin_2d(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"bin_2d\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_bin_2d.html#parameters",
    "href": "reference/geom_bin_2d.html#parameters",
    "title": " plotnine.geom_bin_2d",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nxmax\n\n\n\nxmin\n\n\n\nymax\n\n\n\nymin\n\n\n\nalpha\n1\n\n\ncolor\nNone\n\n\nfill\n'#595959'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"bin_2d\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_boxplot.html",
    "href": "reference/geom_boxplot.html",
    "title": " plotnine.geom_boxplot",
    "section": "",
    "text": "geom_boxplot(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"boxplot\",\n    position=\"dodge2\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    width=None,\n    outlier_alpha=1,\n    outlier_color=None,\n    outlier_shape=\"o\",\n    outlier_size=1.5,\n    outlier_stroke=0.5,\n    notch=False,\n    varwidth=False,\n    notchwidth=0.5,\n    fatten=2,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_boxplot.html#parameters",
    "href": "reference/geom_boxplot.html#parameters",
    "title": " plotnine.geom_boxplot",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nlower\n\n\n\nmiddle\n\n\n\nupper\n\n\n\nx\n\n\n\nymax\n\n\n\nymin\n\n\n\nalpha\n1\n\n\ncolor\n'#333333'\n\n\nfill\n'white'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nshape\n'o'\n\n\nsize\n0.5\n\n\nweight\n1\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"boxplot\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"dodge2\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nwidth : float = None\n\nBox width. If None, the width is set to 90% of the resolution of the data. Note that if the stat has a width parameter, that takes precedence over this one.\n\noutlier_alpha : float = 1\n\nTransparency of the outlier points.\n\noutlier_color : str | tuple = None\n\nColor of the outlier points.\n\noutlier_shape : str = \"o\"\n\nShape of the outlier points. An empty string hides the outliers.\n\noutlier_size : float = 1.5\n\nSize of the outlier points.\n\noutlier_stroke : float = 0.5\n\nStroke-size of the outlier points.\n\nnotch : bool = False\n\nWhether the boxes should have a notch.\n\nvarwidth : bool = False\n\nIf True, boxes are drawn with widths proportional to the square-roots of the number of observations in the groups.\n\nnotchwidth : float = 0.5\n\nWidth of notch relative to the body width.\n\nfatten : float = 2\n\nA multiplicative factor used to increase the size of the middle bar across the box.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_boxplot.html#examples",
    "href": "reference/geom_boxplot.html#examples",
    "title": " plotnine.geom_boxplot",
    "section": "Examples",
    "text": "Examples\n\n\nimport numpy as np\nimport pandas as pd\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_boxplot,\n    geom_jitter,\n    scale_x_discrete,\n    coord_flip,\n)\nfrom plotnine.data import pageviews\n\n\nA box and whiskers plot\nThe boxplot compactly displays the distribution of a continuous variable.\nRead more: + wikipedia + ggplot2 docs\n\nflights = pd.read_csv(\"data/flights.csv\")\nflights.head()\n\n\n\n\n\n\n\n\nyear\nmonth\npassengers\n\n\n\n\n0\n1949\nJanuary\n112\n\n\n1\n1949\nFebruary\n118\n\n\n2\n1949\nMarch\n132\n\n\n3\n1949\nApril\n129\n\n\n4\n1949\nMay\n121\n\n\n\n\n\n\n\nBasic boxplot\n\nmonths = [month[:3] for month in flights.month[:12]]\nprint(months)\n\n['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n\n\n\n\nA Basic Boxplot\n\n# Gallery, distributions\n(\n    ggplot(flights)\n    + geom_boxplot(aes(x=\"factor(month)\", y=\"passengers\"))\n    + scale_x_discrete(labels=months, name=\"month\")  # change ticks labels on OX\n)\n\n\n\n\n\n\n\n\nHorizontal boxplot\n\n(\n    ggplot(flights)\n    + geom_boxplot(aes(x=\"factor(month)\", y=\"passengers\"))\n    + coord_flip()\n    + scale_x_discrete(\n        labels=months[::-1],\n        limits=flights.month[11::-1],\n        name=\"month\",\n    )\n)\n\n\n\n\n\n\n\n\nBoxplot with jittered points:\n\n(\n    ggplot(flights, aes(x=\"factor(month)\", y=\"passengers\"))\n    + geom_boxplot()\n    + geom_jitter()\n    + scale_x_discrete(labels=months, name=\"month\")  # change ticks labels on OX\n)\n\n\n\n\n\n\n\n\n\n\nPrecomputed boxplots\nFor datasets that do not fit in memory, you can precompute the boxplot metrics (for example by aggregating the statistics using database queries) and then use geom_boxplot with stat=\"identity\".\n\n# Precompute the metrics\ndef q25(x):\n    return x.quantile(0.25)\n\ndef q75(x):\n    return x.quantile(0.75)\n    \npageviews[\"hour\"] = pageviews.date_hour.dt.hour\nprecomputed_metrics = pageviews.groupby(\"hour\").agg({'pageviews': [\"min\", q25, \"median\", q75, \"max\"]})\nprecomputed_metrics.columns = [col_name[1] for col_name in precomputed_metrics.columns]  \nprecomputed_metrics = precomputed_metrics.reset_index()\nprecomputed_metrics.head()\n\n\n\n\n\n\n\n\nhour\nmin\nq25\nmedian\nq75\nmax\n\n\n\n\n0\n0\n8437.500380\n8842.109077\n9297.046035\n9600.362430\n11762.446233\n\n\n1\n1\n8852.123978\n9177.938537\n9457.821814\n10530.072887\n11974.437292\n\n\n2\n2\n8793.076686\n9176.462389\n9704.885172\n10446.315276\n12105.406628\n\n\n3\n3\n8683.606449\n9574.722286\n10615.670464\n11290.246605\n11651.443193\n\n\n4\n4\n8252.974951\n9898.998785\n10959.909095\n11409.657288\n11603.711837\n\n\n\n\n\n\n\n\n(\n    ggplot(precomputed_metrics)\n    + geom_boxplot(\n        aes(x=\"factor(hour)\", ymin=\"min\", lower=\"q25\", middle=\"median\", upper=\"q75\", ymax=\"max\"),\n        stat=\"identity\"\n    )\n)\n\n\n\n\n\n\n\n\n\nSource: A box and whiskers plot"
  },
  {
    "objectID": "reference/geom_boxplot.html#precomputed-boxplots",
    "href": "reference/geom_boxplot.html#precomputed-boxplots",
    "title": " plotnine.geom_boxplot",
    "section": "Precomputed boxplots",
    "text": "Precomputed boxplots\nFor datasets that do not fit in memory, you can precompute the boxplot metrics (for example by aggregating the statistics using database queries) and then use geom_boxplot with stat=\"identity\".\n\n# Precompute the metrics\ndef q25(x):\n    return x.quantile(0.25)\n\ndef q75(x):\n    return x.quantile(0.75)\n    \npageviews[\"hour\"] = pageviews.date_hour.dt.hour\nprecomputed_metrics = pageviews.groupby(\"hour\").agg({'pageviews': [\"min\", q25, \"median\", q75, \"max\"]})\nprecomputed_metrics.columns = [col_name[1] for col_name in precomputed_metrics.columns]  \nprecomputed_metrics = precomputed_metrics.reset_index()\nprecomputed_metrics.head()\n\n\n\n\n\n\n\n\nhour\nmin\nq25\nmedian\nq75\nmax\n\n\n\n\n0\n0\n8437.500380\n8842.109077\n9297.046035\n9600.362430\n11762.446233\n\n\n1\n1\n8852.123978\n9177.938537\n9457.821814\n10530.072887\n11974.437292\n\n\n2\n2\n8793.076686\n9176.462389\n9704.885172\n10446.315276\n12105.406628\n\n\n3\n3\n8683.606449\n9574.722286\n10615.670464\n11290.246605\n11651.443193\n\n\n4\n4\n8252.974951\n9898.998785\n10959.909095\n11409.657288\n11603.711837\n\n\n\n\n\n\n\n\n(\n    ggplot(precomputed_metrics)\n    + geom_boxplot(\n        aes(x=\"factor(hour)\", ymin=\"min\", lower=\"q25\", middle=\"median\", upper=\"q75\", ymax=\"max\"),\n        stat=\"identity\"\n    )\n)"
  },
  {
    "objectID": "reference/geom_count.html",
    "href": "reference/geom_count.html",
    "title": " plotnine.geom_count",
    "section": "",
    "text": "geom_count(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"sum\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_count.html#parameters",
    "href": "reference/geom_count.html#parameters",
    "title": " plotnine.geom_count",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\nfill\nNone\n\n\ngroup\n\n\n\nshape\n'o'\n\n\nsize\n1.5\n\n\nstroke\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"sum\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_count.html#examples",
    "href": "reference/geom_count.html#examples",
    "title": " plotnine.geom_count",
    "section": "Examples",
    "text": "Examples\n\n\n\nfrom plotnine import ggplot, aes, geom_count, scale_size_continuous\nfrom plotnine.data import diamonds\n\n\nCategorized Data Plot\ngeom_count() makes the point size proportional to the number of points at a location\n\ndiamonds.head()\n\n\n\n\n\n\n\n\ncarat\ncut\ncolor\nclarity\ndepth\ntable\nprice\nx\ny\nz\n\n\n\n\n0\n0.23\nIdeal\nE\nSI2\n61.5\n55.0\n326\n3.95\n3.98\n2.43\n\n\n1\n0.21\nPremium\nE\nSI1\n59.8\n61.0\n326\n3.89\n3.84\n2.31\n\n\n2\n0.23\nGood\nE\nVS1\n56.9\n65.0\n327\n4.05\n4.07\n2.31\n\n\n3\n0.29\nPremium\nI\nVS2\n62.4\n58.0\n334\n4.20\n4.23\n2.63\n\n\n4\n0.31\nGood\nJ\nSI2\n63.3\n58.0\n335\n4.34\n4.35\n2.75\n\n\n\n\n\n\n\n\n(\n    ggplot(diamonds)\n    + geom_count(aes(x=\"cut\", y=\"color\"))\n)\n\n\n\n\n\n\n\n\nWe can adjust the size range of the points with scale_size_continuous\n\n(\n    ggplot(diamonds)\n    + geom_count(aes(x=\"cut\", y=\"color\"))\n    + scale_size_continuous(range=[1, 20])\n)\n\n\n\n\n\n\n\n\n\nSource: Categorized Data Plot"
  },
  {
    "objectID": "reference/geom_density.html",
    "href": "reference/geom_density.html",
    "title": " plotnine.geom_density",
    "section": "",
    "text": "geom_density(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"density\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    outline_type=\"upper\",\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_density.html#parameters",
    "href": "reference/geom_density.html#parameters",
    "title": " plotnine.geom_density",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\nfill\nNone\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\nweight\n1\n\n\nwhere\nTrue\n\n\n\nThe bold aesthetics are required.\nAesthetics Descriptions\n\nwhere\n\nDefine where to exclude horizontal regions from being filled. Regions between any two False values are skipped. For sensible demarcation the value used in the where predicate expression should match the ymin value or expression. i.e.\n aes(ymin=0, ymax=\"col1\", where=\"col1 &gt; 0\")  # good\n aes(ymin=0, ymax=\"col1\", where=\"col1 &gt; 10\")  # bad\n\n aes(ymin=col2, ymax=\"col1\", where=\"col1 &gt; col2\")  # good\n aes(ymin=col2, ymax=\"col1\", where=\"col1 &gt; col3\")  # bad\n\n\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"density\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_density.html#see-also",
    "href": "reference/geom_density.html#see-also",
    "title": " plotnine.geom_density",
    "section": "See Also",
    "text": "See Also\n\ngeom_ribbon"
  },
  {
    "objectID": "reference/geom_density.html#examples",
    "href": "reference/geom_density.html#examples",
    "title": " plotnine.geom_density",
    "section": "Examples",
    "text": "Examples\n\n\nimport pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    after_stat,\n    geom_density,\n    geom_histogram,\n    geom_vline,\n    geom_rect,\n    labs,\n    annotate,\n    theme_tufte,\n)\nfrom plotnine.data import mpg\n\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nThe defaults are not exactly beautiful, but still quite clear.\n\nBasic Density Plot\n\n# Gallery, distributions\n(\n    ggplot(mpg, aes(x=\"cty\"))\n    + geom_density()\n)\n\n\n\n\n\n\n\n\nPlotting multiple groups is straightforward, but as each group is plotted as an independent PDF summing to 1, the relative size of each group will be normalized.\n\n\nDensity Plot with Groups\n\n# Gallery, distributions\n(\n    ggplot(mpg, aes(x=\"cty\", color=\"drv\", fill=\"drv\"))\n    + geom_density(alpha=0.1)\n)\n\n\n\n\n\n\n\n\nTo plot multiple groups and scale them by their relative size, you can map the y aesthetic to 'count' (calculated by stat_density).\n\n(\n    ggplot(mpg, aes(x=\"cty\", color=\"drv\", fill=\"drv\"))\n    + geom_density(aes(y=after_stat(\"count\")), alpha=0.1)\n)\n\n\n\n\n\n\n\n\n\n\nDensity Plots + Histograms\nTo overlay a histogram onto the density, the y aesthetic of the density should be mapped to the 'count' scaled by the binwidth of the histograms.\nWhy?\nThe count calculated by stat_density is \\(count = density * n\\) where n is the number of points . The density curves have an area of 1 and have no information about the absolute frequency of the values along curve; only the relative frequencies. The count curve reveals the absolute frequencies. The scale of this count corresponds to the count calculated by the stat_bin for the histogram when the bins are 1 unit wide i.e. binwidth=1. The count * binwidth curve matches the scale of counts for the histogram for a give binwidth.\n\n# Gallery, distributions\n\nbinwidth = 2  # The same for geom_density and geom_histogram\n\n(\n    ggplot(mpg, aes(x=\"cty\", color=\"drv\", fill=\"drv\"))\n    + geom_density(aes(y=after_stat(\"count*binwidth\")), alpha=0.1)\n    + geom_histogram(\n        aes(fill=\"drv\", y=after_stat(\"count\")),\n        binwidth=binwidth,\n        color=\"none\",\n        alpha=0.5,\n    )\n    # It is the histogram that gives us the meaningful y axis label\n    # i.e. 'count' and not 'count*2'\n    + labs(y=\"count\")\n)\n\n\n\n\n\n\n\n\n\n\nShaded Range Under a Density Plot\nExtending geom_density to create an effect of a shaded range\nCreate some data and plot the density\n\nn = 101\ndf = pd.DataFrame({\"x\": np.arange(n)})\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n)\n\n\n\n\n\n\n\n\nSuppose we want to mark a region as special e.g. (40, 60), we can use vertical lines to annotate it.\n\nregion = (40, 60)\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n    + annotate(geom_vline, xintercept=region)  # new line\n)\n\n\n\n\n\n\n\n\nTo make it standout more we can highlight. To do that, the first thought is to use a rectangle.\n\nregion = (40, 60)\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n    + annotate(\n        geom_rect, xmin=region[0], xmax=region[1], ymin=0, ymax=float(\"inf\"), alpha=0.5\n    )  # new annotation layer\n    + annotate(geom_vline, xintercept=region)\n)\n\n\n\n\n\n\n\n\nSince y upper-bound varies along the curve, a rectangular highlight has to stretch up to the top of the panel.\nTo hightlight only within the density curve, we have to use a second density curve. We need to calculate the density as normal, but just before the curve & region are plotted, we should keep only the region we want.\nWe create our own geom_density_highlight and override the setup_data method. First, we override but do nothing, we only inspect the data to see what we have to work with.\n\n# new class\nclass geom_density_highlight(geom_density):\n    def setup_data(self, data):\n        data = super().setup_data(data)\n        print(data)\n        return data\n\n\nregion = (40, 60)\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n    + geom_density_highlight(fill=\"black\", alpha=0.5)  # new line\n    + annotate(geom_vline, xintercept=region)\n)\n\n      PANEL     count   density  group    n    scaled           x         y  \\\n0         1  0.519038  0.005139     -1  101  0.519039    0.000000  0.005139   \n1         1  0.522757  0.005176     -1  101  0.522758    0.097752  0.005176   \n2         1  0.526473  0.005213     -1  101  0.526474    0.195503  0.005213   \n3         1  0.530187  0.005249     -1  101  0.530188    0.293255  0.005249   \n4         1  0.533899  0.005286     -1  101  0.533900    0.391007  0.005286   \n...     ...       ...       ...    ...  ...       ...         ...       ...   \n1019      1  0.533899  0.005286     -1  101  0.533900   99.608993  0.005286   \n1020      1  0.530187  0.005249     -1  101  0.530188   99.706745  0.005249   \n1021      1  0.526473  0.005213     -1  101  0.526474   99.804497  0.005213   \n1022      1  0.522757  0.005176     -1  101  0.522758   99.902248  0.005176   \n1023      1  0.519038  0.005139     -1  101  0.519039  100.000000  0.005139   \n\n      ymin      ymax  \n0        0  0.005139  \n1        0  0.005176  \n2        0  0.005213  \n3        0  0.005249  \n4        0  0.005286  \n...    ...       ...  \n1019     0  0.005286  \n1020     0  0.005249  \n1021     0  0.005213  \n1022     0  0.005176  \n1023     0  0.005139  \n\n[1024 rows x 10 columns]\n\n\n\n\n\n\n\n\n\nThe highlight has filled the whole region, but the printed data suggests that we can limit the rows to those where x column is within our region.\n\nclass geom_density_highlight(geom_density):\n    # new method\n    def __init__(self, *args, region=(-np.inf, np.inf), **kwargs):\n        super().__init__(*args, **kwargs)\n        self.region = region\n\n    def setup_data(self, data):\n        data = super().setup_data(data)\n        s = f\"{self.region[0]} &lt;= x &lt;= {self.region[1]}\"  # new line\n        data = data.query(s).reset_index(drop=True)  # new line\n        return data\n\n\nregion = (40, 60)\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n    + geom_density_highlight(region=region, fill=\"black\", alpha=0.5)  # modified line\n    + annotate(geom_vline, xintercept=region)\n)\n\n\n\n\n\n\n\n\nThat is it, but we can make it look better.\n\n# Gallery, distributions\n\nclass geom_density_highlight(geom_density):\n    def __init__(self, *args, region=(-np.inf, np.inf), **kwargs):\n        super().__init__(*args, **kwargs)\n        self.region = region\n\n    def setup_data(self, data):\n        data = super().setup_data(data)\n        s = f\"{self.region[0]} &lt;= x &lt;= {self.region[1]}\"\n        data = data.query(s).reset_index(drop=True)\n        return data\n\n\nregion = (40, 60)\nteal = \"#029386\"\n\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density_highlight(region=region, fill=teal + \"88\", color=\"none\")\n    + geom_density(fill=teal + \"44\", color=teal, size=0.7)\n    + annotate(geom_vline, xintercept=region, color=teal, size=0.7)\n    + theme_tufte()\n)\n\n\n\n\n\n\n\n\nThis example was motivated by a question from github user Rishika-Ravindran.\n\nSource: Basic Density Plot"
  },
  {
    "objectID": "reference/geom_dotplot.html",
    "href": "reference/geom_dotplot.html",
    "title": " plotnine.geom_dotplot",
    "section": "",
    "text": "geom_dotplot(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"bindot\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    stackdir=\"up\",\n    stackratio=1,\n    dotsize=1,\n    stackgroups=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_dotplot.html#parameters",
    "href": "reference/geom_dotplot.html#parameters",
    "title": " plotnine.geom_dotplot",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\nfill\n'black'\n\n\ngroup\n\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"bindot\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nstackdir : Literal[\"up\", \"down\", \"center\", \"centerwhole\"] = \"up\"\n\nDirection in which to stack the dots. Options are\n\nstackratio : float = 1\n\nHow close to stack the dots. If value is less than 1, the dots overlap, if greater than 1 they are spaced.\n\ndotsize : float = 1\n\nDiameter of dots relative to binwidth.\n\nstackgroups : bool = False\n\nIf True, the dots are stacked across groups.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_dotplot.html#see-also",
    "href": "reference/geom_dotplot.html#see-also",
    "title": " plotnine.geom_dotplot",
    "section": "See Also",
    "text": "See Also\n\nstat_bindot"
  },
  {
    "objectID": "reference/geom_errorbarh.html",
    "href": "reference/geom_errorbarh.html",
    "title": " plotnine.geom_errorbarh",
    "section": "",
    "text": "geom_errorbarh(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    height=0.5,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_errorbarh.html#parameters",
    "href": "reference/geom_errorbarh.html#parameters",
    "title": " plotnine.geom_errorbarh",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nxmax\n\n\n\nxmin\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nheight : float = 0.5\n\nBar height as a fraction of the resolution of the data.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_histogram.html",
    "href": "reference/geom_histogram.html",
    "title": " plotnine.geom_histogram",
    "section": "",
    "text": "geom_histogram(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"bin\",\n    position=\"stack\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_histogram.html#parameters",
    "href": "reference/geom_histogram.html#parameters",
    "title": " plotnine.geom_histogram",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\nNone\n\n\nfill\n'#595959'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"bin\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"stack\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_histogram.html#see-also",
    "href": "reference/geom_histogram.html#see-also",
    "title": " plotnine.geom_histogram",
    "section": "See Also",
    "text": "See Also\n\ngeom_bar"
  },
  {
    "objectID": "reference/geom_histogram.html#examples",
    "href": "reference/geom_histogram.html#examples",
    "title": " plotnine.geom_histogram",
    "section": "Examples",
    "text": "Examples\n\n\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    after_stat,\n    geom_histogram,\n    facet_wrap,\n    facet_grid,\n    coord_flip,\n    scale_y_continuous,\n    scale_y_sqrt,\n    scale_y_log10,\n    scale_fill_manual,\n    theme_bw,\n    theme_xkcd,\n)\nfrom plotnine.data import diamonds\nfrom mizani.formatters import percent_format\n\n\nHistograms\nVisualise the distribution of a variable by dividing the x-axis into bins and counting the number of observations in each bin. Histograms display the counts with bars.\nYou can define the number of bins (e.g. divide the data five bins) or define the binwidth (e.g. each bin is size 10).\nDistributions can be visualised as: * count, * normalised count, * density, * normalised density, * scaled density as a percentage.\n\ndiamonds.head(5)\n\n\n\n\n\n\n\n\ncarat\ncut\ncolor\nclarity\ndepth\ntable\nprice\nx\ny\nz\n\n\n\n\n0\n0.23\nIdeal\nE\nSI2\n61.5\n55.0\n326\n3.95\n3.98\n2.43\n\n\n1\n0.21\nPremium\nE\nSI1\n59.8\n61.0\n326\n3.89\n3.84\n2.31\n\n\n2\n0.23\nGood\nE\nVS1\n56.9\n65.0\n327\n4.05\n4.07\n2.31\n\n\n3\n0.29\nPremium\nI\nVS2\n62.4\n58.0\n334\n4.20\n4.23\n2.63\n\n\n4\n0.31\nGood\nJ\nSI2\n63.3\n58.0\n335\n4.34\n4.35\n2.75\n\n\n\n\n\n\n\n\nBasic Histogram\nIf you create a basic histogram, you will be prompted to define the binwidth or number of bins.\n\n# Gallery, distributions\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram()\n)\n\n\n\n\n\n\n\n\nYou can define the width of the bins, by specifying the binwidth inside geom_histogram().\n\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram(binwidth=0.5)  # specify the binwidth\n)\n\n\n\n\n\n\n\n\nOr you can define the number of bins by specifying bins inside geom_histogram(). Note, the example below uses 10 bins, however you can’t see them all because some of the bins are too small to be noticeable.\n\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram(bins=10)  # specify the number of bins\n)\n\n\n\n\n\n\n\n\nThere are different ways to visualise the distribution, you can specify this using the y argument within aes(). In the example below I’m using the default setting: raw count with after_stat('count').\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"count\"),  # specify each bin is a count\n        ),\n    )\n    + geom_histogram(binwidth=0.50)\n)\n\n\n\n\n\n\n\n\nYou can normalise the raw count to 1 by using after_stat('ncount'):\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"ncount\"),  # normalise the count to 1\n        ),\n    )\n    + geom_histogram(binwidth=0.50)\n)\n\n\n\n\n\n\n\n\nYou can display the density of points in a bin, (this is scaled to integrate to 1) by using after_stat('density'):\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"density\"),  # density\n        ),\n    )\n    + geom_histogram(binwidth=0.50)\n)\n\n\n\n\n\n\n\n\nThe proportion of bins can be shown, in the example below the bin=0.5 accounts for about ~55% of the data:\n\n(\n    ggplot(\n        diamonds,\n        aes(x=\"carat\", y=after_stat(\"width*density\")),  # show proportion\n    )\n    + geom_histogram(binwidth=0.5)\n)\n\n\n\n\n\n\n\n\nWe can also display counts as percentages by using the percent_format() which requires the mizani.formatters library:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"width*density\")))\n    + geom_histogram(binwidth=0.5)\n    + scale_y_continuous(labels=percent_format())  # display labels as a percentage\n)\n\n\n\n\n\n\n\n\nInstead of using stat you can use stat_bin defined within geom_histogram(), this is useful if you want to layer a few different plots in the one figure.\n\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram(binwidth=0.5, alpha=0.5)\n    + geom_histogram(binwidth=0.2, alpha=0.5, fill=\"green\")\n)\n\n\n\n\n\n\n\n\nYou can also flip the x-y coordinates:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"density\")))\n    + geom_histogram(binwidth=0.5)\n    + coord_flip()\n)\n\n\n\n\n\n\n\n\nYou can visualise counts by other variables using fill within aes():\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"count\"), fill=\"cut\"))\n    + geom_histogram(binwidth=0.5)\n)\n\n\n\n\n\n\n\n\nYou can visualise too-small-to-see bars by transforming the y-axis scaling by using scale_y_sqrt() square-root scale or scale_y_log10() for a log-scale (similarly use scale_x_sqrt() and scale_x_log10() to transform the x-axis).\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"count\")))\n    + geom_histogram(binwidth=0.5)\n    + scale_y_sqrt()  # square root scale\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"count\")))\n    + geom_histogram(binwidth=0.5)\n    + scale_y_log10()  # log scale\n)\n\n\n\n\n\n\n\n\nChange the look of your plot:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"density\")))\n    + geom_histogram(\n        binwidth=0.5,\n        fill=\"green\",  # change the fill colour (one colour)\n        colour=\"pink\",  # change the outline\n        size=2,  # change the thickness of the outline\n        alpha=0.7,  # change the transparency\n    )\n    + theme_xkcd()  # play with themes (look/arrangement)\n)\n\n\n\n\n\n\n\n\nAnother change, this time changing the fill colours manually:\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"density\"),\n            fill=\"cut\",  # change the fill colour using another variable\n        ),\n    )\n    + scale_fill_manual(\n        values=[\"#000000\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\"]\n    )  # change the fill colour\n    + geom_histogram(\n        binwidth=0.5,\n        colour=\"#D55E00\",  # change the outline\n        size=1,  # change the thickness of the outline\n        alpha=0.7,  # change the transparency\n    )\n    + theme_bw()  # play with themes (look/arrangement)\n)\n\n\n\n\n\n\n\n\nWhen faceting histograms with scaled counts/densities, they are normalised by each facet, and not overall. Here’s an example of a facet wrap:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"ncount\")))\n    + geom_histogram(binwidth=0.5)\n    + facet_wrap(\"color\")  # facet wrap\n)\n\n\n\n\n\n\n\n\nHere’s an example of a facet grid with the count normalised in each grid:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"ncount\")))\n    + geom_histogram(binwidth=0.5)\n    + facet_grid(\"cut\", \"color\")\n)\n\n\n\n\n\n\n\n\n\n\nSource: Histograms"
  },
  {
    "objectID": "reference/geom_histogram.html#histograms",
    "href": "reference/geom_histogram.html#histograms",
    "title": " plotnine.geom_histogram",
    "section": "Histograms",
    "text": "Histograms\nVisualise the distribution of a variable by dividing the x-axis into bins and counting the number of observations in each bin. Histograms display the counts with bars.\nYou can define the number of bins (e.g. divide the data five bins) or define the binwidth (e.g. each bin is size 10).\nDistributions can be visualised as: * count, * normalised count, * density, * normalised density, * scaled density as a percentage.\n\ndiamonds.head(5)\n\n\n\n\n\n\n\n\ncarat\ncut\ncolor\nclarity\ndepth\ntable\nprice\nx\ny\nz\n\n\n\n\n0\n0.23\nIdeal\nE\nSI2\n61.5\n55.0\n326\n3.95\n3.98\n2.43\n\n\n1\n0.21\nPremium\nE\nSI1\n59.8\n61.0\n326\n3.89\n3.84\n2.31\n\n\n2\n0.23\nGood\nE\nVS1\n56.9\n65.0\n327\n4.05\n4.07\n2.31\n\n\n3\n0.29\nPremium\nI\nVS2\n62.4\n58.0\n334\n4.20\n4.23\n2.63\n\n\n4\n0.31\nGood\nJ\nSI2\n63.3\n58.0\n335\n4.34\n4.35\n2.75\n\n\n\n\n\n\n\n\nBasic Histogram\nIf you create a basic histogram, you will be prompted to define the binwidth or number of bins.\n\n# Gallery, distributions\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram()\n)\n\n\n\n\n\n\n\n\nYou can define the width of the bins, by specifying the binwidth inside geom_histogram().\n\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram(binwidth=0.5)  # specify the binwidth\n)\n\n\n\n\n\n\n\n\nOr you can define the number of bins by specifying bins inside geom_histogram(). Note, the example below uses 10 bins, however you can’t see them all because some of the bins are too small to be noticeable.\n\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram(bins=10)  # specify the number of bins\n)\n\n\n\n\n\n\n\n\nThere are different ways to visualise the distribution, you can specify this using the y argument within aes(). In the example below I’m using the default setting: raw count with after_stat('count').\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"count\"),  # specify each bin is a count\n        ),\n    )\n    + geom_histogram(binwidth=0.50)\n)\n\n\n\n\n\n\n\n\nYou can normalise the raw count to 1 by using after_stat('ncount'):\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"ncount\"),  # normalise the count to 1\n        ),\n    )\n    + geom_histogram(binwidth=0.50)\n)\n\n\n\n\n\n\n\n\nYou can display the density of points in a bin, (this is scaled to integrate to 1) by using after_stat('density'):\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"density\"),  # density\n        ),\n    )\n    + geom_histogram(binwidth=0.50)\n)\n\n\n\n\n\n\n\n\nThe proportion of bins can be shown, in the example below the bin=0.5 accounts for about ~55% of the data:\n\n(\n    ggplot(\n        diamonds,\n        aes(x=\"carat\", y=after_stat(\"width*density\")),  # show proportion\n    )\n    + geom_histogram(binwidth=0.5)\n)\n\n\n\n\n\n\n\n\nWe can also display counts as percentages by using the percent_format() which requires the mizani.formatters library:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"width*density\")))\n    + geom_histogram(binwidth=0.5)\n    + scale_y_continuous(labels=percent_format())  # display labels as a percentage\n)\n\n\n\n\n\n\n\n\nInstead of using stat you can use stat_bin defined within geom_histogram(), this is useful if you want to layer a few different plots in the one figure.\n\n(\n    ggplot(diamonds, aes(x=\"carat\"))\n    + geom_histogram(binwidth=0.5, alpha=0.5)\n    + geom_histogram(binwidth=0.2, alpha=0.5, fill=\"green\")\n)\n\n\n\n\n\n\n\n\nYou can also flip the x-y coordinates:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"density\")))\n    + geom_histogram(binwidth=0.5)\n    + coord_flip()\n)\n\n\n\n\n\n\n\n\nYou can visualise counts by other variables using fill within aes():\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"count\"), fill=\"cut\"))\n    + geom_histogram(binwidth=0.5)\n)\n\n\n\n\n\n\n\n\nYou can visualise too-small-to-see bars by transforming the y-axis scaling by using scale_y_sqrt() square-root scale or scale_y_log10() for a log-scale (similarly use scale_x_sqrt() and scale_x_log10() to transform the x-axis).\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"count\")))\n    + geom_histogram(binwidth=0.5)\n    + scale_y_sqrt()  # square root scale\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"count\")))\n    + geom_histogram(binwidth=0.5)\n    + scale_y_log10()  # log scale\n)\n\n\n\n\n\n\n\n\nChange the look of your plot:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"density\")))\n    + geom_histogram(\n        binwidth=0.5,\n        fill=\"green\",  # change the fill colour (one colour)\n        colour=\"pink\",  # change the outline\n        size=2,  # change the thickness of the outline\n        alpha=0.7,  # change the transparency\n    )\n    + theme_xkcd()  # play with themes (look/arrangement)\n)\n\n\n\n\n\n\n\n\nAnother change, this time changing the fill colours manually:\n\n(\n    ggplot(\n        diamonds,\n        aes(\n            x=\"carat\",\n            y=after_stat(\"density\"),\n            fill=\"cut\",  # change the fill colour using another variable\n        ),\n    )\n    + scale_fill_manual(\n        values=[\"#000000\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\"]\n    )  # change the fill colour\n    + geom_histogram(\n        binwidth=0.5,\n        colour=\"#D55E00\",  # change the outline\n        size=1,  # change the thickness of the outline\n        alpha=0.7,  # change the transparency\n    )\n    + theme_bw()  # play with themes (look/arrangement)\n)\n\n\n\n\n\n\n\n\nWhen faceting histograms with scaled counts/densities, they are normalised by each facet, and not overall. Here’s an example of a facet wrap:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"ncount\")))\n    + geom_histogram(binwidth=0.5)\n    + facet_wrap(\"color\")  # facet wrap\n)\n\n\n\n\n\n\n\n\nHere’s an example of a facet grid with the count normalised in each grid:\n\n(\n    ggplot(diamonds, aes(x=\"carat\", y=after_stat(\"ncount\")))\n    + geom_histogram(binwidth=0.5)\n    + facet_grid(\"cut\", \"color\")\n)"
  },
  {
    "objectID": "reference/geom_jitter.html",
    "href": "reference/geom_jitter.html",
    "title": " plotnine.geom_jitter",
    "section": "",
    "text": "geom_jitter(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"jitter\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    width=None,\n    height=None,\n    random_state=None,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_jitter.html#parameters",
    "href": "reference/geom_jitter.html#parameters",
    "title": " plotnine.geom_jitter",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\nfill\nNone\n\n\ngroup\n\n\n\nshape\n'o'\n\n\nsize\n1.5\n\n\nstroke\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"jitter\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nwidth : float = None\n\nProportion to jitter in horizontal direction. The default value is that from position_jitter\n\nheight : float = None\n\nProportion to jitter in vertical direction. The default value is that from position_jitter.\n\nrandom_state : int | RandomState = None\n\nSeed or Random number generator to use. If None, then numpy global generator numpy.random is used.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_jitter.html#see-also",
    "href": "reference/geom_jitter.html#see-also",
    "title": " plotnine.geom_jitter",
    "section": "See Also",
    "text": "See Also\n\nposition_jitter\n\n\n\ngeom_point"
  },
  {
    "objectID": "reference/geom_line.html",
    "href": "reference/geom_line.html",
    "title": " plotnine.geom_line",
    "section": "",
    "text": "geom_line(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    lineend=\"butt\",\n    linejoin=\"round\",\n    arrow=None,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_line.html#parameters",
    "href": "reference/geom_line.html#parameters",
    "title": " plotnine.geom_line",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_line.html#see-also",
    "href": "reference/geom_line.html#see-also",
    "title": " plotnine.geom_line",
    "section": "See Also",
    "text": "See Also\n\ngeom_path\n\nFor documentation of other parameters."
  },
  {
    "objectID": "reference/geom_line.html#examples",
    "href": "reference/geom_line.html#examples",
    "title": " plotnine.geom_line",
    "section": "Examples",
    "text": "Examples\n\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_line,\n    facet_wrap,\n    labs,\n    scale_x_datetime,\n    element_text,\n    theme_538\n)\nfrom plotnine.data import meat\n\n\nLine plots\ngeom_line() connects the dots, and is useful for time series data.\n\nmeat.head()\n\n\n\n\n\n\n\n\ndate\nbeef\nveal\npork\nlamb_and_mutton\nbroilers\nother_chicken\nturkey\n\n\n\n\n0\n1944-01-01\n751.0\n85.0\n1280.0\n89.0\nNaN\nNaN\nNaN\n\n\n1\n1944-02-01\n713.0\n77.0\n1169.0\n72.0\nNaN\nNaN\nNaN\n\n\n2\n1944-03-01\n741.0\n90.0\n1128.0\n75.0\nNaN\nNaN\nNaN\n\n\n3\n1944-04-01\n650.0\n89.0\n978.0\n66.0\nNaN\nNaN\nNaN\n\n\n4\n1944-05-01\n681.0\n106.0\n1029.0\n78.0\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\nMake it tidy.\n\nmeat_long = meat.melt(\n    id_vars=\"date\",\n    value_vars=[\"beef\", \"veal\", \"pork\", \"lamb_and_mutton\", \"broilers\", \"turkey\"],\n    var_name=\"animal\",\n    value_name=\"weight\"\n).dropna()\n\nmeat_long.head()\n\n\n\n\n\n\n\n\ndate\nanimal\nweight\n\n\n\n\n0\n1944-01-01\nbeef\n751.0\n\n\n1\n1944-02-01\nbeef\n713.0\n\n\n2\n1944-03-01\nbeef\n741.0\n\n\n3\n1944-04-01\nbeef\n650.0\n\n\n4\n1944-05-01\nbeef\n681.0\n\n\n\n\n\n\n\nFirst try\n\np = (\n    ggplot(meat_long, aes(x=\"date\", y=\"weight\"))\n    + geom_line()\n)\np\n\n\n\n\n\n\n\n\nIt looks crowded because each there is more than one monthly entry at each x-point. We can get a single trend line by getting a monthly aggregate of the weights.\n\nmeat_long_monthly_agg = meat_long.groupby(\"date\").agg({\"weight\": \"sum\"}).reset_index()\nmeat_long_monthly_agg\n\n\n\n\n\n\n\n\ndate\nweight\n\n\n\n\n0\n1944-01-01\n2205.0\n\n\n1\n1944-02-01\n2031.0\n\n\n2\n1944-03-01\n2034.0\n\n\n3\n1944-04-01\n1783.0\n\n\n4\n1944-05-01\n1894.0\n\n\n...\n...\n...\n\n\n955\n2023-08-01\n9319.1\n\n\n956\n2023-09-01\n8586.1\n\n\n957\n2023-10-01\n9452.5\n\n\n958\n2023-11-01\n8951.1\n\n\n959\n2023-12-01\n8555.1\n\n\n\n\n960 rows × 2 columns\n\n\n\n\n\nA Single Trend Line\n\n(\n    ggplot(meat_long_monthly_agg, aes(x=\"date\", y=\"weight\"))\n    + geom_line()\n)\n\n\n\n\n\n\n\n\nAdd some style\n\n# Gallery, lines\n(\n    ggplot(meat_long_monthly_agg, aes(x=\"date\", y=\"weight\"))\n    + geom_line()\n    # Styling\n    + scale_x_datetime(date_breaks=\"10 years\", date_labels=\"%Y\")\n    + theme_538()\n)\n\n\n\n\n\n\n\n\nOr we can group by the animals to get a trend line for each animal\n\n\nMultiple Trend Lines\n\n(\n    ggplot(meat_long, aes(x=\"date\", y=\"weight\", group=\"animal\"))\n    + geom_line()\n    # Styling\n    + scale_x_datetime(date_breaks=\"10 years\", date_labels=\"%Y\")\n    + theme_538()\n)\n\n\n\n\n\n\n\n\nMake each group be a different color.\n\n# Gallery, lines\n(\n    ggplot(meat_long, aes(x=\"date\", y=\"weight\", color=\"animal\"))\n    + geom_line()\n    # Styling\n    + scale_x_datetime(date_breaks=\"10 years\", date_labels=\"%Y\")\n    + theme_538()\n)\n\n\n\n\n\n\n\n\n\n\nA Trend Line Per Facet\nPlot each group on a separate panel. The legend is no longer required and we adjust to the smaller panels by reducing the size of the line, size of the text and the number of grid lines.\n\n# Gallery, lines\ndef titled(strip_title):\n    return \" \".join(s.title() if s != \"and\" else s for s in strip_title.split(\"_\"))\n\n(\n    ggplot(meat_long, aes(\"date\", \"weight\", color=\"animal\"))\n    + geom_line(size=.5, show_legend=False)\n    + facet_wrap(\"animal\", labeller=titled)\n    + scale_x_datetime(date_breaks=\"20 years\", date_labels=\"%Y\")\n    + labs(\n        x=\"Date\",\n        y=\"Weight (million pounds)\",\n        title=\"Meat Production\"\n    )\n    + theme_538(base_size=9)\n)\n\n\n\n\n\n\n\n\n\nSource: Line plots"
  },
  {
    "objectID": "reference/geom_map.html",
    "href": "reference/geom_map.html",
    "title": " plotnine.geom_map",
    "section": "",
    "text": "geom_map(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_map.html#parameters",
    "href": "reference/geom_map.html#parameters",
    "title": " plotnine.geom_map",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\ngeometry\n\n\n\nalpha\n1\n\n\ncolor\n'#111111'\n\n\nfill\n'#333333'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nshape\n'o'\n\n\nsize\n0.5\n\n\nstroke\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_map.html#notes",
    "href": "reference/geom_map.html#notes",
    "title": " plotnine.geom_map",
    "section": "Notes",
    "text": "Notes\nThis geom is best suited for plotting a shapefile read into geopandas dataframe. The dataframe should have a geometry column."
  },
  {
    "objectID": "reference/geom_map.html#examples",
    "href": "reference/geom_map.html#examples",
    "title": " plotnine.geom_map",
    "section": "Examples",
    "text": "Examples\n\n\nimport geopandas as gp\nimport geodatasets\nfrom plotnine import (\n    ggplot,\n    aes,\n    coord_fixed,\n    facet_wrap,\n    geom_map,\n    geom_text,\n    labs,\n    scale_fill_brewer,\n    scale_fill_continuous,\n    scale_x_continuous,\n    scale_y_continuous,\n    scale_size_continuous,\n    stage,\n    coord_cartesian,\n    element_line,\n    element_rect,\n    element_text,\n    theme_void,\n    theme,\n)\n\nDefine some useful functions\n\ndef good_centroid(geometry):\n    \"\"\"\n    Calculate \"good\" centroids for polygons in the geometry\n\n    The polygon is projected onto the Equal Area Cylindrical projection,\n    the centroids are computed, then mapped back onto the original\n    coordinate system.\n    \"\"\"\n    return geometry.to_crs(\"+proj=cea\").centroid.to_crs(geometry.crs)\n\n\ndef overlay_color(rgb_hex_colors, light=\"white\", dark=\"black\", threshold=0.5):\n    \"\"\"\n    Decide which color is suitable to write onto the given colors\n    \"\"\"\n    def luminance(rgb_hex):\n        \"\"\"\n        Calculate the Luminance ([0, 1]) of a hex color\n        \"\"\"\n        r = int(rgb_hex[1:3], 16)\n        g = int(rgb_hex[3:5], 16)\n        b = int(rgb_hex[5:], 16)\n        luma = (r*0.299 + g*0.587 + b*0.0722) / 256\n        return luma\n    return [light if luminance(x) &lt; threshold  else dark for x in rgb_hex_colors]\n\n\nA Map from geodatasets\nWe are going to use a dataset from the geodatasets package. We can explore the dataset providers at geodatasets.data, each of which has one or more datasets:\nWe choose the dataset of Sudden Infant Death (SIDS) counts from counties in North Carolina. We can see some meta information about that dataset. You can view the details with geodatasets.data.geoda.sids.\nDownload the dataset we want (it is automatically cached).\n\ngeodatasets.fetch(\"geoda sids\")\n\nRead data\n\nsids = gp.read_file(geodatasets.get_path(\"geoda.sids\"))\nsids.head()\n\n\n\n\n\n\n\n\nAREA\nPERIMETER\nCNTY_\nCNTY_ID\nNAME\nFIPS\nFIPSNO\nCRESS_ID\nBIR74\nSID74\nNWBIR74\nBIR79\nSID79\nNWBIR79\ngeometry\n\n\n\n\n0\n0.114\n1.442\n1825\n1825\nAshe\n37009\n37009\n5\n1091.0\n1.0\n10.0\n1364.0\n0.0\n19.0\nPOLYGON ((-81.47276 36.23436, -81.54084 36.272...\n\n\n1\n0.061\n1.231\n1827\n1827\nAlleghany\n37005\n37005\n3\n487.0\n0.0\n10.0\n542.0\n3.0\n12.0\nPOLYGON ((-81.23989 36.36536, -81.24069 36.379...\n\n\n2\n0.143\n1.630\n1828\n1828\nSurry\n37171\n37171\n86\n3188.0\n5.0\n208.0\n3616.0\n6.0\n260.0\nPOLYGON ((-80.45634 36.24256, -80.47639 36.254...\n\n\n3\n0.070\n2.968\n1831\n1831\nCurrituck\n37053\n37053\n27\n508.0\n1.0\n123.0\n830.0\n2.0\n145.0\nMULTIPOLYGON (((-76.00897 36.3196, -76.01735 3...\n\n\n4\n0.153\n2.206\n1832\n1832\nNorthampton\n37131\n37131\n66\n1421.0\n9.0\n1066.0\n1606.0\n3.0\n1197.0\nPOLYGON ((-77.21767 36.24098, -77.23461 36.214...\n\n\n\n\n\n\n\nThe sids data has two periods 1974 - 1978 and 1979 - 1985. For each period there is a number of births and a number of deaths. We want to visually compare the deaths per 1000 in each county for the two periods.\n\ndata = sids.copy()\n\n# Calculate the death per 1000\ndata[\"1974 - 1978\"] = (data[\"SID74\"] / data[\"BIR74\"]) * 1000\ndata[\"1979 - 1984\"] = (data[\"SID79\"] / data[\"BIR79\"]) * 1000\n\n# Calculate center coordinates for the counties\ndata[\"center_lon\"] = good_centroid(data.geometry).x\ndata[\"center_lat\"] = good_centroid(data.geometry).y\n\n# Make the data\ndata = data.melt(\n    id_vars=[\"NAME\", \"geometry\", \"center_lon\", \"center_lat\"],\n    value_vars=[\"1974 - 1978\", \"1979 - 1984\"],\n    var_name=\"period\",\n    value_name=\"deaths_per_1k\",\n).rename(\n    {\"NAME\": \"county\"},\n    axis=1\n)\n\ndata.head()\n\n\n\n\n\n\n\n\ncounty\ngeometry\ncenter_lon\ncenter_lat\nperiod\ndeaths_per_1k\n\n\n\n\n0\nAshe\nPOLYGON ((-81.47276 36.23436, -81.54084 36.272...\n-81.498245\n36.431263\n1974 - 1978\n0.916590\n\n\n1\nAlleghany\nPOLYGON ((-81.23989 36.36536, -81.24069 36.379...\n-81.125138\n36.490963\n1974 - 1978\n0.000000\n\n\n2\nSurry\nPOLYGON ((-80.45634 36.24256, -80.47639 36.254...\n-80.685736\n36.412381\n1974 - 1978\n1.568381\n\n\n3\nCurrituck\nMULTIPOLYGON (((-76.00897 36.3196, -76.01735 3...\n-76.027392\n36.407026\n1974 - 1978\n1.968504\n\n\n4\nNorthampton\nPOLYGON ((-77.21767 36.24098, -77.23461 36.214...\n-77.410484\n36.422110\n1974 - 1978\n6.333568\n\n\n\n\n\n\n\nPlot the data\n\n# Gallery, maps\n\n(\n    ggplot(data)\n    + geom_map(aes(fill=\"deaths_per_1k\"))\n    + geom_text(\n        aes(\n            \"center_lon\",\n            \"center_lat\",\n            label=\"county\",\n            color=stage(\"deaths_per_1k\", after_scale=\"overlay_color(color)\")\n        ),\n        size=6,\n        show_legend=False\n    )\n    + scale_fill_continuous(\n        name=\"Deaths Per 1000\",\n        cmap_name=\"plasma\",\n        breaks=[0, 2.5, 5, 7.5, 10],\n        labels=[\"0\", \"2.5\", \"5\", \"7.5\", \"10\"],\n        limits=[0, 10],\n    )\n    + facet_wrap(\n        \"period\",\n        ncol=1,\n        labeller=lambda s: f\"Sudden Infant Deaths in the Period {s}\"\n    )\n    + coord_fixed(expand=False)\n    + theme_void()\n    + theme(\n        figure_size=(12, 8),\n        legend_position=(0, 0),\n        legend_direction=\"horizontal\",\n        legend_title_position=\"top\",\n        plot_margin=0.01,\n        plot_background=element_rect(fill=\"white\"),\n        panel_spacing=0.025,\n        legend_frame=element_rect(color=\"black\"),\n        legend_ticks=element_line(color=\"black\"),\n        strip_text=element_text(size=12),\n    )\n)\n\n\n\n\n\n\n\n\n\n\nThe Territories of Westeros\nLayering different features on a Map\nRead data and select features in Westeros only.\n\ncontinents = gp.read_file(\"data/lands-of-ice-and-fire/continents.shp\")\nislands = gp.read_file(\"data/lands-of-ice-and-fire/islands.shp\")\nlakes = gp.read_file(\"data/lands-of-ice-and-fire/lakes.shp\")\nrivers = gp.read_file(\"data/lands-of-ice-and-fire/rivers.shp\")\npolitical = gp.read_file(\"data/lands-of-ice-and-fire/political.shp\")\nwall = gp.read_file(\"data/lands-of-ice-and-fire/wall.shp\")\nroads = gp.read_file(\"data/lands-of-ice-and-fire/roads.shp\")\nlocations = gp.read_file(\"data/lands-of-ice-and-fire/locations.shp\")\n\nwesteros = continents.query('name==\"Westeros\"')\nislands = islands.query('continent==\"Westeros\" and name!=\"Summer Islands\"')\nlakes = lakes.query('continent==\"Westeros\"')\nrivers = rivers.query('continent==\"Westeros\"')\nroads = roads.query('continent==\"Westeros\"')\n\nwg = westeros.geometry[0]\nbool_idx = [wg.contains(g) for g in locations.geometry]\nwesteros_locations = locations[bool_idx]\ncities = westeros_locations[westeros_locations[\"type\"] == \"City\"].copy()\n\nCreate map by placing the features in layers in an order that limits obstraction.\nThe GeoDataFrame.geometry.centroid property has the center coordinates of polygons, we use these to place the labels of the political regions.\n\n# Gallery, maps\n\n# colors\nwater_color = \"#a3ccff\"\nwall_color = \"white\"\nroad_color = \"brown\"\n\n\n# Create label text by merging the territory name and\n# the claimant to the territory\ndef fmt_labels(names, claimants):\n    labels = []\n    for name, claimant in zip(names, claimants):\n        if name:\n            labels.append(\"{} ({})\".format(name, claimant))\n        else:\n            labels.append(\"({})\".format(claimant))\n    return labels\n\n\ndef calculate_center(df):\n    \"\"\"\n    Calculate the centre of a geometry\n\n    This method first converts to a planar crs, gets the centroid\n    then converts back to the original crs. This gives a more\n    accurate\n    \"\"\"\n    original_crs = df.crs\n    planar_crs = \"EPSG:3857\"\n    return df[\"geometry\"].to_crs(planar_crs).centroid.to_crs(original_crs)\n\n\npolitical[\"center\"] = calculate_center(political)\ncities[\"center\"] = calculate_center(cities)\n\n(\n    ggplot()\n    + geom_map(westeros, fill=None)\n    + geom_map(islands, fill=None)\n    + geom_map(political, aes(fill=\"ClaimedBy\"), color=None, show_legend=False)\n    + geom_map(wall, color=wall_color, size=2)\n    + geom_map(lakes, fill=water_color, color=None)\n    + geom_map(rivers, aes(size=\"size\"), color=water_color, show_legend=False)\n    + geom_map(roads, aes(size=\"size\"), color=road_color, alpha=0.5, show_legend=False)\n    + geom_map(cities, size=1)\n    + geom_text(\n        political,\n        aes(\"center.x\", \"center.y\", label=\"fmt_labels(name, ClaimedBy)\"),\n        size=8,\n        fontweight=\"bold\",\n    )\n    + geom_text(\n        cities,\n        aes(\"center.x\", \"center.y\", label=\"name\"),\n        size=8,\n        ha=\"left\",\n        nudge_x=0.20,\n    )\n    + labs(title=\"The Political Territories of Westeros\")\n    + scale_fill_brewer(type=\"qual\", palette=8)\n    + scale_x_continuous(expand=(0, 0, 0, 1))\n    + scale_y_continuous(expand=(0, 1, 0, 0))\n    + scale_size_continuous(range=(0.4, 1))\n    + coord_cartesian()\n    + theme_void()\n    + theme(figure_size=(8, 12), panel_background=element_rect(fill=water_color))\n)\n\n\n\n\n\n\n\n\nCredit: cadaei of the cartographersguild website forum.\n\nSource: A Map from `geodatasets`"
  },
  {
    "objectID": "reference/geom_point.html",
    "href": "reference/geom_point.html",
    "title": " plotnine.geom_point",
    "section": "",
    "text": "geom_point(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_point.html#parameters",
    "href": "reference/geom_point.html#parameters",
    "title": " plotnine.geom_point",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\nfill\nNone\n\n\ngroup\n\n\n\nshape\n'o'\n\n\nsize\n1.5\n\n\nstroke\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_point.html#examples",
    "href": "reference/geom_point.html#examples",
    "title": " plotnine.geom_point",
    "section": "Examples",
    "text": "Examples\n\n\n\nimport numpy as np\nimport pandas as pd\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    theme_matplotlib,\n    theme_set,\n)\n\n# Set default theme for all the plots\ntheme_set(theme_matplotlib())\n\n\nnp.random.seed(123)\nn = 150\n\ndf = pd.DataFrame({\n    \"x\": np.random.randint(0, 101, n),\n    \"y\": np.random.randint(0, 101, n),\n    \"var1\": np.random.randint(1, 6, n),\n    \"var2\": np.random.randint(0, 11, n)\n})\n\n\nBasic Scatter Plot\n\n# Gallery, points\n(\n    ggplot(df, aes(\"x\", \"y\"))\n    + geom_point()\n)\n\n\n\n\n\n\n\n\n\n\nColoured Point Bubbles\n\n(\n    ggplot(df, aes(\"x\", \"y\", size=\"var1\"))\n    + geom_point(aes(color=\"var2\"))\n)\n\n\n\n\n\n\n\n\n\n# Gallery, points\n(\n    ggplot(df, aes(\"x\", \"y\", size=\"var1\"))\n    + geom_point(aes(fill=\"var2\"), stroke=0, alpha=0.5)\n    + geom_point(aes(color=\"var2\"), fill=\"none\")\n)\n\n\n\n\n\n\n\n\n\nSource: Set default theme for all the plots"
  },
  {
    "objectID": "reference/geom_pointrange.html",
    "href": "reference/geom_pointrange.html",
    "title": " plotnine.geom_pointrange",
    "section": "",
    "text": "geom_pointrange(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    fatten=4,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_pointrange.html#parameters",
    "href": "reference/geom_pointrange.html#parameters",
    "title": " plotnine.geom_pointrange",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nymax\n\n\n\nymin\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\nfill\nNone\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nshape\n'o'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nfatten : float = 2\n\nA multiplicative factor used to increase the size of the point along the line-range.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_qq.html",
    "href": "reference/geom_qq.html",
    "title": " plotnine.geom_qq",
    "section": "",
    "text": "geom_qq(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"qq\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_qq.html#parameters",
    "href": "reference/geom_qq.html#parameters",
    "title": " plotnine.geom_qq",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\nfill\nNone\n\n\ngroup\n\n\n\nshape\n'o'\n\n\nsize\n1.5\n\n\nstroke\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"qq\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_quantile.html",
    "href": "reference/geom_quantile.html",
    "title": " plotnine.geom_quantile",
    "section": "",
    "text": "geom_quantile(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"quantile\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    lineend=\"butt\",\n    linejoin=\"round\",\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_quantile.html#parameters",
    "href": "reference/geom_quantile.html#parameters",
    "title": " plotnine.geom_quantile",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\n'#3366FF'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"quantile\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nlineend : Literal[butt, round, projecting] = \"butt\"\n\nLine end style. This option is applied for solid linetypes.\n\nlinejoin : Literal[round, miter, bevel] = \"round\"\n\nLine join style. This option is applied for solid linetypes.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_rect.html",
    "href": "reference/geom_rect.html",
    "title": " plotnine.geom_rect",
    "section": "",
    "text": "geom_rect(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_rect.html#parameters",
    "href": "reference/geom_rect.html#parameters",
    "title": " plotnine.geom_rect",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nxmax\n\n\n\nxmin\n\n\n\nymax\n\n\n\nymin\n\n\n\nalpha\n1\n\n\ncolor\nNone\n\n\nfill\n'#595959'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_rug.html",
    "href": "reference/geom_rug.html",
    "title": " plotnine.geom_rug",
    "section": "",
    "text": "geom_rug(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    sides=\"bl\",\n    length=0.03,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_rug.html#parameters",
    "href": "reference/geom_rug.html#parameters",
    "title": " plotnine.geom_rug",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nsides : str = \"bl\"\n\nSides onto which to draw the marks. Any combination chosen from the characters \"btlr\", for bottom, top, left or right side marks.\n\nlength\n\nlength of marks in fractions of horizontal/vertical panel size.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_sina.html",
    "href": "reference/geom_sina.html",
    "title": " plotnine.geom_sina",
    "section": "",
    "text": "geom_sina(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"sina\",\n    position=\"dodge\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_sina.html#parameters",
    "href": "reference/geom_sina.html#parameters",
    "title": " plotnine.geom_sina",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\nfill\nNone\n\n\ngroup\n\n\n\nshape\n'o'\n\n\nsize\n1.5\n\n\nstroke\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"sina\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"dodge\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_sina.html#see-also",
    "href": "reference/geom_sina.html#see-also",
    "title": " plotnine.geom_sina",
    "section": "See Also",
    "text": "See Also\n\nstat_sina"
  },
  {
    "objectID": "reference/geom_sina.html#references",
    "href": "reference/geom_sina.html#references",
    "title": " plotnine.geom_sina",
    "section": "References",
    "text": "References\nSidiropoulos, N., S. H. Sohi, T. L. Pedersen, B. T. Porse, O. Winther, N. Rapin, and F. O. Bagger. 2018. “SinaPlot: An Enhanced Chart for Simple and Truthful Representation of Single Observations over Multiple Classes.” J. Comp. Graph. Stat 27: 673–76."
  },
  {
    "objectID": "reference/geom_spoke.html",
    "href": "reference/geom_spoke.html",
    "title": " plotnine.geom_spoke",
    "section": "",
    "text": "geom_spoke(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    lineend=\"butt\",\n    arrow=None,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_spoke.html#parameters",
    "href": "reference/geom_spoke.html#parameters",
    "title": " plotnine.geom_spoke",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nangle\n\n\n\nradius\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\n'black'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_spoke.html#see-also",
    "href": "reference/geom_spoke.html#see-also",
    "title": " plotnine.geom_spoke",
    "section": "See Also",
    "text": "See Also\n\ngeom_segment\n\nFor documentation of extra parameters."
  },
  {
    "objectID": "reference/geom_text.html",
    "href": "reference/geom_text.html",
    "title": " plotnine.geom_text",
    "section": "",
    "text": "geom_text(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"identity\",\n    position=\"identity\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    parse=False,\n    nudge_x=0,\n    nudge_y=0,\n    adjust_text=None,\n    format_string=None,\n    path_effects=None,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_text.html#parameters",
    "href": "reference/geom_text.html#parameters",
    "title": " plotnine.geom_text",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nlabel\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\nangle\n0\n\n\ncolor\n'black'\n\n\nfamily\nNone\n\n\nfontstyle\n'normal'\n\n\nfontvariant\nNone\n\n\nfontweight\n'normal'\n\n\ngroup\n\n\n\nha\n'center'\n\n\nlineheight\n1.2\n\n\nsize\n11\n\n\nva\n'center'\n\n\n\nThe bold aesthetics are required.\nAesthetics Descriptions\n\nsize\n\nFloat or one of:\n{\n    \"xx-small\", \"x-small\", \"small\", \"medium\", \"large\",\n    \"x-large\", \"xx-large\"\n}\n\nha\n\nHorizontal alignment. One of {\"left\", \"center\", \"right\"}.\n\nva\n\nVertical alignment. One of {\"top\", \"center\", \"bottom\", \"baseline\", \"center_baseline\"}.\n\nfamily\n\nFont family. Can be a font name e.g. “Arial”, “Helvetica”, “Times”, … or a family that is one of {\"serif\", \"sans-serif\", \"cursive\", \"fantasy\", \"monospace\"}}\n\nfontweight\n\nFont weight. A numeric value in range 0-1000 or a string that is one of:\n{\n    \"ultralight\", \"light\", \"normal\", \"regular\", \"book\", \"medium\",\n    \"roman\", \"semibold\", \"demibold\", \"demi\", \"bold\", \"heavy\",\n    \"extra bold\", \"black\"\n}\n\nfontstyle\n\nFont style. One of {\"normal\", \"italic\", \"oblique\"}.\n\nfontvariant\n\nFont variant. One of {\"normal\", \"small-caps\"}.\n\n\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"identity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\nparse : bool = False\n\nIf True, the labels will be rendered with latex.\n\nnudge_x : float = 0\n\nHorizontal adjustment to apply to the text\n\nnudge_y : float = 0\n\nVertical adjustment to apply to the text\n\nadjust_text\n\nParameters to adjust_text will repel overlapping texts. This parameter takes priority of over nudge_x and nudge_y. adjust_text does not work well when it is used in the first layer of the plot, or if it is the only layer. For more see the documentation at https://github.com/Phlya/adjustText/wiki .\n\nformat_string : str = None\n\nIf not None, then the text is formatted with this string using str.format e.g:\n# 2.348 -&gt; \"2.35%\"\ngeom_text(format_string=\"{:.2f}%\")\n\npath_effects : list = None\n\nIf not None, then the text will use these effects. See  documentation for more details.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_text.html#see-also",
    "href": "reference/geom_text.html#see-also",
    "title": " plotnine.geom_text",
    "section": "See Also",
    "text": "See Also\n\ngeom_label\n\n\n\nText\n\n\n\npatheffects"
  },
  {
    "objectID": "reference/geom_violin.html",
    "href": "reference/geom_violin.html",
    "title": " plotnine.geom_violin",
    "section": "",
    "text": "geom_violin(\n    mapping=None,\n    data=None,\n    *,\n    stat=\"ydensity\",\n    position=\"dodge\",\n    na_rm=False,\n    inherit_aes=True,\n    show_legend=None,\n    raster=False,\n    draw_quantiles=None,\n    style=\"full\",\n    scale=\"area\",\n    trim=True,\n    width=None,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/geom_violin.html#parameters",
    "href": "reference/geom_violin.html#parameters",
    "title": " plotnine.geom_violin",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nalpha\n1\n\n\ncolor\n'#333333'\n\n\nfill\n'white'\n\n\ngroup\n\n\n\nlinetype\n'solid'\n\n\nsize\n0.5\n\n\nweight\n1\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\nstat : str | stat = \"ydensity\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"dodge\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ninherit_aes : bool = True\n\nIf False, overrides the default aesthetics.\n\nshow_legend : bool | dict = None\n\nWhether this layer should be included in the legends. None the default, includes any aesthetics that are mapped. If a bool, False never includes and True always includes. A dict can be used to exclude specific aesthetis of the layer from showing in the legend. e.g show_legend={'color': False}, any other aesthetic are included by default.\n\nraster : bool = False\n\nIf True, draw onto this layer a raster (bitmap) object even ifthe final image is in vector format.\n\ndraw_quantiles : float | list[float] = None\n\ndraw horizontal lines at the given quantiles (0..1) of the density estimate.\n\nstyle : str = \"full\"\n\nThe type of violin plot to draw. The options are:\n'full'        # Regular (2 sided violins)\n'left'        # Left-sided half violins\n'right'       # Right-sided half violins\n'left-right'  # Alternate (left first) half violins by the group\n'right-left'  # Alternate (right first) half violins by the group\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the stat."
  },
  {
    "objectID": "reference/geom_violin.html#examples",
    "href": "reference/geom_violin.html#examples",
    "title": " plotnine.geom_violin",
    "section": "Examples",
    "text": "Examples\n\n\nimport pandas as pd\nimport numpy as np\nimport pandas.api.types as pdtypes\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    stage,\n    geom_violin,\n    geom_point,\n    geom_line,\n    geom_boxplot,\n    guides,\n    scale_fill_manual,\n    theme,\n    theme_classic,\n)\n\n\nViolins, Boxes, Points & Lines\nComparing repeated measurements and their summaries\nSuppose you have two sets of related data and each point in the first set maps onto a point in the second set. e.g. they could represent a transition from one state to another for example two measurements of the height of pupils in different years.\nFor demonstration we shall generate data with a before measurement and an after measurement.\n\nnp.random.seed(123)\nn = 20\nmu = (1, 2.3)\nsigma = (1, 1.6)\n\nbefore = np.random.normal(loc=mu[0], scale=sigma[0], size=n)\nafter = np.random.normal(loc=mu[1], scale=sigma[1], size=n)\n\ndf = pd.DataFrame(\n    {\n        \"value\": np.hstack([before, after]),\n        \"when\": np.repeat([\"before\", \"after\"], n),\n        \"id\": np.hstack([range(n), range(n)]),\n    }\n)\n\ndf[\"when\"] = df[\"when\"].astype(pdtypes.CategoricalDtype(categories=[\"before\", \"after\"]))\ndf.head()\n\n\n\n\n\n\n\n\nvalue\nwhen\nid\n\n\n\n\n0\n-0.085631\nbefore\n0\n\n\n1\n1.997345\nbefore\n1\n\n\n2\n1.282978\nbefore\n2\n\n\n3\n-0.506295\nbefore\n3\n\n\n4\n0.421400\nbefore\n4\n\n\n\n\n\n\n\nA basic violin plot shows distributions of the two sets of data.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(df)\n)\n\n\n\n\n\n\n\n\nAdd the original data in form of points.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(df)\n    + geom_point()\n)\n\n\n\n\n\n\n\n\nThe violins are symmetrical about the vertical axis and half a violin has the same information as the full violin. We cut (style) the violins in half and choose to alternate with the left half for the first one and the right half for the second.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(df, style=\"left-right\")  # changed\n    + geom_point()\n)\n\n\n\n\n\n\n\n\nLink up the points to get a sense of how the data the moves.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(df, style=\"left-right\")  # changed\n    + geom_point()\n    + geom_line(aes(group=\"id\"))  # new\n)\n\n\n\n\n\n\n\n\nMake gap between the points and the violions. i.e. shift the violins outward and the points & lines inward. We used stage mapping to get it done. For example\nx=stage('when', after_scale='x+shift*alt_sign(x)')\nsays, map the xaesthetic to the ‘when’ column/variable and after the scale computed the x locations add a shift to them. The calculated x locations of a discrete scale are consecutive numbers 1, 2, 3, ..., so we use that move objects of adjacent groups in opposite directions i.e $(-1)^1, (-1)^2, (-1)^3 … = -1, 1, -1… $\n\n# How much to shift the violin, points and lines\n# 0.1 is 10% of the allocated space for the category\nshift = 0.1\n\n\ndef alt_sign(x):\n    \"Alternate +1/-1 if x is even/odd\"\n    return (-1) ** x\n\n\nm1 = aes(x=stage(\"when\", after_scale=\"x+shift*alt_sign(x)\"))  # shift outward\nm2 = aes(x=stage(\"when\", after_scale=\"x-shift*alt_sign(x)\"), group=\"id\")  # shift inward\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(m1, style=\"left-right\")  # changed\n    + geom_point(m2)  # changed\n    + geom_line(m2)  # changed\n)\n\n\n\n\n\n\n\n\nAdd a boxplot in the gap. The space between the flat edge of the violin and the center of the points is 2 * shift, so we can use the shift to control the width of the boxplot.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(m1, style=\"left-right\")\n    + geom_point(m2)\n    + geom_line(m2)\n    + geom_boxplot(width=shift)\n)\n\n\n\n\n\n\n\n\nFinall, style it up.\n\n# Gallery, distributions\n\nlsize = 0.65\nfill_alpha = 0.7\n\n(\n    ggplot(df, aes(\"when\", \"value\", fill=\"when\"))\n    + geom_violin(m1, style=\"left-right\", alpha=fill_alpha, size=lsize)\n    + geom_point(m2, color=\"none\", alpha=fill_alpha, size=2)\n    + geom_line(m2, color=\"gray\", size=lsize, alpha=0.6)\n    + geom_boxplot(width=shift, alpha=fill_alpha, size=lsize)\n    + scale_fill_manual(values=[\"dodgerblue\", \"darkorange\"])\n    + guides(fill=False)  # Turn off the fill legend\n    + theme_classic()\n    + theme(figure_size=(8, 6))\n)\n\n\n\n\n\n\n\n\nCredit: This is example is motivated by the work of Jordy van Langen (@jorvlan) at https://github.com/jorvlan/open-visualizations.\n\nSource: Violins, Boxes, Points & Lines"
  },
  {
    "objectID": "reference/get_aesthetic_limits.html",
    "href": "reference/get_aesthetic_limits.html",
    "title": " plotnine.helpers.get_aesthetic_limits",
    "section": "",
    "text": "get_aesthetic_limits(plot, ae)"
  },
  {
    "objectID": "reference/get_aesthetic_limits.html#parameters",
    "href": "reference/get_aesthetic_limits.html#parameters",
    "title": " plotnine.helpers.get_aesthetic_limits",
    "section": "Parameters",
    "text": "Parameters\n\n\nplot : ggplot\n\nggplot object\n\nae : str\n\nName of aesthetic"
  },
  {
    "objectID": "reference/get_aesthetic_limits.html#returns",
    "href": "reference/get_aesthetic_limits.html#returns",
    "title": " plotnine.helpers.get_aesthetic_limits",
    "section": "Returns",
    "text": "Returns\n\n\nout : tuple[float, float] | Sequence[str] | list[tuple[float]] | list[Sequence[str]]\n\nThe limits of the aesthetic. If the plot is facetted, (has many panels), it is a sequence of limits, one for each panel."
  },
  {
    "objectID": "reference/ggplot.html",
    "href": "reference/ggplot.html",
    "title": " plotnine.ggplot",
    "section": "",
    "text": "ggplot(data=None, mapping=None)"
  },
  {
    "objectID": "reference/ggplot.html#parameters",
    "href": "reference/ggplot.html#parameters",
    "title": " plotnine.ggplot",
    "section": "Parameters",
    "text": "Parameters\n\n\ndata : Optional[DataLike] = None\n\nDefault data for plot. Every layer that does not have data of its own will use this one.\n\nmapping : Optional[aes] = None\n\nDefault aesthetics mapping for the plot. These will be used by all layers unless specifically overridden."
  },
  {
    "objectID": "reference/ggplot.html#notes",
    "href": "reference/ggplot.html#notes",
    "title": " plotnine.ggplot",
    "section": "Notes",
    "text": "Notes\nggplot object only have partial support for pickling. The mappings used by pickled objects should not reference variables in the namespace."
  },
  {
    "objectID": "reference/ggplot.html#methods",
    "href": "reference/ggplot.html#methods",
    "title": " plotnine.ggplot",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\n__add__\nAdd to ggplot\n\n\n__iadd__\nAdd other to ggplot object\n\n\nshow\nShow plot using the matplotlib backend set by the user\n\n\ndraw\nRender the complete plot\n\n\nsave\nSave a ggplot object as an image file\n\n\nsave_helper\nCreate MPL figure that will be saved\n\n\n\n\n __add__\n\n__add__(rhs)\n\n\nAdd to ggplot\n\n\nParameters\n\n\nother\n\nEither an object that knows how to “radd” itself to a ggplot, or a list of such objects.\n\n\n\n\n\n\n __iadd__\n\n__iadd__(other)\n\n\nAdd other to ggplot object\n\n\nParameters\n\n\nother : PlotAddable | list[PlotAddable] | None\n\nEither an object that knows how to “radd” itself to a ggplot, or a list of such objects.\n\n\n\n\n\n\n show\n\nshow()\n\n\nShow plot using the matplotlib backend set by the user\nUsers should prefer this method instead of printing or repring the object.\n\n\n\n draw\n\ndraw(*, show=False)\n\n\nRender the complete plot\n\n\nParameters\n\n\nshow : bool = False\n\nWhether to show the plot.\n\n\n\n\n\nReturns\n\n\nFigure\n\nMatplotlib figure\n\n\n\n\n\n\n save\n\nsave(\n    filename=None,\n    format=None,\n    path=\"\",\n    width=None,\n    height=None,\n    units=\"in\",\n    dpi=None,\n    limitsize=None,\n    verbose=True,\n    kwargs={}\n)\n\n\nSave a ggplot object as an image file\n\n\nParameters\n\n\nfilename : Optional[str | Path | BytesIO] = None\n\nFile name to write the plot to. If not specified, a name like “plotnine-save-.” is used.\n\nformat : Optional[str] = None\n\nImage format to use, automatically extract from file name extension.\n\npath : str = \"\"\n\nPath to save plot to (if you just want to set path and not filename).\n\nwidth : Optional[float] = None\n\nWidth (defaults to value set by the theme). If specified the height must also be given.\n\nheight : Optional[float] = None\n\nHeight (defaults to value set by the theme). If specified the width must also be given.\n\nunits : str = \"in\"\n\nUnits for width and height when either one is explicitly specified (in, cm, or mm).\n\ndpi : Optional[int] = None\n\nDPI to use for raster graphics. If None, defaults to using the dpi of theme, if none is set then a dpi of 100.\n\nlimitsize : bool | None = None\n\nIf True (the default), save will not save images larger than 25x25 inches, to prevent the common error of specifying dimensions in pixels. The default value is from the option plotine.options.limitsize.\n\nverbose : bool = True\n\nIf True, print the saving information.\n\nkwargs : Any = {}\n\nAdditional arguments to pass to matplotlib savefig().\n\n\n\n\n\n\n save_helper\n\nsave_helper(\n    filename=None,\n    format=None,\n    path=None,\n    width=None,\n    height=None,\n    units=\"in\",\n    dpi=None,\n    limitsize=None,\n    verbose=True,\n    kwargs={}\n)\n\n\nCreate MPL figure that will be saved\n\n\nNotes\nThis method has the same arguments as save. Use it to get access to the figure that will be saved."
  },
  {
    "objectID": "reference/guide.html",
    "href": "reference/guide.html",
    "title": " plotnine.guides.guide.guide",
    "section": "",
    "text": "guide(\n    title=None,\n    theme=Theme(),\n    position=None,\n    direction=None,\n    reverse=False,\n    order=0\n)"
  },
  {
    "objectID": "reference/guide.html#parameter-attributes",
    "href": "reference/guide.html#parameter-attributes",
    "title": " plotnine.guides.guide.guide",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\ntitle: Optional[str] = None\n\nTitle of the guide. Default is the name of the aesthetic or the name specified using lab\n\ntheme: Theme = field(default_factory=Theme)\n\nA theme to style the guide. If None, the plots theme is used.\n\nposition: Optional[LegendPosition] = None\n\nWhere to place the guide relative to the panels.\n\ndirection: Optional[Orientation] = None\n\nDirection of the guide. The default is depends on legend_position.\n\nreverse: bool = False\n\nWhether to reverse the order of the legend keys.\n\norder: int = 0\n\nOrder of this guide among multiple guides."
  },
  {
    "objectID": "reference/guide.html#notes",
    "href": "reference/guide.html#notes",
    "title": " plotnine.guides.guide.guide",
    "section": "Notes",
    "text": "Notes\nAt the moment not all parameters have been fully implemented."
  },
  {
    "objectID": "reference/guide.html#methods",
    "href": "reference/guide.html#methods",
    "title": " plotnine.guides.guide.guide",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncreate_geoms\nCreate layers of geoms for the guide\n\n\ndraw\nDraw guide\n\n\nlegend_aesthetics\nReturn the aesthetics that contribute to the legend\n\n\nsetup\nSetup guide for drawing process\n\n\ntrain\nCreate the key for the guide\n\n\n\n\n create_geoms\n\ncreate_geoms()\n\n\nCreate layers of geoms for the guide\n\n\nReturns\n\n\nOptional[Self]\n\nself if geom layers were create or None of no geom layers were created.\n\n\n\n\n\n\n draw\n\ndraw()\n\n\nDraw guide\n\n\n\n legend_aesthetics\n\nlegend_aesthetics(layer)\n\n\nReturn the aesthetics that contribute to the legend\n\n\nParameters\n\n\nlayer : Layer\n\nLayer whose legend is to be drawn\n\n\n\n\n\nReturns\n\n\nmatched : list\n\nList of the names of the aethetics that contribute to the legend.\n\n\n\n\n\n\n setup\n\nsetup(guides)\n\n\nSetup guide for drawing process\n\n\n\n train\n\ntrain(scale, aesthetic=None)\n\n\nCreate the key for the guide\nReturns guide if training is successful"
  },
  {
    "objectID": "reference/guide_legend.html",
    "href": "reference/guide_legend.html",
    "title": " plotnine.guide_legend",
    "section": "",
    "text": "guide_legend(\n    title=None,\n    theme=Theme(),\n    position=None,\n    direction=None,\n    reverse=False,\n    order=0,\n    nrow=None,\n    ncol=None,\n    byrow=False,\n    override_aes=dict()\n)"
  },
  {
    "objectID": "reference/guide_legend.html#parameter-attributes",
    "href": "reference/guide_legend.html#parameter-attributes",
    "title": " plotnine.guide_legend",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\ntitle: Optional[str] = None\n\nTitle of the guide. Default is the name of the aesthetic or the name specified using lab\n\ntheme: Theme = field(default_factory=Theme)\n\nA theme to style the guide. If None, the plots theme is used.\n\nposition: Optional[LegendPosition] = None\n\nWhere to place the guide relative to the panels.\n\ndirection: Optional[Orientation] = None\n\nDirection of the guide. The default is depends on legend_position.\n\nreverse: bool = False\n\nWhether to reverse the order of the legend keys.\n\norder: int = 0\n\nOrder of this guide among multiple guides.\n\nnrow: Optional[int] = None\n\nNumber of rows of legends.\n\nncol: Optional[int] = None\n\nNumber of columns of legends.\n\nbyrow: bool = False\n\nWhether to fill the legend row-wise or column-wise.\n\noverride_aes: dict[str, Any] = field(default_factory=dict)\n\nAesthetic parameters of legend key."
  },
  {
    "objectID": "reference/huron.html",
    "href": "reference/huron.html",
    "title": " plotnine.data.huron",
    "section": "",
    "text": "huron = pd.read_csv(DATA_DIR / \"huron.csv\")"
  },
  {
    "objectID": "reference/huron.html#format",
    "href": "reference/huron.html#format",
    "title": " plotnine.data.huron",
    "section": "Format",
    "text": "Format\n\n\n\nColumn\nDescription\n\n\n\n\nyear\nYear\n\n\nlevel\nWater level\n\n\ndecade\nDecade\n\n\n\nSource**\nBrockwell, P. J. and Davis, R. A. (1991). Time Series and Forecasting Methods. Second edition. Springer, New York. Series A, page 555.\nBrockwell, P. J. and Davis, R. A. (1996). Introduction to Time Series and Forecasting. Springer, New York. Sections 5.1 and 7.6."
  },
  {
    "objectID": "reference/label_both.html",
    "href": "reference/label_both.html",
    "title": " plotnine.label_both",
    "section": "",
    "text": "label_both(label_info, multi_line=True, sep=\": \")"
  },
  {
    "objectID": "reference/label_both.html#parameters",
    "href": "reference/label_both.html#parameters",
    "title": " plotnine.label_both",
    "section": "Parameters",
    "text": "Parameters\n\n\nlabel_info : strip_label_details\n\nLabel information to be modified.\n\nmulti_line : bool = True\n\nWhether to place each variable on a separate line\n\nsep : str = \": \"\n\nSeparation between variable name and value"
  },
  {
    "objectID": "reference/label_both.html#returns",
    "href": "reference/label_both.html#returns",
    "title": " plotnine.label_both",
    "section": "Returns",
    "text": "Returns\n\n\nout : strip_label_details\n\nLabel information"
  },
  {
    "objectID": "reference/label_value.html",
    "href": "reference/label_value.html",
    "title": " plotnine.label_value",
    "section": "",
    "text": "label_value(label_info, multi_line=True)"
  },
  {
    "objectID": "reference/label_value.html#parameters",
    "href": "reference/label_value.html#parameters",
    "title": " plotnine.label_value",
    "section": "Parameters",
    "text": "Parameters\n\n\nlabel_info : strip_label_details\n\nLabel information whose values will be returned\n\nmulti_line : bool = True\n\nWhether to place each variable on a separate line"
  },
  {
    "objectID": "reference/label_value.html#returns",
    "href": "reference/label_value.html#returns",
    "title": " plotnine.label_value",
    "section": "Returns",
    "text": "Returns\n\n\nout : strip_label_details\n\nLabel text strings"
  },
  {
    "objectID": "reference/labs.html",
    "href": "reference/labs.html",
    "title": " plotnine.labs",
    "section": "",
    "text": "labs(\n    x=None,\n    y=None,\n    alpha=None,\n    color=None,\n    colour=None,\n    fill=None,\n    linetype=None,\n    shape=None,\n    size=None,\n    stroke=None,\n    title=None,\n    subtitle=None,\n    caption=None,\n    tag=None\n)"
  },
  {
    "objectID": "reference/labs.html#parameter-attributes",
    "href": "reference/labs.html#parameter-attributes",
    "title": " plotnine.labs",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nx: str | None = None\n\nName of the x-axis.\n\ny: str | None = None\n\nName of the y-axis.\n\nalpha: str | None = None\n\nName of the alpha legend.\n\ncolor: str | None = None\n\nName of the color legend or colorbar.\n\ncolour: str | None = None\n\nName of the colour legend or colourbar.\nThis is an alias of the color parameter. Only use one of the spellings.\n\nfill: str | None = None\n\nName of the fill legend/colourbar.\n\nlinetype: str | None = None\n\nName of the linetype legend.\n\nshape: str | None = None\n\nName of the shape legend.\n\nsize: str | None = None\n\nName of the size legend.\n\nstroke: str | None = None\n\nName of the stroke legend.\n\ntitle: str | None = None\n\nThe title of the plot.\n\nsubtitle: str | None = None\n\nThe subtitle of the plot.\n\ncaption: str | None = None\n\nThe caption at the bottom of the plot.\n\ntag: str | None = None\n\nA plot tag"
  },
  {
    "objectID": "reference/labs.html#examples",
    "href": "reference/labs.html#examples",
    "title": " plotnine.labs",
    "section": "Examples",
    "text": "Examples\n\n\nfrom plotnine import ggplot, aes, labs, geom_point, theme, theme_538, theme_set\nfrom plotnine.data import mtcars\n\ntheme_set(theme_538())\n\n\nText Outside the Panel(s)\n\n# Gallery, labels\n\ncaption = \"\"\"\\\nThis graphic illustrates the inverse relationship between vehicle weight\nand fuel efficiency (MPG). It aims to highlight how heavier vehicles generally\nconsume more fuel, and how the complexity of an engine's cylinder count and\ntransmission system can affect its fuel economy.\n\"\"\"\n\nfrom plotnine import *\n(\n    ggplot(mtcars, aes(\"mpg\", \"wt\", colour=\"factor(cyl)\", size=\"gear\"))\n    + geom_point()\n    + labs(\n        x=\"Miles per Gallon\",\n        y=\"Weight\",\n        colour=\"Cylinders\",\n        size=\"Gears\",\n        title=\"Fuel Efficiency vs. Vehicle Weight\",\n        subtitle =\"Exploring Factors that Affect the Fuel Effeciency of a Car\",\n        caption=caption,\n    )\n\n    + theme(\n        # left justify the caption and have one line of space between it and\n        # the x-axis label\n        plot_caption=element_text(ha=\"left\", margin={\"t\": 1, \"units\": \"lines\"})\n    )\n    \n)\n\n\n\n\n\n\n\n\n\nSource: Text Outside the Panel(s)"
  },
  {
    "objectID": "reference/legend_background.html",
    "href": "reference/legend_background.html",
    "title": " plotnine.themes.themeable.legend_background",
    "section": "",
    "text": "legend_background(theme_element)"
  },
  {
    "objectID": "reference/legend_background.html#parameters",
    "href": "reference/legend_background.html#parameters",
    "title": " plotnine.themes.themeable.legend_background",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_rect"
  },
  {
    "objectID": "reference/legend_box_background.html",
    "href": "reference/legend_box_background.html",
    "title": " plotnine.themes.themeable.legend_box_background",
    "section": "",
    "text": "legend_box_background(theme_element)"
  },
  {
    "objectID": "reference/legend_box_background.html#parameters",
    "href": "reference/legend_box_background.html#parameters",
    "title": " plotnine.themes.themeable.legend_box_background",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_rect"
  },
  {
    "objectID": "reference/legend_box_background.html#notes",
    "href": "reference/legend_box_background.html#notes",
    "title": " plotnine.themes.themeable.legend_box_background",
    "section": "Notes",
    "text": "Notes\nNot Implemented. We would have to place the outermost VPacker/HPacker boxes that hold the individual legends onto an object that has a patch."
  },
  {
    "objectID": "reference/legend_box_margin.html",
    "href": "reference/legend_box_margin.html",
    "title": " plotnine.themes.themeable.legend_box_margin",
    "section": "",
    "text": "legend_box_margin(theme_element)"
  },
  {
    "objectID": "reference/legend_box_margin.html#parameters",
    "href": "reference/legend_box_margin.html#parameters",
    "title": " plotnine.themes.themeable.legend_box_margin",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : int\n\nValue in points."
  },
  {
    "objectID": "reference/legend_direction.html",
    "href": "reference/legend_direction.html",
    "title": " plotnine.themes.themeable.legend_direction",
    "section": "",
    "text": "legend_direction(theme_element)"
  },
  {
    "objectID": "reference/legend_direction.html#parameters",
    "href": "reference/legend_direction.html#parameters",
    "title": " plotnine.themes.themeable.legend_direction",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : Literal[\"vertical\", \"horizontal\"]\n\nVertically or horizontally"
  },
  {
    "objectID": "reference/legend_justification.html",
    "href": "reference/legend_justification.html",
    "title": " plotnine.themes.themeable.legend_justification",
    "section": "",
    "text": "legend_justification(theme_element)"
  },
  {
    "objectID": "reference/legend_justification.html#parameters",
    "href": "reference/legend_justification.html#parameters",
    "title": " plotnine.themes.themeable.legend_justification",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : Literal[\"left\", \"right\", \"center\", \"top\", \"bottom\"] | float | tuple[float, float]\n\nHow to justify the entire group with 1 or more guides."
  },
  {
    "objectID": "reference/legend_justification_inside.html",
    "href": "reference/legend_justification_inside.html",
    "title": " plotnine.themes.themeable.legend_justification_inside",
    "section": "",
    "text": "legend_justification_inside(theme_element)"
  },
  {
    "objectID": "reference/legend_justification_inside.html#parameters",
    "href": "reference/legend_justification_inside.html#parameters",
    "title": " plotnine.themes.themeable.legend_justification_inside",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : Literal[\"left\", \"right\", \"center\", \"top\", \"bottom\"] | float | tuple[float, float]\n\nHow to justify the entire group with 1 or more guides. i.e. What point of the legend box to place at the destination point in the panels area.\nIf a float, it should be in the range [0, 1], and it implies the horizontal part and with the vertical part fixed at 0.5.\nTherefore a float value of 0.8 equivalent to a tuple value of (0.8, 0.5)."
  },
  {
    "objectID": "reference/legend_justification_right.html",
    "href": "reference/legend_justification_right.html",
    "title": " plotnine.themes.themeable.legend_justification_right",
    "section": "",
    "text": "legend_justification_right(theme_element)"
  },
  {
    "objectID": "reference/legend_justification_right.html#parameters",
    "href": "reference/legend_justification_right.html#parameters",
    "title": " plotnine.themes.themeable.legend_justification_right",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : Literal[\"bottom\", \"center\", \"top\"] | float\n\nHow to justify the entire group with 1 or more guides. i.e. How to slide the legend along the right column. If a float, it should be in the range [0, 1], where 0 is \"bottom\" and 1 is \"top\"."
  },
  {
    "objectID": "reference/legend_key.html",
    "href": "reference/legend_key.html",
    "title": " plotnine.themes.themeable.legend_key",
    "section": "",
    "text": "legend_key(theme_element)"
  },
  {
    "objectID": "reference/legend_key.html#parameters",
    "href": "reference/legend_key.html#parameters",
    "title": " plotnine.themes.themeable.legend_key",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_rect"
  },
  {
    "objectID": "reference/legend_key_size.html",
    "href": "reference/legend_key_size.html",
    "title": " plotnine.themes.themeable.legend_key_size",
    "section": "",
    "text": "legend_key_size(theme_element)"
  },
  {
    "objectID": "reference/legend_key_size.html#parameters",
    "href": "reference/legend_key_size.html#parameters",
    "title": " plotnine.themes.themeable.legend_key_size",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nValue in points."
  },
  {
    "objectID": "reference/legend_key_spacing_x.html",
    "href": "reference/legend_key_spacing_x.html",
    "title": " plotnine.themes.themeable.legend_key_spacing_x",
    "section": "",
    "text": "legend_key_spacing_x(theme_element)"
  },
  {
    "objectID": "reference/legend_key_spacing_x.html#parameters",
    "href": "reference/legend_key_spacing_x.html#parameters",
    "title": " plotnine.themes.themeable.legend_key_spacing_x",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : int\n\nSize in points"
  },
  {
    "objectID": "reference/legend_key_width.html",
    "href": "reference/legend_key_width.html",
    "title": " plotnine.themes.themeable.legend_key_width",
    "section": "",
    "text": "legend_key_width(theme_element)"
  },
  {
    "objectID": "reference/legend_key_width.html#parameters",
    "href": "reference/legend_key_width.html#parameters",
    "title": " plotnine.themes.themeable.legend_key_width",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nValue in points"
  },
  {
    "objectID": "reference/legend_position.html",
    "href": "reference/legend_position.html",
    "title": " plotnine.themes.themeable.legend_position",
    "section": "",
    "text": "legend_position(theme_element)"
  },
  {
    "objectID": "reference/legend_position.html#parameters",
    "href": "reference/legend_position.html#parameters",
    "title": " plotnine.themes.themeable.legend_position",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : Literal[\"right\", \"left\", \"top\", \"bottom\", \"inside\"] | tuple[float, float] | Literal[\"none\"]\n\nWhere to put the legend. Along the edge or inside the panels.\nIf “inside”, the default location is legend_position_inside.\nA tuple of values implies “inside” the panels at those exact values, which should be in the range [0, 1] within the panels area.\nA value of \"none\" turns off the legend."
  },
  {
    "objectID": "reference/legend_spacing.html",
    "href": "reference/legend_spacing.html",
    "title": " plotnine.themes.themeable.legend_spacing",
    "section": "",
    "text": "legend_spacing(theme_element)"
  },
  {
    "objectID": "reference/legend_spacing.html#parameters",
    "href": "reference/legend_spacing.html#parameters",
    "title": " plotnine.themes.themeable.legend_spacing",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nValue in points."
  },
  {
    "objectID": "reference/legend_text_colorbar.html",
    "href": "reference/legend_text_colorbar.html",
    "title": " plotnine.themes.themeable.legend_text_colorbar",
    "section": "",
    "text": "legend_text_colorbar(theme_element)"
  },
  {
    "objectID": "reference/legend_text_colorbar.html#parameters",
    "href": "reference/legend_text_colorbar.html#parameters",
    "title": " plotnine.themes.themeable.legend_text_colorbar",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/legend_text_colorbar.html#notes",
    "href": "reference/legend_text_colorbar.html#notes",
    "title": " plotnine.themes.themeable.legend_text_colorbar",
    "section": "Notes",
    "text": "Notes\nHorizontal alignment ha has no effect when the text is to the left or to the right. Likewise vertical alignment va has no effect when the text at the top or the bottom."
  },
  {
    "objectID": "reference/legend_text_position.html",
    "href": "reference/legend_text_position.html",
    "title": " plotnine.themes.themeable.legend_text_position",
    "section": "",
    "text": "legend_text_position(theme_element)"
  },
  {
    "objectID": "reference/legend_text_position.html#parameters",
    "href": "reference/legend_text_position.html#parameters",
    "title": " plotnine.themes.themeable.legend_text_position",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : Literal[\"top\", \"bottom\", \"left\", \"right\"] | None\n\nPosition of the legend key text. The default depends on the position of the legend."
  },
  {
    "objectID": "reference/legend_title.html",
    "href": "reference/legend_title.html",
    "title": " plotnine.themes.themeable.legend_title",
    "section": "",
    "text": "legend_title(theme_element)"
  },
  {
    "objectID": "reference/legend_title.html#parameters",
    "href": "reference/legend_title.html#parameters",
    "title": " plotnine.themes.themeable.legend_title",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/lims.html",
    "href": "reference/lims.html",
    "title": " plotnine.lims",
    "section": "",
    "text": "lims(kwargs={})"
  },
  {
    "objectID": "reference/lims.html#parameters",
    "href": "reference/lims.html#parameters",
    "title": " plotnine.lims",
    "section": "Parameters",
    "text": "Parameters\n\n\nkwargs = {}\n\nAesthetic and the values of the limits. e.g x=(40, 100)"
  },
  {
    "objectID": "reference/lims.html#notes",
    "href": "reference/lims.html#notes",
    "title": " plotnine.lims",
    "section": "Notes",
    "text": "Notes\nIf the 2nd value of limits is less than the first, a reversed scale will be created."
  },
  {
    "objectID": "reference/luv_colours.html",
    "href": "reference/luv_colours.html",
    "title": " plotnine.data.luv_colours",
    "section": "",
    "text": "luv_colours = pd.read_csv(DATA_DIR / \"luv_colours.csv\")"
  },
  {
    "objectID": "reference/luv_colours.html#description",
    "href": "reference/luv_colours.html#description",
    "title": " plotnine.data.luv_colours",
    "section": "Description",
    "text": "Description\nNamed colors translated into Luv colour space."
  },
  {
    "objectID": "reference/luv_colours.html#format",
    "href": "reference/luv_colours.html#format",
    "title": " plotnine.data.luv_colours",
    "section": "Format",
    "text": "Format\nA data frame with 657 observations and 4 variables:\n\n\n\nColumn\nDescription\n\n\n\n\nL\nL position in Luv colour space\n\n\nu\nu position in Luv colour space\n\n\nv\nv position in Luv colour space\n\n\ncol\nColour name"
  },
  {
    "objectID": "reference/midwest.html",
    "href": "reference/midwest.html",
    "title": " plotnine.data.midwest",
    "section": "",
    "text": "midwest = pd.read_csv(DATA_DIR / \"midwest.csv\")"
  },
  {
    "objectID": "reference/midwest.html#description",
    "href": "reference/midwest.html#description",
    "title": " plotnine.data.midwest",
    "section": "Description",
    "text": "Description\nDemographic information of midwest counties"
  },
  {
    "objectID": "reference/midwest.html#format",
    "href": "reference/midwest.html#format",
    "title": " plotnine.data.midwest",
    "section": "Format",
    "text": "Format\nA data frame with 437 rows and 28 variables\n\n\n\nColumn\nDescription\n\n\n\n\nPID\n\n\n\ncounty\n\n\n\nstate\n\n\n\narea\n\n\n\npoptotal\nTotal population\n\n\npopdensity\nPopulation density\n\n\npopwhite\nNumber of whites\n\n\npopblack\nNumber of blacks\n\n\npopamerindian\nNumber of American Indians\n\n\npopasian\nNumber of Asians\n\n\npopother\nNumber of other races\n\n\npercwhite\nPercent white\n\n\npercblack\nPercent black\n\n\npercamerindan\nPercent American Indian\n\n\npercasian\nPercent Asian\n\n\npercother\nPercent other races\n\n\npopadults\nNumber of adults\n\n\nperchsd\n\n\n\npercollege\nPercent college educated\n\n\npercprof\nPercent profession\n\n\npoppovertyknown\n\n\n\npercpovertyknown\n\n\n\npercbelowpoverty\n\n\n\npercchildbelowpovert\n\n\n\npercadultpoverty\n\n\n\npercelderlypoverty\n\n\n\ninmetro\nIn a metro area\n\n\ncategory"
  },
  {
    "objectID": "reference/msleep.html",
    "href": "reference/msleep.html",
    "title": " plotnine.data.msleep",
    "section": "",
    "text": "msleep = pd.read_csv(DATA_DIR / \"msleep.csv\")"
  },
  {
    "objectID": "reference/msleep.html#description",
    "href": "reference/msleep.html#description",
    "title": " plotnine.data.msleep",
    "section": "Description",
    "text": "Description\nThis is an updated and expanded version of the mammals sleep dataset. Updated sleep times and weights were taken from V. M. Savage and G. B. West. A quantitative, theoretical framework for understanding mammalian sleep. Proceedings of the National Academy of Sciences, 104 (3):1051-1056, 2007."
  },
  {
    "objectID": "reference/msleep.html#format",
    "href": "reference/msleep.html#format",
    "title": " plotnine.data.msleep",
    "section": "Format",
    "text": "Format\nA data frame with 83 rows and 11 variables\n\n\n\nColumn\nDescription\n\n\n\n\nname genus\ncommon name\n\n\nvore order\ncarnivore, omnivore or herbivore?\n\n\nconservation\nthe conservation status of the animal\n\n\nsleep_total\ntotal amount of sleep, in hours\n\n\nsleep_rem\nrem sleep, in hours\n\n\nsleep_cycle\nlength of sleep cycle, in hours\n\n\nawake\namount of time spent awake, in hours\n\n\nbrainwt\nbrain weight in kilograms\n\n\nbodywt\nbody weight in kilograms"
  },
  {
    "objectID": "reference/msleep.html#details",
    "href": "reference/msleep.html#details",
    "title": " plotnine.data.msleep",
    "section": "Details",
    "text": "Details\nAdditional variables order, conservation status and vore were added from wikipedia."
  },
  {
    "objectID": "reference/pageviews.html",
    "href": "reference/pageviews.html",
    "title": " plotnine.data.pageviews",
    "section": "",
    "text": "pageviews = pd.read_csv(DATA_DIR / \"pageviews.csv\", parse_dates=[0])"
  },
  {
    "objectID": "reference/panel_border.html",
    "href": "reference/panel_border.html",
    "title": " plotnine.themes.themeable.panel_border",
    "section": "",
    "text": "panel_border(theme_element)"
  },
  {
    "objectID": "reference/panel_border.html#parameters",
    "href": "reference/panel_border.html#parameters",
    "title": " plotnine.themes.themeable.panel_border",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_rect"
  },
  {
    "objectID": "reference/panel_grid_major.html",
    "href": "reference/panel_grid_major.html",
    "title": " plotnine.themes.themeable.panel_grid_major",
    "section": "",
    "text": "panel_grid_major(theme_element)"
  },
  {
    "objectID": "reference/panel_grid_major.html#parameters",
    "href": "reference/panel_grid_major.html#parameters",
    "title": " plotnine.themes.themeable.panel_grid_major",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/panel_grid_major_y.html",
    "href": "reference/panel_grid_major_y.html",
    "title": " plotnine.themes.themeable.panel_grid_major_y",
    "section": "",
    "text": "panel_grid_major_y(theme_element)"
  },
  {
    "objectID": "reference/panel_grid_major_y.html#parameters",
    "href": "reference/panel_grid_major_y.html#parameters",
    "title": " plotnine.themes.themeable.panel_grid_major_y",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/panel_grid_minor_x.html",
    "href": "reference/panel_grid_minor_x.html",
    "title": " plotnine.themes.themeable.panel_grid_minor_x",
    "section": "",
    "text": "panel_grid_minor_x(theme_element)"
  },
  {
    "objectID": "reference/panel_grid_minor_x.html#parameters",
    "href": "reference/panel_grid_minor_x.html#parameters",
    "title": " plotnine.themes.themeable.panel_grid_minor_x",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_line"
  },
  {
    "objectID": "reference/panel_ontop.html",
    "href": "reference/panel_ontop.html",
    "title": " plotnine.themes.themeable.panel_ontop",
    "section": "",
    "text": "panel_ontop(theme_element)"
  },
  {
    "objectID": "reference/panel_ontop.html#parameters",
    "href": "reference/panel_ontop.html#parameters",
    "title": " plotnine.themes.themeable.panel_ontop",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : bool\n\nDefault is False."
  },
  {
    "objectID": "reference/panel_spacing_x.html",
    "href": "reference/panel_spacing_x.html",
    "title": " plotnine.themes.themeable.panel_spacing_x",
    "section": "",
    "text": "panel_spacing_x(theme_element)"
  },
  {
    "objectID": "reference/panel_spacing_x.html#parameters",
    "href": "reference/panel_spacing_x.html#parameters",
    "title": " plotnine.themes.themeable.panel_spacing_x",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nSize as a fraction of the figure width."
  },
  {
    "objectID": "reference/plot_background.html",
    "href": "reference/plot_background.html",
    "title": " plotnine.themes.themeable.plot_background",
    "section": "",
    "text": "plot_background(theme_element)"
  },
  {
    "objectID": "reference/plot_background.html#parameters",
    "href": "reference/plot_background.html#parameters",
    "title": " plotnine.themes.themeable.plot_background",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_rect"
  },
  {
    "objectID": "reference/plot_caption_position.html",
    "href": "reference/plot_caption_position.html",
    "title": " plotnine.themes.themeable.plot_caption_position",
    "section": "",
    "text": "plot_caption_position(theme_element)"
  },
  {
    "objectID": "reference/plot_caption_position.html#parameters",
    "href": "reference/plot_caption_position.html#parameters",
    "title": " plotnine.themes.themeable.plot_caption_position",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : Literal[\"panel\", \"plot\"] = = \"panel\"\n\nIf “panel”, the caption is aligned with respect to the panels. If “plot”, it is aligned with the plot, excluding the margin space."
  },
  {
    "objectID": "reference/plot_margin_bottom.html",
    "href": "reference/plot_margin_bottom.html",
    "title": " plotnine.themes.themeable.plot_margin_bottom",
    "section": "",
    "text": "plot_margin_bottom(theme_element)"
  },
  {
    "objectID": "reference/plot_margin_bottom.html#parameters",
    "href": "reference/plot_margin_bottom.html#parameters",
    "title": " plotnine.themes.themeable.plot_margin_bottom",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nMust be in the [0, 1] range. It is specified as a fraction of the figure width and figure height."
  },
  {
    "objectID": "reference/plot_margin_right.html",
    "href": "reference/plot_margin_right.html",
    "title": " plotnine.themes.themeable.plot_margin_right",
    "section": "",
    "text": "plot_margin_right(theme_element)"
  },
  {
    "objectID": "reference/plot_margin_right.html#parameters",
    "href": "reference/plot_margin_right.html#parameters",
    "title": " plotnine.themes.themeable.plot_margin_right",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nMust be in the [0, 1] range. It is specified as a fraction of the figure width and figure height."
  },
  {
    "objectID": "reference/plot_subtitle.html",
    "href": "reference/plot_subtitle.html",
    "title": " plotnine.themes.themeable.plot_subtitle",
    "section": "",
    "text": "plot_subtitle(theme_element)"
  },
  {
    "objectID": "reference/plot_subtitle.html#parameters",
    "href": "reference/plot_subtitle.html#parameters",
    "title": " plotnine.themes.themeable.plot_subtitle",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/plot_subtitle.html#notes",
    "href": "reference/plot_subtitle.html#notes",
    "title": " plotnine.themes.themeable.plot_subtitle",
    "section": "Notes",
    "text": "Notes\nThe default horizontal alignment for the subtitle is left. And when it is present, by default it drags the title to the left. The subtitle drags the title to the left only if none of the two has their horizontal alignment are set."
  },
  {
    "objectID": "reference/plot_tag_location.html",
    "href": "reference/plot_tag_location.html",
    "title": " plotnine.themes.themeable.plot_tag_location",
    "section": "",
    "text": "plot_tag_location(theme_element)"
  },
  {
    "objectID": "reference/plot_tag_location.html#parameters",
    "href": "reference/plot_tag_location.html#parameters",
    "title": " plotnine.themes.themeable.plot_tag_location",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : Literal[\"margin\", \"plot\", \"panel\"] = = \"margin\"\n\nIf “margin”, it is placed within the plot_margin. If “plot”, it is placed in the figure, ignoring any margins. If “panel”, it is placed within the panel area."
  },
  {
    "objectID": "reference/plot_title.html",
    "href": "reference/plot_title.html",
    "title": " plotnine.themes.themeable.plot_title",
    "section": "",
    "text": "plot_title(theme_element)"
  },
  {
    "objectID": "reference/plot_title.html#parameters",
    "href": "reference/plot_title.html#parameters",
    "title": " plotnine.themes.themeable.plot_title",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/plot_title.html#notes",
    "href": "reference/plot_title.html#notes",
    "title": " plotnine.themes.themeable.plot_title",
    "section": "Notes",
    "text": "Notes\nThe default horizontal alignment for the title is center. However the title will be left aligned if and only if there is a subtitle and its horizontal alignment has not been set (so it defaults to the left).\nThe defaults ensure that, short titles are not awkwardly left-aligned, and that a title and a subtitle will not be awkwardly mis-aligned in the center or with different alignments."
  },
  {
    "objectID": "reference/position.html",
    "href": "reference/position.html",
    "title": " plotnine.positions.position.position",
    "section": "",
    "text": "position()"
  },
  {
    "objectID": "reference/position.html#methods",
    "href": "reference/position.html#methods",
    "title": " plotnine.positions.position.position",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncollide\nCalculate boundaries of geometry object\n\n\ncollide2\nCalculate boundaries of geometry object\n\n\ncompute_layer\nCompute position for the layer in all panels\n\n\ncompute_panel\nPositions must override this function\n\n\nfrom_geom\nCreate and return a position object for the geom\n\n\nsetup_data\nVerify & return data\n\n\nsetup_params\nVerify, modify & return a copy of the params.\n\n\nstrategy\nCalculate boundaries of geometry object\n\n\ntransform_position\nTransform all the variables that map onto the x and y scales.\n\n\n\n\n collide \n\ncollide(data, params)\n\n\nCalculate boundaries of geometry object\nUses Strategy\n\n\n\n collide2 \n\ncollide2(data, params)\n\n\nCalculate boundaries of geometry object\nUses Strategy\n\n\n\n compute_layer \n\ncompute_layer(data, params, layout)\n\n\nCompute position for the layer in all panels\nPositions can override this function instead of compute_panel if the position computations are independent of the panel. i.e when not colliding\n\n\n\n compute_panel \n\ncompute_panel(data, scales, params)\n\n\nPositions must override this function\n\n\nNotes\nMake necessary adjustments to the columns in the dataframe.\nCreate the position transformation functions and use self.transform_position() do the rest.\n\n\nSee Also\n\ncompute_panel\n\n\n\n\n\n\n\n from_geom \n\nfrom_geom(geom)\n\n\nCreate and return a position object for the geom\n\n\nParameters\n\n\ngeom : geom\n\nAn instantiated geom object.\n\n\n\n\n\nReturns\n\n\nout : position\n\nA position object\n\n\n\n\n\nRaises\n\n\nPlotnineError\n\nIf unable to create a position.\n\n\n\n\n\n\n setup_data\n\nsetup_data(data, params)\n\n\nVerify & return data\n\n\n\n setup_params\n\nsetup_params(data)\n\n\nVerify, modify & return a copy of the params.\n\n\n\n strategy \n\nstrategy(data, params)\n\n\nCalculate boundaries of geometry object\n\n\n\n transform_position \n\ntransform_position(data, trans_x=None, trans_y=None)\n\n\nTransform all the variables that map onto the x and y scales.\n\n\nParameters\n\n\ndata : dataframe\n\nData to transform\n\ntrans_x : callable = None\n\nTransforms x scale mappings Takes one argument, either a scalar or an array-type\n\ntrans_y : callable = None\n\nTransforms y scale mappings Takes one argument, either a scalar or an array-type"
  },
  {
    "objectID": "reference/position_dodge2.html",
    "href": "reference/position_dodge2.html",
    "title": " plotnine.position_dodge2",
    "section": "",
    "text": "position_dodge2(width=None, preserve=\"total\", padding=0.1, reverse=False)"
  },
  {
    "objectID": "reference/position_dodge2.html#parameters",
    "href": "reference/position_dodge2.html#parameters",
    "title": " plotnine.position_dodge2",
    "section": "Parameters",
    "text": "Parameters\n\n\nwidth : Optional[float] = None\n\nDodging width, when different to the width of the individual elements. This is useful when you want to align narrow geoms with wider geoms\n\npreserve : Literal[\"total\", \"single\"] = \"total\"\n\nShould dodging preserve the total width of all elements at a position, or the width of a single element?\n\npadding : float = 0.1\n\nPadding between elements at the same position. Elements are shrunk by this proportion to allow space between them.\n\nreverse : bool = False\n\nReverse the default ordering of the groups. This is useful if you’re rotating both the plot and legend."
  },
  {
    "objectID": "reference/position_identity.html",
    "href": "reference/position_identity.html",
    "title": " plotnine.position_identity",
    "section": "",
    "text": "position_identity()\n\n\nDo not adjust the position"
  },
  {
    "objectID": "reference/position_jitterdodge.html",
    "href": "reference/position_jitterdodge.html",
    "title": " plotnine.position_jitterdodge",
    "section": "",
    "text": "position_jitterdodge(\n    jitter_width=None, jitter_height=0, dodge_width=0.75, random_state=None\n)"
  },
  {
    "objectID": "reference/position_jitterdodge.html#parameters",
    "href": "reference/position_jitterdodge.html#parameters",
    "title": " plotnine.position_jitterdodge",
    "section": "Parameters",
    "text": "Parameters\n\n\njitter_width : Optional[float] = None\n\nProportion to jitter in horizontal direction. If None, 0.4 of the resolution of the data.\n\njitter_height : float = 0\n\nProportion to jitter in vertical direction.\n\ndodge_width : float = 0.75\n\nAmount to dodge in horizontal direction.\n\nrandom_state : Optional[int | np.random.RandomState] = None\n\nSeed or Random number generator to use. If None, then numpy global generator numpy.random is used."
  },
  {
    "objectID": "reference/position_stack.html",
    "href": "reference/position_stack.html",
    "title": " plotnine.position_stack",
    "section": "",
    "text": "position_stack(vjust=1, reverse=False)"
  },
  {
    "objectID": "reference/position_stack.html#parameters",
    "href": "reference/position_stack.html#parameters",
    "title": " plotnine.position_stack",
    "section": "Parameters",
    "text": "Parameters\n\n\nvjust : float = 1\n\nBy what fraction to avoid overlapping the lower object, where 0 gives a complete overlap and 1 gives no overlap.\n\nreverse : bool = False\n\nReverse the order of the stacked groups if true."
  },
  {
    "objectID": "reference/qplot.html",
    "href": "reference/qplot.html",
    "title": " plotnine.qplot",
    "section": "",
    "text": "qplot(\n    x=None,\n    y=None,\n    data=None,\n    facets=\"\",\n    margins=False,\n    geom=\"auto\",\n    xlim=None,\n    ylim=None,\n    log=None,\n    main=None,\n    xlab=None,\n    ylab=None,\n    asp=None,\n    kwargs={}\n)"
  },
  {
    "objectID": "reference/qplot.html#parameters",
    "href": "reference/qplot.html#parameters",
    "title": " plotnine.qplot",
    "section": "Parameters",
    "text": "Parameters\n\n\nx : Optional[str | Iterable[Any] | range] = None\n\nx aesthetic\n\ny : Optional[str | Iterable[Any] | range] = None\n\ny aesthetic\n\ndata : Optional[DataLike] = None\n\nData frame to use (optional). If not specified, will create one, extracting arrays from the current environment.\n\ngeom : str | Sequence[str] = \"auto\"\n\ngeom(s) to do the drawing. If auto, defaults to ‘point’ if x and y are specified or ‘histogram’ if only x is specified.\n\nfacets : str = \"\"\n\nFacets\n\nmargins : bool | Sequence[str] = False\n\nvariable names to compute margins for. True will compute all possible margins. Depends on the facetting.\n\nxlim : Optional[tuple[float, float]] = None\n\nx-axis limits\n\nylim : Optional[tuple[float, float]] = None\n\ny-axis limits\n\nlog : Optional[Literal[\"x\", \"y\", \"xy\"]] = None\n\nWhich (if any) variables to log transform.\n\nmain : Optional[str] = None\n\nPlot title\n\nxlab : Optional[str] = None\n\nx-axis label\n\nylab : Optional[str] = None\n\ny-axis label\n\nasp : Optional[float] = None\n\nThe y/x aspect ratio.\n\n**kwargs : Any = {}\n\nArguments passed on to the geom."
  },
  {
    "objectID": "reference/qplot.html#returns",
    "href": "reference/qplot.html#returns",
    "title": " plotnine.qplot",
    "section": "Returns",
    "text": "Returns\n\n\nggplot\n\nggplot object"
  },
  {
    "objectID": "reference/reorder.html",
    "href": "reference/reorder.html",
    "title": " plotnine.mapping._eval_environment.reorder",
    "section": "",
    "text": "reorder(x, y, fun=np.median, ascending=True)"
  },
  {
    "objectID": "reference/reorder.html#parameters",
    "href": "reference/reorder.html#parameters",
    "title": " plotnine.mapping._eval_environment.reorder",
    "section": "Parameters",
    "text": "Parameters\n\n\nx : list - like\n\nValues that will make up the categorical.\n\ny : list - like\n\nValues by which c will be ordered.\n\nfun : callable = np.median\n\nSummarising function to x for each category in c. Default is the median.\n\nascending : bool = True\n\nIf True, the c is ordered in ascending order of x."
  },
  {
    "objectID": "reference/reorder.html#examples",
    "href": "reference/reorder.html#examples",
    "title": " plotnine.mapping._eval_environment.reorder",
    "section": "Examples",
    "text": "Examples\n\n\nimport pandas as pd\nfrom plotnine import ggplot, aes, geom_col\n\ndf = pd.DataFrame({\n    \"x\": [\"b\", \"d\", \"c\", \"a\"],\n    \"y\": [1, 2, 3, 4]\n})\n\nggplot(df, aes(\"reorder(x, y)\", \"y\")) + geom_col()\n\n\n\n\n\n\n\n\nSource: reorder.ipynb"
  },
  {
    "objectID": "reference/scale.html",
    "href": "reference/scale.html",
    "title": " plotnine.scales.scale.scale",
    "section": "",
    "text": "scale(\n    *,\n    name=None,\n    breaks,\n    limits,\n    labels=True,\n    expand=None,\n    guide,\n    na_value=np.nan,\n    aesthetics=()\n)"
  },
  {
    "objectID": "reference/scale.html#parameter-attributes",
    "href": "reference/scale.html#parameter-attributes",
    "title": " plotnine.scales.scale.scale",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: BreaksUserT\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: LimitsUserT\n\nLimits of the scale. Most commonly, these are the min & max values for the scales. For scales that deal with categoricals, these may be a subset or superset of the categories.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: GuideTypeT\n\nWhether to include a legend\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun."
  },
  {
    "objectID": "reference/scale_alpha_continuous.html",
    "href": "reference/scale_alpha_continuous.html",
    "title": " plotnine.scale_alpha_continuous",
    "section": "",
    "text": "scale_alpha_continuous(\n    range=(0.1, 1),\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_alpha_continuous.html#init-parameters",
    "href": "reference/scale_alpha_continuous.html#init-parameters",
    "title": " plotnine.scale_alpha_continuous",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nrange: tuple[float, float] = (0.1, 1)\n\nRange ([Minimum, Maximum]) of output alpha values. Should be between 0 and 1."
  },
  {
    "objectID": "reference/scale_alpha_continuous.html#parameter-attributes",
    "href": "reference/scale_alpha_continuous.html#parameter-attributes",
    "title": " plotnine.scale_alpha_continuous",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_alpha_discrete.html",
    "href": "reference/scale_alpha_discrete.html",
    "title": " plotnine.scale_alpha_discrete",
    "section": "",
    "text": "scale_alpha_discrete(\n    range=(0.1, 1),\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_alpha_discrete.html#init-parameters",
    "href": "reference/scale_alpha_discrete.html#init-parameters",
    "title": " plotnine.scale_alpha_discrete",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nrange: tuple[float, float] = (0.1, 1)\n\nRange ([Minimum, Maximum]) of output alpha values. Should be between 0 and 1."
  },
  {
    "objectID": "reference/scale_alpha_discrete.html#parameter-attributes",
    "href": "reference/scale_alpha_discrete.html#parameter-attributes",
    "title": " plotnine.scale_alpha_discrete",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_alpha_manual.html",
    "href": "reference/scale_alpha_manual.html",
    "title": " plotnine.scale_alpha_manual",
    "section": "",
    "text": "scale_alpha_manual(\n    values,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_alpha_manual.html#init-parameters",
    "href": "reference/scale_alpha_manual.html#init-parameters",
    "title": " plotnine.scale_alpha_manual",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nvalues: Sequence[Any] | dict[Any, Any] \n\nAlpha values (in the [0, 1] range) that make up the palette. The values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to alpha values."
  },
  {
    "objectID": "reference/scale_alpha_manual.html#parameter-attributes",
    "href": "reference/scale_alpha_manual.html#parameter-attributes",
    "title": " plotnine.scale_alpha_manual",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_color_brewer.html",
    "href": "reference/scale_color_brewer.html",
    "title": " plotnine.scale_color_brewer",
    "section": "",
    "text": "scale_color_brewer(\n    type=\"seq\",\n    palette=1,\n    direction=1,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_color_brewer.html#init-parameters",
    "href": "reference/scale_color_brewer.html#init-parameters",
    "title": " plotnine.scale_color_brewer",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ntype: Literal['diverging', 'qualitative', 'sequential', 'div', 'qual', 'seq'] = 'seq'\n\nType of data\n\npalette: int | str = 1\n\nIf a string, will use that named palette. If a number, will index into the list of palettes of appropriate type.\n\ndirection: Literal[1, -1] = 1\n\nSets the order of colors in the scale. If 1, colors are as output brewer_pal. If -1, the order of colors is reversed."
  },
  {
    "objectID": "reference/scale_color_brewer.html#parameter-attributes",
    "href": "reference/scale_color_brewer.html#parameter-attributes",
    "title": " plotnine.scale_color_brewer",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_color_cmap_d.html",
    "href": "reference/scale_color_cmap_d.html",
    "title": " plotnine.scale_color_cmap_d",
    "section": "",
    "text": "scale_color_cmap_d(\n    cmap_name=\"viridis\",\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_color_cmap_d.html#init-parameters",
    "href": "reference/scale_color_cmap_d.html#init-parameters",
    "title": " plotnine.scale_color_cmap_d",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ncmap_name: str = 'viridis'\n\nA standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see the documentation &lt;http://matplotlib.org/users/colormaps.html&gt;_."
  },
  {
    "objectID": "reference/scale_color_cmap_d.html#parameter-attributes",
    "href": "reference/scale_color_cmap_d.html#parameter-attributes",
    "title": " plotnine.scale_color_cmap_d",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_color_cmap_d.html#see-also",
    "href": "reference/scale_color_cmap_d.html#see-also",
    "title": " plotnine.scale_color_cmap_d",
    "section": "See Also",
    "text": "See Also\n\nmatplotlib.cm\n\n\n\nmatplotlib.colors"
  },
  {
    "objectID": "reference/scale_color_datetime.html",
    "href": "reference/scale_color_datetime.html",
    "title": " plotnine.scale_color_datetime",
    "section": "",
    "text": "scale_color_datetime(\n    cmap_name=\"viridis\",\n    date_breaks=None,\n    date_labels=None,\n    date_minor_breaks=None,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"colorbar\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"datetime\"\n)"
  },
  {
    "objectID": "reference/scale_color_datetime.html#init-parameters",
    "href": "reference/scale_color_datetime.html#init-parameters",
    "title": " plotnine.scale_color_datetime",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ncmap_name: str = 'viridis'\n\nA standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see colormaps.\n\ndate_breaks: str | None = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str | None = None\n\nFormat string for the labels. See strftime. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str | None = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks."
  },
  {
    "objectID": "reference/scale_color_datetime.html#parameter-attributes",
    "href": "reference/scale_color_datetime.html#parameter-attributes",
    "title": " plotnine.scale_color_datetime",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: ( # pyright: ignore[reportIncompatibleVariableOverride]    tuple[float, timedelta]    | tuple[float, timedelta, float, timedelta]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, timedelta(0)) - Do not expand.\n(0, timedelta(days=1)) - Expand lower and upper limits by 1 day.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, timedelta(hours=6)) - Expand upper limit by 6 hours.\n(0, timedelta(minutes=5), 0.1, timdelta(0)) - Expand lower limit by 5 minutes and upper limit by 10%.\n(0, 0, 0.1, timedelta(weeks=2)) - Expand upper limit by 10% plus 2 weeks.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\", \"colorbar\"] | None = \"colorbar\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"datetime\""
  },
  {
    "objectID": "reference/scale_color_discrete.html",
    "href": "reference/scale_color_discrete.html",
    "title": " plotnine.scale_color_discrete",
    "section": "",
    "text": "scale_color_discrete(\n    h=0.01,\n    l=0.6,\n    s=0.65,\n    color_space=\"hls\",\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_color_discrete.html#init-parameters",
    "href": "reference/scale_color_discrete.html#init-parameters",
    "title": " plotnine.scale_color_discrete",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nh: float = 0.01\n\nHue. Must be in the range [0, 1]\n\nl: float = 0.6\n\nLightness. Must be in the range [0, 1]\n\ns: float = 0.65\n\nSaturation. Must be in the range [0, 1]\n\ncolor_space: Literal['hls', 'hsluv'] = 'hls'\n\nColor space to use. Should be one of hls or hsluv. https://www.hsluv.org/"
  },
  {
    "objectID": "reference/scale_color_discrete.html#parameter-attributes",
    "href": "reference/scale_color_discrete.html#parameter-attributes",
    "title": " plotnine.scale_color_discrete",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_color_discrete.html#examples",
    "href": "reference/scale_color_discrete.html#examples",
    "title": " plotnine.scale_color_discrete",
    "section": "Examples",
    "text": "Examples\n\n\nimport pandas as pd\nimport numpy as np\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_path,\n    geom_point,\n    geom_col,\n    labs,\n    scale_color_discrete,\n    scale_fill_discrete,\n    guides,\n    guide_legend,\n)\n\nMake some data\n\nn = 9\ndf = pd.DataFrame(\n    {\n        \"x\": np.arange(1, n+1),\n        \"y\": np.arange(1, n+1),\n        \"yfit\": np.arange(1, n+1) + np.tile([-0.2, 0, 0.2], n // 3),\n        \"cat\": [\"a\", \"b\", \"c\"] * (n // 3),\n    }\n)\n\nDraw an initial plot.\n\n(\n    ggplot(df)\n    + geom_col(aes(\"x\", \"y\"))\n)\n\n\n\n\n\n\n\n\nMapping the fill to a discrete variable uses the default color palette from the scale_fill_discrete\n\n(\n    ggplot(df)\n    + geom_col(aes(\"x\", \"y\", fill=\"cat\")) # changed\n)\n\n\n\n\n\n\n\n\nAssuming we want to visualise a “model” on top of the data. We could add this model data as points and a path through the points.\n\n(\n    ggplot(df)\n    + geom_col(aes(\"x\", \"y\", fill=\"cat\"))\n    + geom_point(aes(\"x\", y=\"yfit\", color=\"cat\"))  # new\n    + geom_path(aes(\"x\", y=\"yfit\", color=\"cat\"))   # new\n)\n\n\n\n\n\n\n\n\nThere is a clash of colors between the actual data (the bars) and the fitted model (the points and lines). A simple solution is to adjust the colors of the fitted model slightly. We do that by varying the lightness of the default color scale, make them a little darker.\n\n(\n    ggplot(df)\n    + geom_col(aes(\"x\", \"y\", fill=\"cat\"))\n    + geom_point(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + geom_path(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + scale_color_discrete(l=0.4)   # new\n)\n\n\n\n\n\n\n\n\nThere are two main pieces of information in the plot, but we a single combined legend. Since we use separate aesthetics for the actual data and fitted model, we can have distinct legends for both by giving a name to the scales associated with each.\n\n(\n    ggplot(df)\n    + geom_col(aes(\"x\", \"y\", fill=\"cat\"))\n    + geom_point(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + geom_path(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + scale_color_discrete(l=0.4, name=\"Model\") # modified\n    + scale_fill_discrete(name=\"Data\")          # new\n)\n\n\n\n\n\n\n\n\nAlternatively, we could use the labs class to set the names.\n\n(\n    ggplot(df)\n    + geom_col(aes(\"x\", \"y\", fill=\"cat\"))\n    + geom_point(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + geom_path(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + scale_color_discrete(l=0.4)\n    + labs(fill=\"Data\", color=\"Model\") # new\n)\n\n\n\n\n\n\n\n\nOr we could use guide_legend to rename the titles of the legends.\n\n(\n    ggplot(df)\n    + geom_col(aes(\"x\", \"y\", fill=\"cat\"))\n    + geom_point(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + geom_path(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + scale_color_discrete(l=0.4)\n    + guides( # new\n        fill=guide_legend(title=\"Data\"), color=guide_legend(title=\"Model\")\n    )\n)\n\n\n\n\n\n\n\n\nSource: scale_color_discrete.ipynb"
  },
  {
    "objectID": "reference/scale_color_gradient.html",
    "href": "reference/scale_color_gradient.html",
    "title": " plotnine.scale_color_gradient",
    "section": "",
    "text": "scale_color_gradient(\n    low=\"#132B43\",\n    high=\"#56B1F7\",\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"colorbar\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_color_gradient.html#init-parameters",
    "href": "reference/scale_color_gradient.html#init-parameters",
    "title": " plotnine.scale_color_gradient",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nlow: str = '#132B43'\n\nLow color.\n\nhigh: str = '#56B1F7'\n\nHigh color."
  },
  {
    "objectID": "reference/scale_color_gradient.html#parameter-attributes",
    "href": "reference/scale_color_gradient.html#parameter-attributes",
    "title": " plotnine.scale_color_gradient",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\", \"colorbar\"] | None = \"colorbar\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_color_gradient.html#see-also",
    "href": "reference/scale_color_gradient.html#see-also",
    "title": " plotnine.scale_color_gradient",
    "section": "See Also",
    "text": "See Also\n\nscale_color_gradient2\n\n\n\nscale_color_gradientn"
  },
  {
    "objectID": "reference/scale_color_gradientn.html",
    "href": "reference/scale_color_gradientn.html",
    "title": " plotnine.scale_color_gradientn",
    "section": "",
    "text": "scale_color_gradientn(\n    colors=\"#832424\",\n    values=None,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"colorbar\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_color_gradientn.html#init-parameters",
    "href": "reference/scale_color_gradientn.html#init-parameters",
    "title": " plotnine.scale_color_gradientn",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ncolors: Sequence[str] = '#832424'\n\nList of colors\n\nvalues: Sequence[float] | None = None\n\nlist of points in the range [0, 1] at which to place each color. Must be the same size as colors. Default to evenly space the colors"
  },
  {
    "objectID": "reference/scale_color_gradientn.html#parameter-attributes",
    "href": "reference/scale_color_gradientn.html#parameter-attributes",
    "title": " plotnine.scale_color_gradientn",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\", \"colorbar\"] | None = \"colorbar\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_color_gradientn.html#see-also",
    "href": "reference/scale_color_gradientn.html#see-also",
    "title": " plotnine.scale_color_gradientn",
    "section": "See Also",
    "text": "See Also\n\nscale_color_gradient\n\n\n\nscale_color_gradientn"
  },
  {
    "objectID": "reference/scale_color_grey.html",
    "href": "reference/scale_color_grey.html",
    "title": " plotnine.scale_color_grey",
    "section": "",
    "text": "scale_color_grey(\n    start=0.2,\n    end=0.8,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_color_grey.html#init-parameters",
    "href": "reference/scale_color_grey.html#init-parameters",
    "title": " plotnine.scale_color_grey",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nstart: float = 0.2\n\nGrey value at low end of palette.\n\nend: float = 0.8\n\nGrey value at high end of palette"
  },
  {
    "objectID": "reference/scale_color_grey.html#parameter-attributes",
    "href": "reference/scale_color_grey.html#parameter-attributes",
    "title": " plotnine.scale_color_grey",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_color_identity.html",
    "href": "reference/scale_color_identity.html",
    "title": " plotnine.scale_color_identity",
    "section": "",
    "text": "scale_color_identity(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_color_identity.html#parameter-attributes",
    "href": "reference/scale_color_identity.html#parameter-attributes",
    "title": " plotnine.scale_color_identity",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = None\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_color_ordinal.html",
    "href": "reference/scale_color_ordinal.html",
    "title": " plotnine.scale_color_ordinal",
    "section": "",
    "text": "scale_color_ordinal(\n    cmap_name=\"viridis\",\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_color_ordinal.html#init-parameters",
    "href": "reference/scale_color_ordinal.html#init-parameters",
    "title": " plotnine.scale_color_ordinal",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ncmap_name: str = 'viridis'\n\nA standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see the documentation &lt;http://matplotlib.org/users/colormaps.html&gt;_."
  },
  {
    "objectID": "reference/scale_color_ordinal.html#parameter-attributes",
    "href": "reference/scale_color_ordinal.html#parameter-attributes",
    "title": " plotnine.scale_color_ordinal",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_colour_manual.html",
    "href": "reference/scale_colour_manual.html",
    "title": " plotnine.scale_colour_manual",
    "section": "",
    "text": "scale_colour_manual(\n    values,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_colour_manual.html#init-parameters",
    "href": "reference/scale_colour_manual.html#init-parameters",
    "title": " plotnine.scale_colour_manual",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nvalues: Sequence[Any] | dict[Any, Any] \n\nColors that make up the palette. The values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to colors."
  },
  {
    "objectID": "reference/scale_colour_manual.html#parameter-attributes",
    "href": "reference/scale_colour_manual.html#parameter-attributes",
    "title": " plotnine.scale_colour_manual",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\n\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_datetime.html",
    "href": "reference/scale_datetime.html",
    "title": " plotnine.scales.scale_datetime.scale_datetime",
    "section": "",
    "text": "scale_datetime(\n    date_breaks=None,\n    date_labels=None,\n    date_minor_breaks=None,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"datetime\"\n)"
  },
  {
    "objectID": "reference/scale_datetime.html#init-parameters",
    "href": "reference/scale_datetime.html#init-parameters",
    "title": " plotnine.scales.scale_datetime.scale_datetime",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ndate_breaks: str | None = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str | None = None\n\nFormat string for the labels. See strftime. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str | None = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks."
  },
  {
    "objectID": "reference/scale_datetime.html#parameter-attributes",
    "href": "reference/scale_datetime.html#parameter-attributes",
    "title": " plotnine.scales.scale_datetime.scale_datetime",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: ( # pyright: ignore[reportIncompatibleVariableOverride]    tuple[float, timedelta]    | tuple[float, timedelta, float, timedelta]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, timedelta(0)) - Do not expand.\n(0, timedelta(days=1)) - Expand lower and upper limits by 1 day.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, timedelta(hours=6)) - Expand upper limit by 6 hours.\n(0, timedelta(minutes=5), 0.1, timdelta(0)) - Expand lower limit by 5 minutes and upper limit by 10%.\n(0, 0, 0.1, timedelta(weeks=2)) - Expand upper limit by 10% plus 2 weeks.\n\nIf not specified, suitable defaults are chosen.\n\nguide: GuideTypeT\n\nWhether to include a legend\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"datetime\""
  },
  {
    "objectID": "reference/scale_fill_brewer.html",
    "href": "reference/scale_fill_brewer.html",
    "title": " plotnine.scale_fill_brewer",
    "section": "",
    "text": "scale_fill_brewer(\n    type=\"seq\",\n    palette=1,\n    direction=1,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_fill_brewer.html#init-parameters",
    "href": "reference/scale_fill_brewer.html#init-parameters",
    "title": " plotnine.scale_fill_brewer",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ntype: Literal['diverging', 'qualitative', 'sequential', 'div', 'qual', 'seq'] = 'seq'\n\nType of data\n\npalette: int | str = 1\n\nIf a string, will use that named palette. If a number, will index into the list of palettes of appropriate type.\n\ndirection: Literal[1, -1] = 1\n\nSets the order of colors in the scale. If 1, colors are as output brewer_pal. If -1, the order of colors is reversed."
  },
  {
    "objectID": "reference/scale_fill_brewer.html#parameter-attributes",
    "href": "reference/scale_fill_brewer.html#parameter-attributes",
    "title": " plotnine.scale_fill_brewer",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_fill_cmap_d.html",
    "href": "reference/scale_fill_cmap_d.html",
    "title": " plotnine.scale_fill_cmap_d",
    "section": "",
    "text": "scale_fill_cmap_d(\n    cmap_name=\"viridis\",\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_fill_cmap_d.html#init-parameters",
    "href": "reference/scale_fill_cmap_d.html#init-parameters",
    "title": " plotnine.scale_fill_cmap_d",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ncmap_name: str = 'viridis'\n\nA standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see the documentation &lt;http://matplotlib.org/users/colormaps.html&gt;_."
  },
  {
    "objectID": "reference/scale_fill_cmap_d.html#parameter-attributes",
    "href": "reference/scale_fill_cmap_d.html#parameter-attributes",
    "title": " plotnine.scale_fill_cmap_d",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_fill_datetime.html",
    "href": "reference/scale_fill_datetime.html",
    "title": " plotnine.scale_fill_datetime",
    "section": "",
    "text": "scale_fill_datetime(\n    cmap_name=\"viridis\",\n    date_breaks=None,\n    date_labels=None,\n    date_minor_breaks=None,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"colorbar\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"datetime\"\n)"
  },
  {
    "objectID": "reference/scale_fill_datetime.html#init-parameters",
    "href": "reference/scale_fill_datetime.html#init-parameters",
    "title": " plotnine.scale_fill_datetime",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ncmap_name: str = 'viridis'\n\nA standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see colormaps.\n\ndate_breaks: str | None = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str | None = None\n\nFormat string for the labels. See strftime. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str | None = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks."
  },
  {
    "objectID": "reference/scale_fill_datetime.html#parameter-attributes",
    "href": "reference/scale_fill_datetime.html#parameter-attributes",
    "title": " plotnine.scale_fill_datetime",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: ( # pyright: ignore[reportIncompatibleVariableOverride]    tuple[float, timedelta]    | tuple[float, timedelta, float, timedelta]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, timedelta(0)) - Do not expand.\n(0, timedelta(days=1)) - Expand lower and upper limits by 1 day.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, timedelta(hours=6)) - Expand upper limit by 6 hours.\n(0, timedelta(minutes=5), 0.1, timdelta(0)) - Expand lower limit by 5 minutes and upper limit by 10%.\n(0, 0, 0.1, timedelta(weeks=2)) - Expand upper limit by 10% plus 2 weeks.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\", \"colorbar\"] | None = \"colorbar\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"datetime\""
  },
  {
    "objectID": "reference/scale_fill_discrete.html",
    "href": "reference/scale_fill_discrete.html",
    "title": " plotnine.scale_fill_discrete",
    "section": "",
    "text": "scale_fill_discrete(\n    h=0.01,\n    l=0.6,\n    s=0.65,\n    color_space=\"hls\",\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_fill_discrete.html#init-parameters",
    "href": "reference/scale_fill_discrete.html#init-parameters",
    "title": " plotnine.scale_fill_discrete",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nh: float = 0.01\n\nHue. Must be in the range [0, 1]\n\nl: float = 0.6\n\nLightness. Must be in the range [0, 1]\n\ns: float = 0.65\n\nSaturation. Must be in the range [0, 1]\n\ncolor_space: Literal['hls', 'hsluv'] = 'hls'\n\nColor space to use. Should be one of hls or hsluv. https://www.hsluv.org/"
  },
  {
    "objectID": "reference/scale_fill_discrete.html#parameter-attributes",
    "href": "reference/scale_fill_discrete.html#parameter-attributes",
    "title": " plotnine.scale_fill_discrete",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_fill_gradient.html",
    "href": "reference/scale_fill_gradient.html",
    "title": " plotnine.scale_fill_gradient",
    "section": "",
    "text": "scale_fill_gradient(\n    low=\"#132B43\",\n    high=\"#56B1F7\",\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"colorbar\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_fill_gradient.html#init-parameters",
    "href": "reference/scale_fill_gradient.html#init-parameters",
    "title": " plotnine.scale_fill_gradient",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nlow: str = '#132B43'\n\nLow color.\n\nhigh: str = '#56B1F7'\n\nHigh color."
  },
  {
    "objectID": "reference/scale_fill_gradient.html#parameter-attributes",
    "href": "reference/scale_fill_gradient.html#parameter-attributes",
    "title": " plotnine.scale_fill_gradient",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\", \"colorbar\"] | None = \"colorbar\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_fill_gradientn.html",
    "href": "reference/scale_fill_gradientn.html",
    "title": " plotnine.scale_fill_gradientn",
    "section": "",
    "text": "scale_fill_gradientn(\n    colors=\"#832424\",\n    values=None,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"colorbar\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_fill_gradientn.html#init-parameters",
    "href": "reference/scale_fill_gradientn.html#init-parameters",
    "title": " plotnine.scale_fill_gradientn",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ncolors: Sequence[str] = '#832424'\n\nList of colors\n\nvalues: Sequence[float] | None = None\n\nlist of points in the range [0, 1] at which to place each color. Must be the same size as colors. Default to evenly space the colors"
  },
  {
    "objectID": "reference/scale_fill_gradientn.html#parameter-attributes",
    "href": "reference/scale_fill_gradientn.html#parameter-attributes",
    "title": " plotnine.scale_fill_gradientn",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\", \"colorbar\"] | None = \"colorbar\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_fill_grey.html",
    "href": "reference/scale_fill_grey.html",
    "title": " plotnine.scale_fill_grey",
    "section": "",
    "text": "scale_fill_grey(\n    start=0.2,\n    end=0.8,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=\"#7F7F7F\",\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_fill_grey.html#init-parameters",
    "href": "reference/scale_fill_grey.html#init-parameters",
    "title": " plotnine.scale_fill_grey",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nstart: float = 0.2\n\nGrey value at low end of palette.\n\nend: float = 0.8\n\nGrey value at high end of palette"
  },
  {
    "objectID": "reference/scale_fill_grey.html#parameter-attributes",
    "href": "reference/scale_fill_grey.html#parameter-attributes",
    "title": " plotnine.scale_fill_grey",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: str = \"#7F7F7F\"\n\nColor of missing values.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_fill_identity.html",
    "href": "reference/scale_fill_identity.html",
    "title": " plotnine.scale_fill_identity",
    "section": "",
    "text": "scale_fill_identity(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_fill_identity.html#parameter-attributes",
    "href": "reference/scale_fill_identity.html#parameter-attributes",
    "title": " plotnine.scale_fill_identity",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = None\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_fill_ordinal.html",
    "href": "reference/scale_fill_ordinal.html",
    "title": " plotnine.scale_fill_ordinal",
    "section": "",
    "text": "scale_fill_ordinal(\n    cmap_name=\"viridis\",\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_fill_ordinal.html#init-parameters",
    "href": "reference/scale_fill_ordinal.html#init-parameters",
    "title": " plotnine.scale_fill_ordinal",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ncmap_name: str = 'viridis'\n\nA standard Matplotlib colormap name. The default is viridis. For the list of names checkout the output of matplotlib.cm.cmap_d.keys() or see the documentation &lt;http://matplotlib.org/users/colormaps.html&gt;_."
  },
  {
    "objectID": "reference/scale_fill_ordinal.html#parameter-attributes",
    "href": "reference/scale_fill_ordinal.html#parameter-attributes",
    "title": " plotnine.scale_fill_ordinal",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_linetype_discrete.html",
    "href": "reference/scale_linetype_discrete.html",
    "title": " plotnine.scale_linetype_discrete",
    "section": "",
    "text": "scale_linetype_discrete(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_linetype_discrete.html#parameter-attributes",
    "href": "reference/scale_linetype_discrete.html#parameter-attributes",
    "title": " plotnine.scale_linetype_discrete",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_linetype_manual.html",
    "href": "reference/scale_linetype_manual.html",
    "title": " plotnine.scale_linetype_manual",
    "section": "",
    "text": "scale_linetype_manual(\n    values,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_linetype_manual.html#init-parameters",
    "href": "reference/scale_linetype_manual.html#init-parameters",
    "title": " plotnine.scale_linetype_manual",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nvalues: Sequence[Any] | dict[Any, Any] \n\nLinetypes that make up the palette. Possible values of the list are:\n\nStrings like\n\n'solid'                # solid line\n'dashed'               # dashed line\n'dashdot'              # dash-dotted line\n'dotted'               # dotted line\n'None' or ' ' or ''    # draw nothing\n\nTuples of the form (offset, (on, off, on, off, ….)) e.g. (0, (1, 1)), (1, (2, 2)), (2, (5, 3, 1, 3))\n\nThe values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to linetypes."
  },
  {
    "objectID": "reference/scale_linetype_manual.html#parameter-attributes",
    "href": "reference/scale_linetype_manual.html#parameter-attributes",
    "title": " plotnine.scale_linetype_manual",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_linetype_manual.html#see-also",
    "href": "reference/scale_linetype_manual.html#see-also",
    "title": " plotnine.scale_linetype_manual",
    "section": "See Also",
    "text": "See Also\n\nmatplotlib.markers"
  },
  {
    "objectID": "reference/scale_shape_discrete.html",
    "href": "reference/scale_shape_discrete.html",
    "title": " plotnine.scale_shape_discrete",
    "section": "",
    "text": "scale_shape_discrete(\n    unfilled=False,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_shape_discrete.html#init-parameters",
    "href": "reference/scale_shape_discrete.html#init-parameters",
    "title": " plotnine.scale_shape_discrete",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nunfilled: bool = False\n\nIf True, then all shapes will have no interiors that can be a filled."
  },
  {
    "objectID": "reference/scale_shape_discrete.html#parameter-attributes",
    "href": "reference/scale_shape_discrete.html#parameter-attributes",
    "title": " plotnine.scale_shape_discrete",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_shape_manual.html",
    "href": "reference/scale_shape_manual.html",
    "title": " plotnine.scale_shape_manual",
    "section": "",
    "text": "scale_shape_manual(\n    values,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_shape_manual.html#init-parameters",
    "href": "reference/scale_shape_manual.html#init-parameters",
    "title": " plotnine.scale_shape_manual",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nvalues: Sequence[Any] | dict[Any, Any] \n\nShapes that make up the palette. See matplotlib.markers for list of all possible shapes. The values will be matched with the limits of the scale or the breaks if provided. If it is a dict then it should map data values to shapes."
  },
  {
    "objectID": "reference/scale_shape_manual.html#parameter-attributes",
    "href": "reference/scale_shape_manual.html#parameter-attributes",
    "title": " plotnine.scale_shape_manual",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_shape_manual.html#see-also",
    "href": "reference/scale_shape_manual.html#see-also",
    "title": " plotnine.scale_shape_manual",
    "section": "See Also",
    "text": "See Also\n\nmatplotlib.markers"
  },
  {
    "objectID": "reference/scale_size_area.html",
    "href": "reference/scale_size_area.html",
    "title": " plotnine.scale_size_area",
    "section": "",
    "text": "scale_size_area(\n    max_size=6,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_size_area.html#init-parameters",
    "href": "reference/scale_size_area.html#init-parameters",
    "title": " plotnine.scale_size_area",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nmax_size: float = 6\n\nMaximum size of the plotting symbol."
  },
  {
    "objectID": "reference/scale_size_area.html#parameter-attributes",
    "href": "reference/scale_size_area.html#parameter-attributes",
    "title": " plotnine.scale_size_area",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler = rescale_max\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_size_datetime.html",
    "href": "reference/scale_size_datetime.html",
    "title": " plotnine.scale_size_datetime",
    "section": "",
    "text": "scale_size_datetime(\n    date_breaks=None,\n    date_labels=None,\n    date_minor_breaks=None,\n    range=(1, 6),\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"datetime\"\n)"
  },
  {
    "objectID": "reference/scale_size_datetime.html#init-parameters",
    "href": "reference/scale_size_datetime.html#init-parameters",
    "title": " plotnine.scale_size_datetime",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ndate_breaks: str | None = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str | None = None\n\nFormat string for the labels. See strftime. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str | None = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks.\n\nrange: tuple[float, float] = (1, 6)\n\nRange ([Minimum, Maximum]) of the size."
  },
  {
    "objectID": "reference/scale_size_datetime.html#parameter-attributes",
    "href": "reference/scale_size_datetime.html#parameter-attributes",
    "title": " plotnine.scale_size_datetime",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: ( # pyright: ignore[reportIncompatibleVariableOverride]    tuple[float, timedelta]    | tuple[float, timedelta, float, timedelta]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, timedelta(0)) - Do not expand.\n(0, timedelta(days=1)) - Expand lower and upper limits by 1 day.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, timedelta(hours=6)) - Expand upper limit by 6 hours.\n(0, timedelta(minutes=5), 0.1, timdelta(0)) - Expand lower limit by 5 minutes and upper limit by 10%.\n(0, 0, 0.1, timedelta(weeks=2)) - Expand upper limit by 10% plus 2 weeks.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"datetime\""
  },
  {
    "objectID": "reference/scale_size_identity.html",
    "href": "reference/scale_size_identity.html",
    "title": " plotnine.scale_size_identity",
    "section": "",
    "text": "scale_size_identity(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_size_identity.html#parameter-attributes",
    "href": "reference/scale_size_identity.html#parameter-attributes",
    "title": " plotnine.scale_size_identity",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = None\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_size_ordinal.html",
    "href": "reference/scale_size_ordinal.html",
    "title": " plotnine.scale_size_ordinal",
    "section": "",
    "text": "scale_size_ordinal(\n    range=(2, 6),\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_size_ordinal.html#init-parameters",
    "href": "reference/scale_size_ordinal.html#init-parameters",
    "title": " plotnine.scale_size_ordinal",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nrange: tuple[float, float] = (2, 6)\n\nRange ([Minimum, Maximum]) of the size."
  },
  {
    "objectID": "reference/scale_size_ordinal.html#parameter-attributes",
    "href": "reference/scale_size_ordinal.html#parameter-attributes",
    "title": " plotnine.scale_size_ordinal",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_stroke.html",
    "href": "reference/scale_stroke.html",
    "title": " plotnine.scale_stroke",
    "section": "",
    "text": "scale_stroke(\n    range=(1, 6),\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_stroke.html#init-parameters",
    "href": "reference/scale_stroke.html#init-parameters",
    "title": " plotnine.scale_stroke",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\nrange: tuple[float, float] = (1, 6)\n\nRange ([Minimum, Maximum]) of output stroke values. Should be between 0 and 1."
  },
  {
    "objectID": "reference/scale_stroke.html#parameter-attributes",
    "href": "reference/scale_stroke.html#parameter-attributes",
    "title": " plotnine.scale_stroke",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_x_continuous.html",
    "href": "reference/scale_x_continuous.html",
    "title": " plotnine.scale_x_continuous",
    "section": "",
    "text": "scale_x_continuous(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=None\n)"
  },
  {
    "objectID": "reference/scale_x_continuous.html#parameter-attributes",
    "href": "reference/scale_x_continuous.html#parameter-attributes",
    "title": " plotnine.scale_x_continuous",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: None = None\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = None\n\nThe transformation of the scale. Either name of a trans function or a trans function. See mizani.transforms for possible options."
  },
  {
    "objectID": "reference/scale_x_continuous.html#examples",
    "href": "reference/scale_x_continuous.html#examples",
    "title": " plotnine.scale_x_continuous",
    "section": "Examples",
    "text": "Examples\n\n\nimport numpy as np\nimport pandas as pd\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    geom_path,\n    scale_x_continuous,\n    scale_y_continuous,\n    guides,\n    theme,\n    element_line,\n    element_rect,\n)\nfrom mizani.transforms import trans\n\n\nGuitar Neck\nUsing a transformed x-axis to visualise guitar chords\nThe x-axis is transformed to resemble the narrowing width of frets on a 25.5 inch Strat. To do that we create custom transformation.\nThe key parts of any transform object are the transform and inverse functions.\n\nclass frets_trans(trans):\n    \"\"\"\n    Frets Transformation\n    \"\"\"\n\n    number_of_frets = 23  # Including fret 0\n    domain = (0, number_of_frets - 1)\n\n    @staticmethod\n    def transform(x):\n        x = np.asarray(x)\n        return 25.5 - (25.5 / (2 ** (x / 12)))\n\n    @staticmethod\n    def inverse(x):\n        x = np.asarray(x)\n        return 12 * np.log2(25.5 / (25.5 - x))\n\n    @classmethod\n    def breaks_(cls, limits):\n        # Fixed major breaks\n        return cls.domain\n\n    @classmethod\n    def minor_breaks(cls, major, limits):\n        # The major breaks as passed to this method are in transformed space.\n        # The minor breaks are calculated in data space to reveal the\n        # non-linearity of the scale.\n        _major = cls.inverse(major)\n        minor = cls.transform(np.linspace(*_major, cls.number_of_frets))\n        return minor\n\nThe above transform is different from most in that, breaks and minor breaks do not change. This is common of very specialized scales. It can also be a key requirement when creating graphics for demontration purposes.\nSome chord Data\n\n# Notes: the 0 fret is an open strum, all other frets are played half-way between fret bars.\n# The strings are 1:low E, 2: A, 3: D, 4: G, 5: B, 6: E\nc_chord = pd.DataFrame({\"Fret\": [0, 2.5, 1.5, 0, 0.5, 0], \"String\": [1, 2, 3, 4, 5, 6]})\n\n# Sequence based on the number of notes in the chord\nc_chord[\"Sequence\"] = list(range(1, 1 + len(c_chord[\"Fret\"])))\n\n# Standard markings for a Stratocaster\nmarkings = pd.DataFrame(\n    {\n        \"Fret\": [2.5, 4.5, 6.5, 8.5, 11.5, 11.5, 14.5, 16.5, 18.5, 20.5],\n        \"String\": [3.5, 3.5, 3.5, 3.5, 2, 5, 3.5, 3.5, 3.5, 3.5],\n    }\n)\n\nVisualizing the chord\n\n# Gallery, elaborate\n\n# Look and feel of the graphic\nneck_color = \"#FFDDCC\"\nfret_color = \"#998888\"\nstring_color = \"#AA9944\"\n\nneck_theme = theme(\n    figure_size=(10, 2),\n    panel_background=element_rect(fill=neck_color),\n    panel_grid_major_y=element_line(color=string_color, size=2.2),\n    panel_grid_major_x=element_line(color=fret_color, size=2.2),\n    panel_grid_minor_x=element_line(color=fret_color, size=1),\n)\n\n(\n    ggplot(c_chord, aes(\"Fret\", \"String\"))\n    + geom_path(aes(color=\"Sequence\"), size=3)\n    + geom_point(aes(color=\"Sequence\"), fill=\"#FFFFFF\", size=3)\n    + geom_point(data=markings, fill=\"#000000\", size=4)\n    + scale_x_continuous(trans=frets_trans)\n    + scale_y_continuous(breaks=range(0, 7), minor_breaks=[])\n    + guides(color=False)\n    + neck_theme\n)\n\n\n\n\n\n\n\n\nCredit: This example was motivated by Jonathan Vitale who wanted to create graphics for a guitar scale trainer.\n\nSource: Guitar Neck ###"
  },
  {
    "objectID": "reference/scale_x_datetime.html",
    "href": "reference/scale_x_datetime.html",
    "title": " plotnine.scale_x_datetime",
    "section": "",
    "text": "scale_x_datetime(\n    date_breaks=None,\n    date_labels=None,\n    date_minor_breaks=None,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"datetime\"\n)"
  },
  {
    "objectID": "reference/scale_x_datetime.html#init-parameters",
    "href": "reference/scale_x_datetime.html#init-parameters",
    "title": " plotnine.scale_x_datetime",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ndate_breaks: str | None = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str | None = None\n\nFormat string for the labels. See strftime. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str | None = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks."
  },
  {
    "objectID": "reference/scale_x_datetime.html#parameter-attributes",
    "href": "reference/scale_x_datetime.html#parameter-attributes",
    "title": " plotnine.scale_x_datetime",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: ( # pyright: ignore[reportIncompatibleVariableOverride]    tuple[float, timedelta]    | tuple[float, timedelta, float, timedelta]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, timedelta(0)) - Do not expand.\n(0, timedelta(days=1)) - Expand lower and upper limits by 1 day.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, timedelta(hours=6)) - Expand upper limit by 6 hours.\n(0, timedelta(minutes=5), 0.1, timdelta(0)) - Expand lower limit by 5 minutes and upper limit by 10%.\n(0, 0, 0.1, timedelta(weeks=2)) - Expand upper limit by 10% plus 2 weeks.\n\nIf not specified, suitable defaults are chosen.\n\nguide: None = None\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"datetime\""
  },
  {
    "objectID": "reference/scale_x_log10.html",
    "href": "reference/scale_x_log10.html",
    "title": " plotnine.scale_x_log10",
    "section": "",
    "text": "scale_x_log10(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"log10\"\n)"
  },
  {
    "objectID": "reference/scale_x_log10.html#parameter-attributes",
    "href": "reference/scale_x_log10.html#parameter-attributes",
    "title": " plotnine.scale_x_log10",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: None = None\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"log10\""
  },
  {
    "objectID": "reference/scale_x_sqrt.html",
    "href": "reference/scale_x_sqrt.html",
    "title": " plotnine.scale_x_sqrt",
    "section": "",
    "text": "scale_x_sqrt(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"sqrt\"\n)"
  },
  {
    "objectID": "reference/scale_x_sqrt.html#parameter-attributes",
    "href": "reference/scale_x_sqrt.html#parameter-attributes",
    "title": " plotnine.scale_x_sqrt",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: None = None\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"sqrt\""
  },
  {
    "objectID": "reference/scale_x_timedelta.html",
    "href": "reference/scale_x_timedelta.html",
    "title": " plotnine.scale_x_timedelta",
    "section": "",
    "text": "scale_x_timedelta(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"pd_timedelta\"\n)"
  },
  {
    "objectID": "reference/scale_x_timedelta.html#parameter-attributes",
    "href": "reference/scale_x_timedelta.html#parameter-attributes",
    "title": " plotnine.scale_x_timedelta",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: None = None\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"pd_timedelta\""
  },
  {
    "objectID": "reference/scale_y_date.html",
    "href": "reference/scale_y_date.html",
    "title": " plotnine.scale_y_date",
    "section": "",
    "text": "scale_y_date(\n    date_breaks=None,\n    date_labels=None,\n    date_minor_breaks=None,\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"datetime\"\n)"
  },
  {
    "objectID": "reference/scale_y_date.html#init-parameters",
    "href": "reference/scale_y_date.html#init-parameters",
    "title": " plotnine.scale_y_date",
    "section": "Init Parameters",
    "text": "Init Parameters\n\n\ndate_breaks: str | None = None\n\nA string giving the distance between major breaks. For example '2 weeks', '5 years'. If specified, date_breaks takes precedence over breaks.\n\ndate_labels: str | None = None\n\nFormat string for the labels. See strftime. If specified, date_labels takes precedence over labels.\n\ndate_minor_breaks: str | None = None\n\nA string giving the distance between minor breaks. For example '2 weeks', '5 years'. If specified, date_minor_breaks takes precedence over minor_breaks."
  },
  {
    "objectID": "reference/scale_y_date.html#parameter-attributes",
    "href": "reference/scale_y_date.html#parameter-attributes",
    "title": " plotnine.scale_y_date",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: ( # pyright: ignore[reportIncompatibleVariableOverride]    tuple[float, timedelta]    | tuple[float, timedelta, float, timedelta]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, timedelta(0)) - Do not expand.\n(0, timedelta(days=1)) - Expand lower and upper limits by 1 day.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, timedelta(hours=6)) - Expand upper limit by 6 hours.\n(0, timedelta(minutes=5), 0.1, timdelta(0)) - Expand lower limit by 5 minutes and upper limit by 10%.\n(0, 0, 0.1, timedelta(weeks=2)) - Expand upper limit by 10% plus 2 weeks.\n\nIf not specified, suitable defaults are chosen.\n\nguide: None = None\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"datetime\""
  },
  {
    "objectID": "reference/scale_y_discrete.html",
    "href": "reference/scale_y_discrete.html",
    "title": " plotnine.scale_y_discrete",
    "section": "",
    "text": "scale_y_discrete(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=\"legend\",\n    na_value=np.nan,\n    aesthetics=(),\n    drop=True,\n    na_translate=True\n)"
  },
  {
    "objectID": "reference/scale_y_discrete.html#parameter-attributes",
    "href": "reference/scale_y_discrete.html#parameter-attributes",
    "title": " plotnine.scale_y_discrete",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: DiscreteBreaksUser = True\n\nList of major break points. Or a callable that takes a tuple of limits and returns a list of breaks. If True, automatically calculate the breaks.\n\nlimits: DiscreteLimitsUser = None\n\nLimits of the scale. These are the categories (unique values) of the variables. If is only a subset of the values, those that are left out will be treated as missing data and represented with a na_value.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: Literal[\"legend\"] | None = \"legend\"\n\n\n\nna_value: Any = np.nan\n\nIf na_translate=True, what aesthetic value should be assigned to the missing values. This parameter does not apply to position scales where nan is always placed on the right.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\ndrop: bool = True\n\nWhether to drop unused categories from the scale\n\nna_translate: bool = True\n\nIf True translate missing values and show them. If False remove missing values."
  },
  {
    "objectID": "reference/scale_y_reverse.html",
    "href": "reference/scale_y_reverse.html",
    "title": " plotnine.scale_y_reverse",
    "section": "",
    "text": "scale_y_reverse(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"reverse\"\n)"
  },
  {
    "objectID": "reference/scale_y_reverse.html#parameter-attributes",
    "href": "reference/scale_y_reverse.html#parameter-attributes",
    "title": " plotnine.scale_y_reverse",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: None = None\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"reverse\""
  },
  {
    "objectID": "reference/scale_y_symlog.html",
    "href": "reference/scale_y_symlog.html",
    "title": " plotnine.scale_y_symlog",
    "section": "",
    "text": "scale_y_symlog(\n    *,\n    name=None,\n    breaks=True,\n    limits=None,\n    labels=True,\n    expand=None,\n    guide=None,\n    na_value=np.nan,\n    aesthetics=(),\n    rescaler=rescale,\n    oob=censor,\n    minor_breaks=True,\n    trans=\"symlog\"\n)"
  },
  {
    "objectID": "reference/scale_y_symlog.html#parameter-attributes",
    "href": "reference/scale_y_symlog.html#parameter-attributes",
    "title": " plotnine.scale_y_symlog",
    "section": "Parameter Attributes",
    "text": "Parameter Attributes\n\n\nname: str | None = None\n\nThe name of the scale. It is used as the label of the axis or the title of the guide. Suitable defaults are chosen depending on the type of scale.\n\nbreaks: ContinuousBreaksUser = True\n\nMajor breaks\n\nlimits: ContinuousLimitsUser = None\n\nLimits of the scale. Most commonly, these are the minimum & maximum values for the scale. If not specified they are derived from the data. It may also be a function that takes the derived limits and transforms them into the final limits.\n\nlabels: ScaleLabelsUser = True\n\nLabels at the breaks. Alternatively, a callable that takes an array_like of break points as input and returns a list of strings.\n\nexpand: (    tuple[float, float]    | tuple[float, float, float, float]    | None) = None\n\nMultiplicative and additive expansion constants that determine how the scale is expanded. If specified must be of length 2 or 4. Specifically the values are in this order:\n(mul, add)\n(mul_low, add_low, mul_high, add_high)\nFor example,\n\n(0, 0) - Do not expand.\n(0, 1) - Expand lower and upper limits by 1 unit.\n(1, 0) - Expand lower and upper limits by 100%.\n(0, 0, 0, 0) - Do not expand, as (0, 0).\n(0, 0, 0, 1) - Expand upper limit by 1 unit.\n(0, 1, 0.1, 0) - Expand lower limit by 1 unit and upper limit by 10%.\n(0, 0, 0.1, 2) - Expand upper limit by 10% plus 2 units.\n\nIf not specified, suitable defaults are chosen.\n\nguide: None = None\n\n\n\nna_value: Any = np.nan\n\nWhat value to assign to missing values. Default is to assign np.nan.\n\naesthetics: Sequence[ScaledAestheticsName] = ()\n\nAesthetics affected by this scale. These are defined by each scale and the user should probably not change them. Have fun.\n\nrescaler: PRescale = rescale\n\nFunction to rescale data points so that they can be handled by the palette. Default is to rescale them onto the [0, 1] range. Scales that inherit from this class may have another default.\n\noob: PCensor = censor\n\nFunction to deal with out of bounds (limits) data points. Default is to turn them into np.nan, which then get dropped.\n\nminor_breaks: MinorBreaksUser = True\n\nIf a list-like, it is the minor breaks points. If an integer, it is the number of minor breaks between any set of major breaks. If a function, it should have the signature func(limits) and return a list-like of consisting of the minor break points. If None, no minor breaks are calculated. The default is to automatically calculate them.\n\ntrans: TransUser = \"symlog\""
  },
  {
    "objectID": "reference/scales._runtime_typing.html",
    "href": "reference/scales._runtime_typing.html",
    "title": "Typing Information",
    "section": "",
    "text": "TypeVar(\"RangeT\", bound=Range)\n\n\n\n\n\nTypeVar(\"BreaksUserT\")\n\n\n\n\n\nTypeVar(\"LimitsUserT\")\n\n\n\n\n\nTypeVar(\"GuideTypeT\")"
  },
  {
    "objectID": "reference/scales._runtime_typing.html#type-variables",
    "href": "reference/scales._runtime_typing.html#type-variables",
    "title": "Typing Information",
    "section": "",
    "text": "TypeVar(\"RangeT\", bound=Range)\n\n\n\n\n\nTypeVar(\"BreaksUserT\")\n\n\n\n\n\nTypeVar(\"LimitsUserT\")\n\n\n\n\n\nTypeVar(\"GuideTypeT\")"
  },
  {
    "objectID": "reference/scales._runtime_typing.html#type-aliases",
    "href": "reference/scales._runtime_typing.html#type-aliases",
    "title": "Typing Information",
    "section": "Type Aliases",
    "text": "Type Aliases\n\n DiscreteBreaksUser\n\n(    bool    | None    | Sequence[str]    | Callable[[Sequence[str]], Sequence[str]])\n\n\n\n DiscreteLimitsUser\n\n(    None    | Sequence[str]    | Callable[[Sequence[str]], Sequence[str]])\n\n\n\n ContinuousBreaksUser\n\n(    bool    | None    | Sequence[float]    | Callable[[tuple[float, float]], Sequence[float]])\n\n\n\n MinorBreaksUser\n\nContinuousBreaksUser\n\n\n\n ContinuousLimitsUser\n\n(    None    | tuple[float, float]    | Callable[[tuple[float, float]], tuple[float, float]])\n\n\n\n ScaleLabelsUser\n\n(    bool    | None    | Sequence[str]    | Callable[[Sequence[float] | Sequence[str]], Sequence[str]]    | dict[str, str])\n\n\n\n TransUser\n\ntrans | str | Type[trans] | None"
  },
  {
    "objectID": "reference/set_option.html",
    "href": "reference/set_option.html",
    "title": " plotnine.options.set_option",
    "section": "",
    "text": "set_option(name, value)"
  },
  {
    "objectID": "reference/set_option.html#parameters",
    "href": "reference/set_option.html#parameters",
    "title": " plotnine.options.set_option",
    "section": "Parameters",
    "text": "Parameters\n\n\nname : str\n\nName of the option\n\nvalue : Any\n\nNew value of the option"
  },
  {
    "objectID": "reference/set_option.html#returns",
    "href": "reference/set_option.html#returns",
    "title": " plotnine.options.set_option",
    "section": "Returns",
    "text": "Returns\n\n\nAny\n\nOld value of the option"
  },
  {
    "objectID": "reference/set_option.html#notes",
    "href": "reference/set_option.html#notes",
    "title": " plotnine.options.set_option",
    "section": "Notes",
    "text": "Notes\nSee reference for a list of all the available options."
  },
  {
    "objectID": "reference/stat.html",
    "href": "reference/stat.html",
    "title": " plotnine.stats.stat.stat",
    "section": "",
    "text": "stat(mapping=None, data=None, kwargs={})"
  },
  {
    "objectID": "reference/stat.html#attributes",
    "href": "reference/stat.html#attributes",
    "title": " plotnine.stats.stat.stat",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nCREATES\nset() -&gt; new empty set object\n\n\nDEFAULT_AES\ndict() -&gt; new empty dictionary\n\n\nDEFAULT_PARAMS\ndict() -&gt; new empty dictionary\n\n\nNON_MISSING_AES\nset() -&gt; new empty set object\n\n\nREQUIRED_AES\nset() -&gt; new empty set object\n\n\n\n\n CREATES\n\nCREATES : set[str] = set()\n\n\nset() -&gt; new empty set object set(iterable) -&gt; new set object\nBuild an unordered collection of unique elements.\n\n\n\n DEFAULT_AES\n\nDEFAULT_AES : dict[str, Any] = aes(**self.DEFAULT_AES)\n\n\ndict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object’s (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)\n\n\n\n DEFAULT_PARAMS\n\nDEFAULT_PARAMS : dict[str, Any] = {}\n\n\ndict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object’s (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)\n\n\n\n NON_MISSING_AES\n\nNON_MISSING_AES : set[str] = set()\n\n\nset() -&gt; new empty set object set(iterable) -&gt; new set object\nBuild an unordered collection of unique elements.\n\n\n\n REQUIRED_AES\n\nREQUIRED_AES : set[str] = set()\n\n\nset() -&gt; new empty set object set(iterable) -&gt; new set object\nBuild an unordered collection of unique elements."
  },
  {
    "objectID": "reference/stat.html#methods",
    "href": "reference/stat.html#methods",
    "title": " plotnine.stats.stat.stat",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\naesthetics\nReturn a set of all non-computed aesthetics for this stat.\n\n\ncompute_group\nCalculate statistics for the group\n\n\ncompute_layer\nCalculate statistics for this layers\n\n\ncompute_panel\nCalculate the statistics for all the groups\n\n\nfinish_layer\nModify data after the aesthetics have been mapped\n\n\nfrom_geom\nReturn an instantiated stat object\n\n\nsetup_data\nOverride to modify data before compute_layer is called\n\n\nsetup_params\nOverride this to verify or adjust parameters\n\n\nto_layer\nMake a layer that represents this stat\n\n\nuse_defaults\nCombine data with defaults and set aesthetics from parameters\n\n\n\n\n aesthetics \n\naesthetics()\n\n\nReturn a set of all non-computed aesthetics for this stat.\nstats should not override this method.\n\n\n\n compute_group \n\ncompute_group(data, scales, params={})\n\n\nCalculate statistics for the group\nAll stats should implement this method\n\n\nParameters\n\n\ndata : pd.DataFrame\n\nData for a group\n\nscales : pos_scales\n\nx (scales.x) and y (scales.y) scale objects. The most likely reason to use scale information is to find out the physical size of a scale. e.g.\nrange_x = scales.x.dimension()\n\nparams : Any = {}\n\nParameters\n\n\n\n\n\n\n compute_layer \n\ncompute_layer(data, params, layout)\n\n\nCalculate statistics for this layers\nThis is the top-most computation method for the stat. It does not do any computations, but it knows how to verify the data, partition it call the next computation method and merge results.\nstats should not override this method.\n\n\nParameters\n\n\ndata : pd.DataFrame\n\nData points for all objects in a layer.\n\nparams : dict[str, Any]\n\nStat parameters\n\nlayout : Layout\n\nPanel layout information\n\n\n\n\n\n\n compute_panel \n\ncompute_panel(data, scales, params={})\n\n\nCalculate the statistics for all the groups\nReturn the results in a single dataframe.\nThis is a default function that can be overridden by individual stats\n\n\nParameters\n\n\ndata : pd.DataFrame\n\ndata for the computing\n\nscales : pos_scales\n\nx (scales.x) and y (scales.y) scale objects. The most likely reason to use scale information is to find out the physical size of a scale. e.g.\nrange_x = scales.x.dimension()\n\nparams : Any = {}\n\nThe parameters for the stat. It includes default values if user did not set a particular parameter.\n\n\n\n\n\n\n finish_layer\n\nfinish_layer(data, params)\n\n\nModify data after the aesthetics have been mapped\nThis can be used by stats that require access to the mapped values of the computed aesthetics, part 3 as shown below.\n1. stat computes and creates variables\n2. variables mapped to aesthetics\n3. stat sees and modifies data according to the\n   aesthetic values\nThe default to is to do nothing.\n\n\nParameters\n\n\ndata : pd.DataFrame\n\nData for the layer\n\nparams : dict[str, Any]\n\nParameters\n\n\n\n\n\nReturns\n\n\ndata : pd.DataFrame\n\nModified data\n\n\n\n\n\n\n from_geom \n\nfrom_geom(geom)\n\n\nReturn an instantiated stat object\nstats should not override this method.\n\n\nParameters\n\n\ngeom : geom\n\nA geom object\n\n\n\n\n\nReturns\n\n\nstat\n\nA stat object\n\n\n\n\n\nRaises\n\n\nPlotnineError if unable to create a stat.\n\n\n\n\n\n\n\n\n setup_data\n\nsetup_data(data)\n\n\nOverride to modify data before compute_layer is called\n\n\nParameters\n\n\ndata : pd.DataFrame\n\nData\n\n\n\n\n\nReturns\n\n\nout : pd.DataFrame\n\nData\n\n\n\n\n\n\n setup_params\n\nsetup_params(data)\n\n\nOverride this to verify or adjust parameters\n\n\nParameters\n\n\ndata : pd.DataFrame\n\nData\n\n\n\n\n\nReturns\n\n\nout : dict[str, Any]\n\nParameters used by the stats.\n\n\n\n\n\n\n to_layer\n\nto_layer()\n\n\nMake a layer that represents this stat\n\n\nReturns\n\n\nout : layer\n\nLayer\n\n\n\n\n\n\n use_defaults\n\nuse_defaults(data)\n\n\nCombine data with defaults and set aesthetics from parameters\nstats should not override this method.\n\n\nParameters\n\n\ndata : pd.DataFrame\n\nData used for drawing the geom.\n\n\n\n\n\nReturns\n\n\nout : pd.DataFrame\n\nData used for drawing the geom."
  },
  {
    "objectID": "reference/stat_bin_2d.html",
    "href": "reference/stat_bin_2d.html",
    "title": " plotnine.stat_bin_2d",
    "section": "",
    "text": "stat_bin_2d(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"rect\",\n    position=\"identity\",\n    na_rm=False,\n    bins=30,\n    breaks=None,\n    binwidth=None,\n    drop=True,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_bin_2d.html#parameters",
    "href": "reference/stat_bin_2d.html#parameters",
    "title": " plotnine.stat_bin_2d",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nfill\nafter_stat('count')\n\n\nweight\nNone\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"xmin\"    # x lower bound for the bin\n\"xmax\"    # x upper bound for the bin\n\"ymin\"    # y lower bound for the bin\n\"ymax\"    # y upper bound for the bin\n\"count\"   # number of points in bin\n\"density\" # density of points in bin, scaled to integrate to 1\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"rect\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nbins : int = 30\n\nNumber of bins. Overridden by binwidth.\n\nbreaks : array_like | tuple[array_like, array_like] = None\n\nBin boundaries. This supersedes the binwidth, bins, center and boundary. It can be an array_like or a list of two array_likes to provide distinct breaks for the x and y axes.\n\nbinwidth : float = None\n\nThe width of the bins. The default is to use bins bins that cover the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data.\n\ndrop : bool = False\n\nIf True, removes all cells with zero counts.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_boxplot.html",
    "href": "reference/stat_boxplot.html",
    "title": " plotnine.stat_boxplot",
    "section": "",
    "text": "stat_boxplot(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"boxplot\",\n    position=\"dodge\",\n    na_rm=False,\n    coef=1.5,\n    width=None,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_boxplot.html#parameters",
    "href": "reference/stat_boxplot.html#parameters",
    "title": " plotnine.stat_boxplot",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"width\"  # width of boxplot\n\"lower\"  # lower hinge, 25% quantile\n\"middle\" # median, 50% quantile\n\"upper\"  # upper hinge, 75% quantile\n\n# lower edge of notch, computed as;\n# median - 1.58 * IQR / sqrt(n)\n\"notchlower\"\n\n# upper edge of notch, computed as;\n# median + 1.58 * IQR / sqrt(n)\n\"notchupper\"\n\n# lower whisker, computed as; smallest observation\n# greater than or equal to lower hinge - 1.5 * IQR\n\"ymin\"\n\n# upper whisker, computed as; largest observation\n# less than or equal to upper hinge + 1.5 * IQR\n\"ymax\"\n'n'     # Number of observations at a position\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('width').\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"boxplot\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"dodge\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ncoef : float = 1.5\n\nLength of the whiskers as a multiple of the Interquartile Range.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_boxplot.html#see-also",
    "href": "reference/stat_boxplot.html#see-also",
    "title": " plotnine.stat_boxplot",
    "section": "See Also",
    "text": "See Also\n\ngeom_boxplot"
  },
  {
    "objectID": "reference/stat_density.html",
    "href": "reference/stat_density.html",
    "title": " plotnine.stat_density",
    "section": "",
    "text": "stat_density(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"density\",\n    position=\"stack\",\n    na_rm=False,\n    kernel=\"gaussian\",\n    adjust=1,\n    trim=False,\n    n=1024,\n    gridsize=None,\n    bw=\"nrd0\",\n    cut=3,\n    clip=(-inf, inf),\n    bounds=(-inf, inf),\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_density.html#parameters",
    "href": "reference/stat_density.html#parameters",
    "title": " plotnine.stat_density",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\nafter_stat('density')\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n'density'   # density estimate\n\n'count'     # density * number of points,\n            # useful for stacked density plots\n\n'scaled'    # density estimate, scaled to maximum of 1\n'n'         # Number of observations at a position\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"density\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"stack\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nkernel : str = \"gaussian\"\n\nKernel used for density estimation. One of:\n\"biweight\"\n\"cosine\"\n\"cosine2\"\n\"epanechnikov\"\n\"gaussian\"\n\"triangular\"\n\"triweight\"\n\"uniform\"\n\nadjust : float = 1\n\nAn adjustment factor for the bw. Bandwidth becomes bw * adjust. Adjustment of the bandwidth.\n\ntrim : bool = False\n\nThis parameter only matters if you are displaying multiple densities in one plot. If False, the default, each density is computed on the full range of the data. If True, each density is computed over the range of that group; this typically means the estimated x values will not line-up, and hence you won’t be able to stack density values.\n\nn : int = 1024\n\nNumber of equally spaced points at which the density is to be estimated. For efficient computation, it should be a power of two.\n\ngridsize : int = None\n\nIf gridsize is None, max(len(x), 50) is used.\n\nbw : str | float = \"nrd0\"\n\nThe bandwidth to use, If a float is given, it is the bandwidth. The options are:\n\"nrd0\"\n\"normal_reference\"\n\"scott\"\n\"silverman\"\nnrd0 is a port of stats::bw.nrd0 in R; it is eqiuvalent to silverman when there is more than 1 value in a group.\n\ncut : float = 3\n\nDefines the length of the grid past the lowest and highest values of x so that the kernel goes to zero. The end points are -/+ cut*bw*{min(x) or max(x)}.\n\nclip : tuple[float, float] = (-inf, inf)\n\nValues in x that are outside of the range given by clip are dropped. The number of values in x is then shortened.\n\nbounds\n\nThe domain boundaries of the data. When the domain is finite the estimated density will be corrected to remove asymptotic boundary effects that are usually biased away from the probability density function being estimated.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_density.html#see-also",
    "href": "reference/stat_density.html#see-also",
    "title": " plotnine.stat_density",
    "section": "See Also",
    "text": "See Also\n\ngeom_density\n\n\n\nKDEUnivariate\n\n\n\nfit"
  },
  {
    "objectID": "reference/stat_ecdf.html",
    "href": "reference/stat_ecdf.html",
    "title": " plotnine.stat_ecdf",
    "section": "",
    "text": "stat_ecdf(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"step\",\n    position=\"identity\",\n    na_rm=False,\n    n=None,\n    pad=True,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_ecdf.html#parameters",
    "href": "reference/stat_ecdf.html#parameters",
    "title": " plotnine.stat_ecdf",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\nafter_stat('ecdf')\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"x\"     # x in the data\n\"ecdf\"  # cumulative density corresponding to x\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"step\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nn\n\nThis is the number of points to interpolate with. If None, do not interpolate.\n\npad : bool = True\n\nIf True, pad the domain with -inf and +inf so that ECDF does not have discontinuities at the extremes.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_ecdf.html#see-also",
    "href": "reference/stat_ecdf.html#see-also",
    "title": " plotnine.stat_ecdf",
    "section": "See Also",
    "text": "See Also\n\ngeom_step"
  },
  {
    "objectID": "reference/stat_function.html",
    "href": "reference/stat_function.html",
    "title": " plotnine.stat_function",
    "section": "",
    "text": "stat_function(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"path\",\n    position=\"identity\",\n    na_rm=False,\n    fun=None,\n    n=101,\n    args=None,\n    xlim=None,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_function.html#parameters",
    "href": "reference/stat_function.html#parameters",
    "title": " plotnine.stat_function",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\ny\nafter_stat('fx')\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"x\"   # x points at which the function is evaluated\n\"fx\"  # points evaluated at each x\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"path\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nfun : callable\n\nFunction to evaluate.\n\nn : int = 101\n\nNumber of points at which to evaluate the function.\n\nxlim : tuple = None\n\nx limits for the range. The default depends on the x aesthetic. There is not an x aesthetic then the xlim must be provided.\n\nargs : Optional[tuple[Any] | dict[str, Any]] = None\n\nArguments to pass to fun.\n\n**kwargs = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_identity.html",
    "href": "reference/stat_identity.html",
    "title": " plotnine.stat_identity",
    "section": "",
    "text": "stat_identity(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"point\",\n    position=\"identity\",\n    na_rm=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_identity.html#parameters",
    "href": "reference/stat_identity.html#parameters",
    "title": " plotnine.stat_identity",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\n\n\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"point\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_qq_line.html",
    "href": "reference/stat_qq_line.html",
    "title": " plotnine.stat_qq_line",
    "section": "",
    "text": "stat_qq_line(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"qq_line\",\n    position=\"identity\",\n    na_rm=False,\n    distribution=\"norm\",\n    dparams={},\n    quantiles=None,\n    alpha_beta=(0.375, 0.375),\n    line_p=(0.25, 0.75),\n    fullrange=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_qq_line.html#parameters",
    "href": "reference/stat_qq_line.html#parameters",
    "title": " plotnine.stat_qq_line",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nsample\n\n\n\n\nThe bold aesthetics are required.\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"qq_line\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\ndistribution : str = \"norm\"\n\nDistribution or distribution function name. The default is norm for a normal probability plot. Objects that look enough like a stats.distributions instance (i.e. they have a ppf method) are also accepted. See scipy stats for available distributions.\n\ndparams : dict = None\n\nDistribution-specific shape parameters (shape parameters plus location and scale).\n\nquantiles : array_like = None\n\nProbability points at which to calculate the theoretical quantile values. If provided, must be the same number as as the sample data points. The default is to use calculated theoretical points, use to alpha_beta control how these points are generated.\n\nalpha_beta : tuple = (3/8, 3/8)\n\nParameter values to use when calculating the quantiles.\n\nline_p : tuple = (0.25, 0.75)\n\nQuantiles to use when fitting a Q-Q line. Must be 2 values.\n\nfullrange : bool = False\n\nIf True the fit will span the full range of the plot.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_qq_line.html#see-also",
    "href": "reference/stat_qq_line.html#see-also",
    "title": " plotnine.stat_qq_line",
    "section": "See Also",
    "text": "See Also\n\nplotting_positions\n\nUses alpha_beta to calculate the quantiles."
  },
  {
    "objectID": "reference/stat_sina.html",
    "href": "reference/stat_sina.html",
    "title": " plotnine.stat_sina",
    "section": "",
    "text": "stat_sina(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"sina\",\n    position=\"dodge\",\n    na_rm=False,\n    binwidth=None,\n    bins=None,\n    method=\"density\",\n    bw=\"nrd0\",\n    maxwidth=None,\n    adjust=1,\n    bin_limit=1,\n    random_state=None,\n    scale=\"area\",\n    style=\"full\",\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_sina.html#parameters",
    "href": "reference/stat_sina.html#parameters",
    "title": " plotnine.stat_sina",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"quantile\"  # quantile\n\"group\"     # group identifier\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('quantile').\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"sina\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"dodge\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nbinwidth : float = None\n\nThe width of the bins. The default is to use bins that cover the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data.\n\nbins : int = 50\n\nNumber of bins. Overridden by binwidth.\n\nmethod : Literal[density, counts] = \"density\"\n\nChoose the method to spread the samples within the same bin along the x-axis. Available methods: “density”, “counts” (can be abbreviated, e.g. “d”). See Details.\n\nmaxwidth : float = None\n\nControl the maximum width the points can spread into. Values should be in the range (0, 1).\n\nadjust : float = 1\n\nAdjusts the bandwidth of the density kernel when method=\"density\". see stat_density.\n\nbw : str | float = \"nrd0\"\n\nThe bandwidth to use, If a float is given, it is the bandwidth. The str choices are: \"nrd0\", \"normal_reference\", \"scott\", \"silverman\"\nnrd0 is a port of stats::bw.nrd0 in R; it is eqiuvalent to silverman when there is more than 1 value in a group.\n\nbin_limit : int = 1\n\nIf the samples within the same y-axis bin are more than bin_limit, the samples’s X coordinates will be adjusted. This parameter is effective only when method=\"counts\"\n\nrandom_state : int | RandomState = None\n\nSeed or Random number generator to use. If None, then numpy global generator numpy.random is used.\n\nscale : Literal[area, count, width] = \"area\"\n\nHow to scale the sina groups.\n\narea - Scale by the largest density/bin among the different sinas\ncount - areas are scaled proportionally to the number of points\nwidth - Only scale according to the maxwidth parameter.\n\n\nstyle\n\nType of sina plot to draw. The options are\n'full'        # Regular (2 sided)\n'left'        # Left-sided half\n'right'       # Right-sided half\n'left-right'  # Alternate (left first) half by the group\n'right-left'  # Alternate (right first) half by the group\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_sina.html#see-also",
    "href": "reference/stat_sina.html#see-also",
    "title": " plotnine.stat_sina",
    "section": "See Also",
    "text": "See Also\n\ngeom_sina"
  },
  {
    "objectID": "reference/stat_sum.html",
    "href": "reference/stat_sum.html",
    "title": " plotnine.stat_sum",
    "section": "",
    "text": "stat_sum(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"point\",\n    position=\"identity\",\n    na_rm=False,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_sum.html#parameters",
    "href": "reference/stat_sum.html#parameters",
    "title": " plotnine.stat_sum",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nsize\nafter_stat('n')\n\n\nweight\n1\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"n\"     # Number of observations at a position\n\"prop\"  # Ratio of points in that panel at a position\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"point\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_summary_bin.html",
    "href": "reference/stat_summary_bin.html",
    "title": " plotnine.stat_summary_bin",
    "section": "",
    "text": "stat_summary_bin(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"pointrange\",\n    position=\"identity\",\n    na_rm=False,\n    bins=30,\n    breaks=None,\n    binwidth=None,\n    boundary=None,\n    fun_data=None,\n    fun_y=None,\n    fun_ymin=None,\n    fun_ymax=None,\n    fun_args=None,\n    random_state=None,\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_summary_bin.html#parameters",
    "href": "reference/stat_summary_bin.html#parameters",
    "title": " plotnine.stat_summary_bin",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"bin\"    # bin identifier\n\"width\"  # bin width\n\"ymin\"   # ymin computed by the summary function\n\"ymax\"   # ymax computed by the summary function\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('ymin').\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"pointrange\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"identity\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nbinwidth : float | tuple = None\n\nThe width of the bins. The default is to use bins bins that cover the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data.\n\nbins : int | tuple = 30\n\nNumber of bins. Overridden by binwidth.\n\nbreaks : array_like | tuple[array_like, array_like] = None\n\nBin boundaries. This supersedes the binwidth, bins and boundary arguments.\n\nboundary : float | tuple = None\n\nA boundary between two bins. As with center, things are shifted when boundary is outside the range of the data. For example, to center on integers, use width=1 and boundary=0.5, even if 1 is outside the range of the data. At most one of center and boundary may be specified.\n\nfun_data : str | callable = \"mean_se\"\n\nIf a string, should be one of mean_cl_boot, mean_cl_normal, mean_sdl, median_hilow, mean_se. If a function, it should that takes an array and return a dataframe with three rows indexed as y, ymin and ymax.\n\nfun_y : callable = None\n\nA function that takes an array_like and returns a single value\n\nfun_ymax : callable = None\n\nA function that takes an array_like and returns a single value\n\nfun_args : dict = None\n\nArguments to any of the functions. Provided the names of the arguments of the different functions are in not conflict, the arguments will be assigned to the right functions. If there is a conflict, create a wrapper function that resolves the ambiguity in the argument names.\n\nrandom_state : int | RandomState = None\n\nSeed or Random number generator to use. If None, then numpy global generator numpy.random is used.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_summary_bin.html#notes",
    "href": "reference/stat_summary_bin.html#notes",
    "title": " plotnine.stat_summary_bin",
    "section": "Notes",
    "text": "Notes\nThe binwidth, bins, breaks and boundary arguments can be a tuples with two values (xaxis-value, yaxis-value) of the required type."
  },
  {
    "objectID": "reference/stat_summary_bin.html#see-also",
    "href": "reference/stat_summary_bin.html#see-also",
    "title": " plotnine.stat_summary_bin",
    "section": "See Also",
    "text": "See Also\n\ngeom_pointrange"
  },
  {
    "objectID": "reference/stat_ydensity.html",
    "href": "reference/stat_ydensity.html",
    "title": " plotnine.stat_ydensity",
    "section": "",
    "text": "stat_ydensity(\n    mapping=None,\n    data=None,\n    *,\n    geom=\"violin\",\n    position=\"dodge\",\n    na_rm=False,\n    adjust=1,\n    kernel=\"gaussian\",\n    n=1024,\n    trim=True,\n    bw=\"nrd0\",\n    scale=\"area\",\n    **kwargs\n)"
  },
  {
    "objectID": "reference/stat_ydensity.html#parameters",
    "href": "reference/stat_ydensity.html#parameters",
    "title": " plotnine.stat_ydensity",
    "section": "Parameters",
    "text": "Parameters\n\n\nmapping : aes = None\n\nAesthetic mappings created with aes. If specified and inherit_aes=True, it is combined with the default mapping for the plot. You must supply mapping if there is no plot mapping.\n\n\n\n\n\n\n\nAesthetic\nDefault value\n\n\n\n\nx\n\n\n\ny\n\n\n\nweight\nNone\n\n\n\nThe bold aesthetics are required.\nOptions for computed aesthetics\n\"width\"        # Maximum width of density, [0, 1] range.\n\"violinwidth\"  # Shape of the violin\nCalculated aesthetics are accessed using the after_stat function. e.g. after_stat('width').\n\ndata : DataFrame = None\n\nThe data to be displayed in this layer. If None, the data from from the ggplot() call is used. If specified, it overrides the data from the ggplot() call.\n\ngeom : str | geom = \"violin\"\n\nThe statistical transformation to use on the data for this layer. If it is a string, it must be the registered and known to Plotnine.\n\nposition : str | position = \"dodge\"\n\nPosition adjustment. If it is a string, it must be registered and known to Plotnine.\n\nna_rm : bool = False\n\nIf False, removes missing values with a warning. If True silently removes missing values.\n\nkernel : str = \"gaussian\"\n\nKernel used for density estimation. One of:\n\"biweight\"\n\"cosine\"\n\"cosine2\"\n\"epanechnikov\"\n\"gaussian\"\n\"triangular\"\n\"triweight\"\n\"uniform\"\n\nadjust : float = 1\n\nAn adjustment factor for the bw. Bandwidth becomes bw * adjust. Adjustment of the bandwidth.\n\ntrim : bool = False\n\nThis parameter only matters if you are displaying multiple densities in one plot. If False, the default, each density is computed on the full range of the data. If True, each density is computed over the range of that group; this typically means the estimated x values will not line-up, and hence you won’t be able to stack density values.\n\nn : int = 1024\n\nNumber of equally spaced points at which the density is to be estimated. For efficient computation, it should be a power of two.\n\nbw : str | float = \"nrd0\"\n\nThe bandwidth to use, If a float is given, it is the bandwidth. The str choices are:\n\"nrd0\"\n\"normal_reference\"\n\"scott\"\n\"silverman\"\nnrd0 is a port of stats::bw.nrd0 in R; it is eqiuvalent to silverman when there is more than 1 value in a group.\n\nscale : Literal[area, count, width] = \"area\"\n\nHow to scale the violins. The options are: If area all violins have the same area, before trimming the tails. If count the areas are scaled proportionally to the number of observations. If width all violins have the same maximum width.\n\n**kwargs : Any = {}\n\nAesthetics or parameters used by the geom."
  },
  {
    "objectID": "reference/stat_ydensity.html#see-also",
    "href": "reference/stat_ydensity.html#see-also",
    "title": " plotnine.stat_ydensity",
    "section": "See Also",
    "text": "See Also\n\ngeom_violin\n\n\n\nKDEUnivariate\n\n\n\nfit"
  },
  {
    "objectID": "reference/strip_align_x.html",
    "href": "reference/strip_align_x.html",
    "title": " plotnine.themes.themeable.strip_align_x",
    "section": "",
    "text": "strip_align_x(theme_element)"
  },
  {
    "objectID": "reference/strip_align_x.html#parameters",
    "href": "reference/strip_align_x.html#parameters",
    "title": " plotnine.themes.themeable.strip_align_x",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : float\n\nValue as a proportion of the strip size. A good value should be the range [-1, 0.5]. A negative value puts the strip inside the axes. A positive value creates a margin between the strip and the axes. 0 puts the strip on top of the panels."
  },
  {
    "objectID": "reference/strip_background.html",
    "href": "reference/strip_background.html",
    "title": " plotnine.themes.themeable.strip_background",
    "section": "",
    "text": "strip_background(theme_element)"
  },
  {
    "objectID": "reference/strip_background.html#parameters",
    "href": "reference/strip_background.html#parameters",
    "title": " plotnine.themes.themeable.strip_background",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_rect"
  },
  {
    "objectID": "reference/strip_background_y.html",
    "href": "reference/strip_background_y.html",
    "title": " plotnine.themes.themeable.strip_background_y",
    "section": "",
    "text": "strip_background_y(theme_element)"
  },
  {
    "objectID": "reference/strip_background_y.html#parameters",
    "href": "reference/strip_background_y.html#parameters",
    "title": " plotnine.themes.themeable.strip_background_y",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_rect"
  },
  {
    "objectID": "reference/strip_text_x.html",
    "href": "reference/strip_text_x.html",
    "title": " plotnine.themes.themeable.strip_text_x",
    "section": "",
    "text": "strip_text_x(theme_element)"
  },
  {
    "objectID": "reference/strip_text_x.html#parameters",
    "href": "reference/strip_text_x.html#parameters",
    "title": " plotnine.themes.themeable.strip_text_x",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/subplots_adjust.html",
    "href": "reference/subplots_adjust.html",
    "title": " plotnine.themes.themeable.subplots_adjust",
    "section": "",
    "text": "subplots_adjust(theme_element)"
  },
  {
    "objectID": "reference/text.html",
    "href": "reference/text.html",
    "title": " plotnine.themes.themeable.text",
    "section": "",
    "text": "text(theme_element)"
  },
  {
    "objectID": "reference/text.html#parameters",
    "href": "reference/text.html#parameters",
    "title": " plotnine.themes.themeable.text",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/theme_538.html",
    "href": "reference/theme_538.html",
    "title": " plotnine.theme_538",
    "section": "",
    "text": "theme_538(base_size=11, base_family=\"DejaVu Sans\")"
  },
  {
    "objectID": "reference/theme_538.html#parameters",
    "href": "reference/theme_538.html#parameters",
    "title": " plotnine.theme_538",
    "section": "Parameters",
    "text": "Parameters\n\n\nbase_size : int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family : str = \"DejaVu Sans\"\n\nBase font family."
  },
  {
    "objectID": "reference/theme_classic.html",
    "href": "reference/theme_classic.html",
    "title": " plotnine.theme_classic",
    "section": "",
    "text": "theme_classic(base_size=11, base_family=None)"
  },
  {
    "objectID": "reference/theme_classic.html#parameters",
    "href": "reference/theme_classic.html#parameters",
    "title": " plotnine.theme_classic",
    "section": "Parameters",
    "text": "Parameters\n\n\nbase_size : int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family : str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_classic.html#examples",
    "href": "reference/theme_classic.html#examples",
    "title": " plotnine.theme_classic",
    "section": "Examples",
    "text": "Examples\n\n\nfrom plotnine import ggplot, aes, labs, theme_classic, geom_point\nfrom plotnine.data import mtcars\n\n\nClassic\n\n# Gallery, themes\n(\n    ggplot(mtcars, aes(x=\"wt\", y=\"mpg\", colour=\"factor(gear)\"))\n    + geom_point()\n    + labs(\n        title= \"Fuel economy declines as weight increases\",\n        subtitle=\"(1973-74)\",\n        caption=\"Data from the 1974 Motor Trend US magazine.\",\n        x=\"Weight (1000 lbs)\",\n        y=\"Fuel economy (mpg)\",\n        colour=\"Gears\"\n    )\n    + theme_classic()\n)\n\n\n\n\n\n\n\n\n\nSource: Classic"
  },
  {
    "objectID": "reference/theme_get.html",
    "href": "reference/theme_get.html",
    "title": " plotnine.theme_get",
    "section": "",
    "text": "theme_get()\n\n\nReturn the default theme\nThe default theme is the one set (using theme_set) by the user. If none has been set, then theme_gray is the default."
  },
  {
    "objectID": "reference/theme_grey.html",
    "href": "reference/theme_grey.html",
    "title": " plotnine.theme_grey",
    "section": "",
    "text": "theme_grey(base_size=11, base_family=None)\n\n\nalias of theme_gray"
  },
  {
    "objectID": "reference/theme_linedraw.html",
    "href": "reference/theme_linedraw.html",
    "title": " plotnine.theme_linedraw",
    "section": "",
    "text": "theme_linedraw(base_size=11, base_family=None)"
  },
  {
    "objectID": "reference/theme_linedraw.html#parameters",
    "href": "reference/theme_linedraw.html#parameters",
    "title": " plotnine.theme_linedraw",
    "section": "Parameters",
    "text": "Parameters\n\n\nbase_size : int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family : str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_minimal.html",
    "href": "reference/theme_minimal.html",
    "title": " plotnine.theme_minimal",
    "section": "",
    "text": "theme_minimal(base_size=11, base_family=None)"
  },
  {
    "objectID": "reference/theme_minimal.html#parameters",
    "href": "reference/theme_minimal.html#parameters",
    "title": " plotnine.theme_minimal",
    "section": "Parameters",
    "text": "Parameters\n\n\nbase_size : int = 11\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nbase_family : str = None\n\nBase font family. If None, use plotnine.options.base_family."
  },
  {
    "objectID": "reference/theme_set.html",
    "href": "reference/theme_set.html",
    "title": " plotnine.theme_set",
    "section": "",
    "text": "theme_set(new)"
  },
  {
    "objectID": "reference/theme_set.html#parameters",
    "href": "reference/theme_set.html#parameters",
    "title": " plotnine.theme_set",
    "section": "Parameters",
    "text": "Parameters\n\n\nnew : theme\n\nNew default theme"
  },
  {
    "objectID": "reference/theme_set.html#returns",
    "href": "reference/theme_set.html#returns",
    "title": " plotnine.theme_set",
    "section": "Returns",
    "text": "Returns\n\n\nout : theme\n\nPrevious theme"
  },
  {
    "objectID": "reference/theme_update.html",
    "href": "reference/theme_update.html",
    "title": " plotnine.theme_update",
    "section": "",
    "text": "theme_update(kwargs={})"
  },
  {
    "objectID": "reference/theme_update.html#parameters",
    "href": "reference/theme_update.html#parameters",
    "title": " plotnine.theme_update",
    "section": "Parameters",
    "text": "Parameters\n\n\nkwargs : dict = {}\n\nTheme elements"
  },
  {
    "objectID": "reference/theme_xkcd.html",
    "href": "reference/theme_xkcd.html",
    "title": " plotnine.theme_xkcd",
    "section": "",
    "text": "theme_xkcd(\n    base_size=12,\n    scale=1,\n    length=100,\n    randomness=2,\n    stroke_size=3,\n    stroke_color=\"white\"\n)"
  },
  {
    "objectID": "reference/theme_xkcd.html#parameters",
    "href": "reference/theme_xkcd.html#parameters",
    "title": " plotnine.theme_xkcd",
    "section": "Parameters",
    "text": "Parameters\n\n\nbase_size : int = 12\n\nBase font size. All text sizes are a scaled versions of the base font size.\n\nscale : float = 1\n\nThe amplitude of the wiggle perpendicular to the line (in pixels)\n\nlength : float = 100\n\nThe length of the wiggle along the line (in pixels).\n\nrandomness : float = 2\n\nThe factor by which the length is randomly scaled. Default is 2.\n\nstroke_size : float = 3\n\nSize of the stroke to apply to the lines and text paths.\n\nstroke_color : str | tuple = \"white\"\n\nColor of the strokes. Use \"none\" for no color."
  },
  {
    "objectID": "reference/title.html",
    "href": "reference/title.html",
    "title": " plotnine.themes.themeable.title",
    "section": "",
    "text": "title(theme_element)"
  },
  {
    "objectID": "reference/title.html#parameters",
    "href": "reference/title.html#parameters",
    "title": " plotnine.themes.themeable.title",
    "section": "Parameters",
    "text": "Parameters\n\n\ntheme_element : element_text"
  },
  {
    "objectID": "reference/typing.html",
    "href": "reference/typing.html",
    "title": "Typing Information",
    "section": "",
    "text": "DataFrameConvertible()\n\n\nObject that can be converted to a DataFrame\n\n\n\n\n\n\nto_pandas()\n\n\nConvert to pandas dataframe\n\n\n\n\n\npd.DataFrame\n\nPandas representation of this object.\n\n\n\n\n\n\n\n\n\n\nPTransform()\n\n\nTransform function\n\n\n\n\n\n\n__call__(x)"
  },
  {
    "objectID": "reference/typing.html#protocols",
    "href": "reference/typing.html#protocols",
    "title": "Typing Information",
    "section": "",
    "text": "DataFrameConvertible()\n\n\nObject that can be converted to a DataFrame\n\n\n\n\n\n\nto_pandas()\n\n\nConvert to pandas dataframe\n\n\n\n\n\npd.DataFrame\n\nPandas representation of this object.\n\n\n\n\n\n\n\n\n\n\nPTransform()\n\n\nTransform function\n\n\n\n\n\n\n__call__(x)"
  },
  {
    "objectID": "reference/typing.html#type-variables",
    "href": "reference/typing.html#type-variables",
    "title": "Typing Information",
    "section": "Type Variables",
    "text": "Type Variables\n\n TFloatArrayLike\n\nTypeVar(\"TFloatArrayLike\", bound=FloatArrayLike)"
  },
  {
    "objectID": "reference/typing.html#type-aliases",
    "href": "reference/typing.html#type-aliases",
    "title": "Typing Information",
    "section": "Type Aliases",
    "text": "Type Aliases\n\n AnyArray\n\nNDArray[Any]\n\n\n\n BoolArray\n\nNDArray[np.bool_]\n\n\n\n FloatArray\n\nNDArray[np.floating]\n\n\n\n IntArray\n\nNDArray[np.int64]\n\n\n\n StrArray\n\nNDArray[np.str_]\n\n\n\n AnySeries\n\npd.Series[Any]\n\n\n\n IntSeries\n\npd.Series[int]\n\n\n\n FloatSeries\n\npd.Series[float]\n\n\n\n AnyArrayLike\n\nAnyArray | pd.Series[Any] | Sequence[Any]\n\n\n\n IntArrayLike\n\nIntArray | IntSeries | Sequence[int]\n\n\n\n FloatArrayLike\n\nFloatArray | FloatSeries | Sequence[float]\n\n\n\n Data\n\npd.DataFrame | Callable[[pd.DataFrame], pd.DataFrame]\n\n\n\n DataLike\n\nData | DataFrameConvertible\n\n\n\n LayerData\n\npd.DataFrame | Callable[[pd.DataFrame], pd.DataFrame]\n\n\n\n LayerDataLike\n\nLayerData | DataFrameConvertible\n\n\n\n ColorLike\n\nstr\n\n\n\n ColorsLike\n\n(    ColorLike | list[ColorLike] | pd.Series[ColorLike] | StrArray)\n\n\n\n FigureFormat\n\nLiteral[\"png\", \"retina\", \"jpeg\", \"jpg\", \"svg\", \"pdf\"]\n\n\n\n FacetSpaceRatios\n\ndict[Literal[\"x\", \"y\"], Sequence[float]]\n\n\n\n StripPosition\n\nLiteral[\"top\", \"right\"]\n\n\n\n ScaledAestheticsName\n\nLiteral[    \"x\",    \"xmin\",    \"xmax\",    \"xend\",    \"xintercept\",    \"y\",    \"ymin\",    \"ymax\",    \"yend\",    \"yintercept\",    \"alpha\",    \"color\",    \"colour\",    \"fill\",    \"linetype\",    \"shape\",    \"size\",    \"stroke\",    # boxplot    \"ymax_final\",    \"ymin_final\",    \"lower\",    \"middle\",    \"upper\",]\n\n\n\n CoordRange\n\ntuple[float, float]\n\n\n\n Side\n\nLiteral[\"left\", \"right\", \"top\", \"bottom\"]\n\n\n\n LegendPosition\n\n(    Literal[\"left\", \"right\", \"top\", \"bottom\", \"inside\"] | tuple[float, float])\n\n\n\n Orientation\n\nLiteral[\"horizontal\", \"vertical\"]\n\n\n\n GuideKind\n\nLiteral[\"legend\", \"colorbar\", \"colourbar\"]\n\n\n\n NoGuide\n\nLiteral[\"none\", False]\n\n\n\n VerticalJustification\n\nLiteral[\"bottom\", \"center\", \"top\"]\n\n\n\n HorizontalJustification\n\nLiteral[\"left\", \"center\", \"right\"]\n\n\n\n TextJustification\n\n(    VerticalJustification | HorizontalJustification | Literal[\"baseline\"])\n\n\n\n TransformCol\n\nCallable[[FloatSeries], FloatSeries | FloatArray]"
  },
  {
    "objectID": "reference/xlab.html",
    "href": "reference/xlab.html",
    "title": " plotnine.xlab",
    "section": "",
    "text": "xlab(label)"
  },
  {
    "objectID": "reference/xlab.html#parameters",
    "href": "reference/xlab.html#parameters",
    "title": " plotnine.xlab",
    "section": "Parameters",
    "text": "Parameters\n\n\nname\n\nx aesthetic label (x-axis)"
  },
  {
    "objectID": "reference/ylab.html",
    "href": "reference/ylab.html",
    "title": " plotnine.ylab",
    "section": "",
    "text": "ylab(label)"
  },
  {
    "objectID": "reference/ylab.html#parameters",
    "href": "reference/ylab.html#parameters",
    "title": " plotnine.ylab",
    "section": "Parameters",
    "text": "Parameters\n\n\nname\n\ny aesthetic label i.e. y-axis label"
  },
  {
    "objectID": "tutorials/index.html",
    "href": "tutorials/index.html",
    "title": "Tutorials",
    "section": "",
    "text": "Using slightly altered colors to make a distinction between related data\nManipulating date breaks and date labels\nUsing ipyWidgets\nA PyQt5 Application\nCustom sorting of plot series\nUsing precomputed boxplots\nWhen the automatic groups are not sufficient\nUsing letters as shapes\nShow counts on a stacked bar plot\nShow counts and percentages for bar plots"
  },
  {
    "objectID": "gallery/dev/aes.html",
    "href": "gallery/dev/aes.html",
    "title": "aes",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import ggplot, aes, geom_point\n\nMapping variables to the visual properties of a plot.\n\ndf = pd.DataFrame({\n    \"col1\": np.arange(11),\n    \"col2\": np.arange(11)\n})\n\n(\n    ggplot(df, aes(x=\"col1\", y=\"col2\"))\n    + geom_point()\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(df, aes(x=\"col1\", y=\"col2 ** 2\"))\n    + geom_point()\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(df, aes(x=\"col1\", y=\"np.square(col2)\"))\n    + geom_point()\n)\n\n\n\n\n\n\n\n\nThe first two positional arguments are x and y aesthetics. Any other aesthetic must be mapped with a keyword argument.\n\n(\n    ggplot(df, aes(\"col1\", \"np.square(col2)\", color=\"col2\"))\n    + geom_point(size=3)\n)"
  },
  {
    "objectID": "gallery/dev/after_stat.html",
    "href": "gallery/dev/after_stat.html",
    "title": "after_stat",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import ggplot, aes, after_stat, geom_bar, labs\n\ngeom_bar uses stat_count which by default maps the y aesthetic to the count which is the number of observations at a position.\n\ndf = pd.DataFrame({\n    \"var1\": [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]\n})\n\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar()\n)\n\n\n\n\n\n\n\n\nUsing the after_stat function, we can instead map to the prop which is the ratio of points in the panel at a position.\n\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar(aes(y=after_stat(\"prop\")))  # default is after_stat('count')\n)\n\n\n\n\n\n\n\n\nWith after_stat you can used the variables calculated by the stat in expressions. For example we use the count to calculated the prop.\n\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar(aes(y=after_stat(\"count / np.sum(count)\")))\n    + labs(y=\"prop\")\n)\n\n\n\n\n\n\n\n\nBy default geom_bar uses stat_count to compute a frequency table with the x aesthetic as the key column. As a result, any mapping (other than the x aesthetic is lost) to a continuous variable is lost (if you have a classroom and you compute a frequency table of the gender, you lose any other information like height of students).\nFor example, below fill='var1' has no effect, but the var1 variable has not been lost it has been turned into x aesthetic.\n\n(ggplot(df, aes(\"var1\")) + geom_bar(aes(fill=\"var1\")))\n\n\n\n\n\n\n\n\nWe use after_stat to map fill to the x aesthetic after it has been computed.\n\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar(aes(fill=after_stat(\"x\")))\n    + labs(fill=\"var1\")\n)"
  },
  {
    "objectID": "gallery/dev/facet_wrap.html",
    "href": "gallery/dev/facet_wrap.html",
    "title": "Facet wrap",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_point, labs, facet_wrap, theme\nfrom plotnine.data import mpg\n\nfacet_wrap() creates a collection of plots (facets), where each plot is differentiated by the faceting variable. These plots are wrapped into a certain number of columns or rows as specified by the user.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nBasic scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nFacet a discrete variable using facet_wrap():\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\"class\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nControl the number of rows and columns with the options nrow and ncol:\n\n# Selecting the number of columns to display\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\n        \"class\",\n        ncol=4,  # change the number of columns\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\n\n# Selecting the number of rows to display\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\n        \"class\",\n        nrow=4,  # change the number of columns\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nTo change the plot order of the facets, reorder the levels of the faceting variable in the data.\n\n# re-order categories\nmpg[\"class\"] = mpg[\"class\"].cat.reorder_categories(\n    [\"pickup\", \"suv\", \"minivan\", \"midsize\", \"compact\", \"subcompact\", \"2seater\"]\n)\n\n\n# facet plot with reorded drv category\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\"class\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nOrdinarily the facets are arranged horizontally (left-to-right from top to bottom). However if you would prefer a vertical layout (facets are arranged top-to-bottom, from left to right) use the dir option:\n\n# Facet plot with vertical layout\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\n        \"class\",\n        dir=\"v\",  # change to a vertical layout\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can choose if the scale of x- and y-axes are fixed or variable. Set the scales argument to free-y, free_x or free for a free scales on the y-axis, x-axis or both axes respectively. You may need to add spacing between the facets to ensure axis ticks and values are easy to read.\nA fixed scale is the default and does not need to be specified.\n\n# facet plot with free scales\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\n        \"class\",\n        scales=\"free_y\",  # set scales so y-scale varies with the data\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can add additional information to your facet labels, by using the labeller argument within the facet_wrap() command. Below we use labeller = 'label_both' to include the column name in the facet label.\n\n# facet plot with labeller\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\"class\", labeller=\"label_both\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can add two discrete variables to a facet:\n\n# add additional column for plotting exercise\nmpg[\"transmission\"] = mpg[\"trans\"].map(\n    lambda x: \"auto\" if \"auto\" in x else \"man\" if \"man\" in x else \"\"\n)\n\n\n# inspect new column transmission which identifies cars as having an automatic or manual transmission\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\ntransmission\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\nauto\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\nman\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\nman\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\nauto\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\nauto\n\n\n\n\n\n\n\n\n# facet plot with two variables on one facet\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap([\"class\", \"transmission\"])  # use a list to add additional facetting variables\n    + labs(x=\"displacement\", y=\"horsepower\")\n)"
  },
  {
    "objectID": "gallery/dev/geom_abline.html",
    "href": "gallery/dev/geom_abline.html",
    "title": "AB line",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_point, labs, geom_abline, facet_grid\nfrom plotnine.data import mpg\n\ngeom_abline() draws a line when the yintercept and gradient is supplied, and is useful as a guide.\n\n# inspect the data\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nIt’s useful to use geom_abline() with some data, so we start with a basic scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nNow layer a line over the scatter plot using geom_abline(). geom_abline() requires inputs for the slope (default slope is 1) and y-intercept (default value is [0,0]).\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_abline(\n        intercept=45,  # set the y-intercept value\n        slope=-5,  # set the slope value\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can plot two lines on one plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_abline(\n        intercept=[45, 45],  # add many lines to a plot using a list for the y-intercepts...\n        slope=[-5, -7],  # ... and for the slopes\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can change the look of the line:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_abline(\n        intercept=45,\n        slope=-5,\n        color=\"blue\",  # set line colour\n        size=2,  # set line thickness\n        linetype=\"dashed\",  # set line type\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\ngeom_abline() can be used with a facet plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_abline(intercept=45, slope=-5)  # add a line ...\n    + facet_grid(\"drv\")  # ... to a facet plot.\n    + labs(x=\"displacement\", y=\"horsepower\")\n)"
  },
  {
    "objectID": "gallery/dev/geom_bar.html",
    "href": "gallery/dev/geom_bar.html",
    "title": "Bar chart",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_bar, coord_flip, theme_classic\nfrom plotnine.data import mpg\n\ngeom_bar() makes the height of the bar proportional to the number of cases in each group\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\n\nBar Plot with Counts\n\n# Gallery, distributions\nggplot(mpg) + geom_bar(aes(x=\"class\"))\n\n\n\n\n\n\n\n\n\n(\n    ggplot(mpg)\n    + geom_bar(aes(x=\"class\", fill=\"drv\"))\n)\n\n\n\n\n\n\n\n\n\n\nHorizontal Bar Plot with Counts\n\n# Gallery, distributions\n(\n    ggplot(mpg) \n    + geom_bar(aes(x=\"class\", fill=\"drv\"))\n    + coord_flip()\n    + theme_classic()\n)"
  },
  {
    "objectID": "gallery/dev/geom_col.html",
    "href": "gallery/dev/geom_col.html",
    "title": "Two Variable Bar Plot",
    "section": "",
    "text": "import pandas as pd\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_col,\n    geom_text,\n    position_dodge,\n    lims,\n    theme,\n    element_text,\n    element_blank,\n    element_rect,\n    element_line,\n)\n\nVisualising on a single plot the values of a variable that has nested (and independent) variables\nCreate the data\n\ndf = pd.DataFrame(\n    {\n        \"variable\": [\n            \"gender\",\n            \"gender\",\n            \"age\",\n            \"age\",\n            \"age\",\n            \"income\",\n            \"income\",\n            \"income\",\n            \"income\",\n        ],\n        \"category\": [\n            \"Female\",\n            \"Male\",\n            \"1-24\",\n            \"25-54\",\n            \"55+\",\n            \"Lo\",\n            \"Lo-Med\",\n            \"Med\",\n            \"High\",\n        ],\n        \"value\": [60, 40, 50, 30, 20, 10, 25, 25, 40],\n    }\n)\ndf[\"variable\"] = pd.Categorical(df[\"variable\"], categories=[\"gender\", \"age\", \"income\"])\ndf[\"category\"] = pd.Categorical(df[\"category\"], categories=df[\"category\"])\n\ndf\n\n\n\n\n\n\n\n\nvariable\ncategory\nvalue\n\n\n\n\n0\ngender\nFemale\n60\n\n\n1\ngender\nMale\n40\n\n\n2\nage\n1-24\n50\n\n\n3\nage\n25-54\n30\n\n\n4\nage\n55+\n20\n\n\n5\nincome\nLo\n10\n\n\n6\nincome\nLo-Med\n25\n\n\n7\nincome\nMed\n25\n\n\n8\nincome\nHigh\n40\n\n\n\n\n\n\n\nWe want to visualise this data and at a galance get an idea to how the value breaks down along the categorys for the different variable. Note that each variable has different categorys.\nFirst we make a simple plot with all this information and see what to draw from it.\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col()\n)\n\n\n\n\n\n\n\n\nAll the values along each variable add up to 100, but stacked together the difference within and without the groups is not clear. The solution is to dodge the bars.\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col(stat=\"identity\", position=\"dodge\")  # modified\n)  \n\n\n\n\n\n\n\n\nThis is good, it gives us the plot we want but the legend is not great. Each variable has a different set of categorys, but the legend has them all clamped together. We cannot easily change the legend, but we can replicate it’s purpose by labelling the individual bars.\nTo do this, we create a geom_text with position_dodge(width=0.9) to match the ratio of the space taken up by each variable. If there was no spacing between the bars of different variables, we would have width=1.\nA minor quack, when text extends beyond the limits we have to manually make space or it would get clipped. Therefore we adjust the bottom y limits.\n\ndodge_text = position_dodge(width=0.9)  # new\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col(stat=\"identity\", position=\"dodge\", show_legend=False)  # modified\n    + geom_text(\n        aes(y=-0.5, label=\"category\"),  # new\n        position=dodge_text,\n        color=\"gray\",\n        size=8,\n        angle=45,\n        va=\"top\",\n    )\n    + lims(y=(-5, 60))  # new\n)\n\n\n\n\n\n\n\n\nWould it look too crowded if we add value labels on top of the bars?\n\ndodge_text = position_dodge(width=0.9)\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col(stat=\"identity\", position=\"dodge\", show_legend=False)\n    + geom_text(\n        aes(y=-0.5, label=\"category\"),\n        position=dodge_text,\n        color=\"gray\",\n        size=8,\n        angle=45,\n        va=\"top\",\n    )\n    + geom_text(\n        aes(label=\"value\"),  # new\n        position=dodge_text,\n        size=8,\n        va=\"bottom\",\n        format_string=\"{}%\",\n    )\n    + lims(y=(-5, 60))\n)\n\n\n\n\n\n\n\n\nThat looks okay. The values line up with the categorys because we used the same dodge parameters. For the final polish, we remove the y-axis, clear out the panel and make the variable and category labels have the same color.\n\n# Gallery, bars\n\ndodge_text = position_dodge(width=0.9)\nccolor = \"#555555\"\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col(stat=\"identity\", position=\"dodge\", show_legend=False)\n    + geom_text(\n        aes(y=-0.5, label=\"category\"),\n        position=dodge_text,\n        color=ccolor,\n        size=8,\n        angle=45,\n        va=\"top\",\n    )  # modified\n    + geom_text(\n        aes(label=\"value\"),\n        position=dodge_text,\n        size=8,\n        va=\"bottom\",\n        format_string=\"{}%\",\n    )\n    + lims(y=(-5, 60))\n    + theme(\n        panel_background=element_rect(fill=\"white\"),  # new\n        axis_title_y=element_blank(),\n        axis_line_x=element_line(color=\"black\"),\n        axis_line_y=element_blank(),\n        axis_text_y=element_blank(),\n        axis_text_x=element_text(color=ccolor),\n        axis_ticks_major_y=element_blank(),\n        panel_grid=element_blank(),\n        panel_border=element_blank(),\n    )\n)\n\n\n\n\n\n\n\n\nCredit: I saved a plot this example is based on a while ago and forgot/misplaced the link to the source. The user considered it a minor coup."
  },
  {
    "objectID": "gallery/dev/geom_density.html",
    "href": "gallery/dev/geom_density.html",
    "title": "plotnine {{< var version >}}",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    after_stat,\n    geom_density,\n    geom_histogram,\n    geom_vline,\n    geom_rect,\n    labs,\n    annotate,\n    theme_tufte,\n)\nfrom plotnine.data import mpg\n\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nThe defaults are not exactly beautiful, but still quite clear.\n\nBasic Density Plot\n\n# Gallery, distributions\n(\n    ggplot(mpg, aes(x=\"cty\"))\n    + geom_density()\n)\n\n\n\n\n\n\n\n\nPlotting multiple groups is straightforward, but as each group is plotted as an independent PDF summing to 1, the relative size of each group will be normalized.\n\n\nDensity Plot with Groups\n\n# Gallery, distributions\n(\n    ggplot(mpg, aes(x=\"cty\", color=\"drv\", fill=\"drv\"))\n    + geom_density(alpha=0.1)\n)\n\n\n\n\n\n\n\n\nTo plot multiple groups and scale them by their relative size, you can map the y aesthetic to 'count' (calculated by stat_density).\n\n(\n    ggplot(mpg, aes(x=\"cty\", color=\"drv\", fill=\"drv\"))\n    + geom_density(aes(y=after_stat(\"count\")), alpha=0.1)\n)\n\n\n\n\n\n\n\n\n\n\nDensity Plots + Histograms\nTo overlay a histogram onto the density, the y aesthetic of the density should be mapped to the 'count' scaled by the binwidth of the histograms.\nWhy?\nThe count calculated by stat_density is \\(count = density * n\\) where n is the number of points . The density curves have an area of 1 and have no information about the absolute frequency of the values along curve; only the relative frequencies. The count curve reveals the absolute frequencies. The scale of this count corresponds to the count calculated by the stat_bin for the histogram when the bins are 1 unit wide i.e. binwidth=1. The count * binwidth curve matches the scale of counts for the histogram for a give binwidth.\n\n# Gallery, distributions\n\nbinwidth = 2  # The same for geom_density and geom_histogram\n\n(\n    ggplot(mpg, aes(x=\"cty\", color=\"drv\", fill=\"drv\"))\n    + geom_density(aes(y=after_stat(\"count*binwidth\")), alpha=0.1)\n    + geom_histogram(\n        aes(fill=\"drv\", y=after_stat(\"count\")),\n        binwidth=binwidth,\n        color=\"none\",\n        alpha=0.5,\n    )\n    # It is the histogram that gives us the meaningful y axis label\n    # i.e. 'count' and not 'count*2'\n    + labs(y=\"count\")\n)\n\n\n\n\n\n\n\n\n\n\nShaded Range Under a Density Plot\nExtending geom_density to create an effect of a shaded range\nCreate some data and plot the density\n\nn = 101\ndf = pd.DataFrame({\"x\": np.arange(n)})\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n)\n\n\n\n\n\n\n\n\nSuppose we want to mark a region as special e.g. (40, 60), we can use vertical lines to annotate it.\n\nregion = (40, 60)\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n    + annotate(geom_vline, xintercept=region)  # new line\n)\n\n\n\n\n\n\n\n\nTo make it standout more we can highlight. To do that, the first thought is to use a rectangle.\n\nregion = (40, 60)\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n    + annotate(\n        geom_rect, xmin=region[0], xmax=region[1], ymin=0, ymax=float(\"inf\"), alpha=0.5\n    )  # new annotation layer\n    + annotate(geom_vline, xintercept=region)\n)\n\n\n\n\n\n\n\n\nSince y upper-bound varies along the curve, a rectangular highlight has to stretch up to the top of the panel.\nTo hightlight only within the density curve, we have to use a second density curve. We need to calculate the density as normal, but just before the curve & region are plotted, we should keep only the region we want.\nWe create our own geom_density_highlight and override the setup_data method. First, we override but do nothing, we only inspect the data to see what we have to work with.\n\n# new class\nclass geom_density_highlight(geom_density):\n    def setup_data(self, data):\n        data = super().setup_data(data)\n        print(data)\n        return data\n\n\nregion = (40, 60)\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n    + geom_density_highlight(fill=\"black\", alpha=0.5)  # new line\n    + annotate(geom_vline, xintercept=region)\n)\n\n      PANEL     count   density  group    n    scaled           x         y  \\\n0         1  0.519038  0.005139     -1  101  0.519039    0.000000  0.005139   \n1         1  0.522757  0.005176     -1  101  0.522758    0.097752  0.005176   \n2         1  0.526473  0.005213     -1  101  0.526474    0.195503  0.005213   \n3         1  0.530187  0.005249     -1  101  0.530188    0.293255  0.005249   \n4         1  0.533899  0.005286     -1  101  0.533900    0.391007  0.005286   \n...     ...       ...       ...    ...  ...       ...         ...       ...   \n1019      1  0.533899  0.005286     -1  101  0.533900   99.608993  0.005286   \n1020      1  0.530187  0.005249     -1  101  0.530188   99.706745  0.005249   \n1021      1  0.526473  0.005213     -1  101  0.526474   99.804497  0.005213   \n1022      1  0.522757  0.005176     -1  101  0.522758   99.902248  0.005176   \n1023      1  0.519038  0.005139     -1  101  0.519039  100.000000  0.005139   \n\n      ymin      ymax  \n0        0  0.005139  \n1        0  0.005176  \n2        0  0.005213  \n3        0  0.005249  \n4        0  0.005286  \n...    ...       ...  \n1019     0  0.005286  \n1020     0  0.005249  \n1021     0  0.005213  \n1022     0  0.005176  \n1023     0  0.005139  \n\n[1024 rows x 10 columns]\n\n\n\n\n\n\n\n\n\nThe highlight has filled the whole region, but the printed data suggests that we can limit the rows to those where x column is within our region.\n\nclass geom_density_highlight(geom_density):\n    # new method\n    def __init__(self, *args, region=(-np.inf, np.inf), **kwargs):\n        super().__init__(*args, **kwargs)\n        self.region = region\n\n    def setup_data(self, data):\n        data = super().setup_data(data)\n        s = f\"{self.region[0]} &lt;= x &lt;= {self.region[1]}\"  # new line\n        data = data.query(s).reset_index(drop=True)  # new line\n        return data\n\n\nregion = (40, 60)\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n    + geom_density_highlight(region=region, fill=\"black\", alpha=0.5)  # modified line\n    + annotate(geom_vline, xintercept=region)\n)\n\n\n\n\n\n\n\n\nThat is it, but we can make it look better.\n\n# Gallery, distributions\n\nclass geom_density_highlight(geom_density):\n    def __init__(self, *args, region=(-np.inf, np.inf), **kwargs):\n        super().__init__(*args, **kwargs)\n        self.region = region\n\n    def setup_data(self, data):\n        data = super().setup_data(data)\n        s = f\"{self.region[0]} &lt;= x &lt;= {self.region[1]}\"\n        data = data.query(s).reset_index(drop=True)\n        return data\n\n\nregion = (40, 60)\nteal = \"#029386\"\n\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density_highlight(region=region, fill=teal + \"88\", color=\"none\")\n    + geom_density(fill=teal + \"44\", color=teal, size=0.7)\n    + annotate(geom_vline, xintercept=region, color=teal, size=0.7)\n    + theme_tufte()\n)\n\n\n\n\n\n\n\n\nThis example was motivated by a question from github user Rishika-Ravindran."
  },
  {
    "objectID": "gallery/dev/geom_hline.html",
    "href": "gallery/dev/geom_hline.html",
    "title": "Horizontal line",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_point, geom_hline, facet_grid, labs\nfrom plotnine.data import mpg\n\ngeom_hline() draws a vertical line, and is useful as a guide.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nIt’s useful to use geom_hline() with some data, so we start with a basic scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nNow add a horizontal line to the scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_hline(yintercept=25)  # add one horizonal line\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can add many horizontal lines:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_hline(yintercept=[25, 35, 45])  # add many horizontal lines using a list\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can change the look of the line:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_hline(\n        yintercept=25,\n        color=\"yellow\",  # set line colour\n        size=2,  # set line thickness\n        linetype=\"dashed\",  # set line type\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nAnd you can add horizontal lines to a facet plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_hline(yintercept=25)  # add a vertical line...\n    + facet_grid(\"drv\")  # ... to a facet plot\n    + labs(x=\"displacement\", y=\"horsepower\")\n)"
  },
  {
    "objectID": "gallery/dev/geom_linerange.html",
    "href": "gallery/dev/geom_linerange.html",
    "title": "Upper & Lower Trends",
    "section": "",
    "text": "import pandas as pd\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    geom_line,\n    geom_linerange,\n    element_blank,\n    element_rect,\n    theme,\n    theme_matplotlib,\n    theme_set,\n)\n\n# Set default theme\n# matplotlib + the background of 538\ntheme_set(\n    theme_matplotlib()\n    + theme(\n        plot_background=element_rect(fill=\"#F0F0F0\"),\n        panel_background=element_rect(fill=\"#F0F0F0\"),\n    )\n)\n\nThe data\n\ndf = pd.DataFrame({\n    \"x\": range(0, 6),\n    \"y\": [3, 4, 3.5, 4.5, 4, 4]\n})\n\nCreate the line ranges\n\n(ggplot(df, aes(\"x\", \"y\"))\n + geom_linerange(aes(ymin=\"y-2\", ymax=\"y\"))\n)\n\n\n\n\n\n\n\n\nAdd points at each end of the ranges.\n\n(ggplot(df, aes(\"x\", \"y\"))\n + geom_linerange(aes(ymin=\"y-2\", ymax=\"y\"))\n + geom_point()\n + geom_point(aes(y=\"y-2\"))\n\n)\n\n\n\n\n\n\n\n\nAdd a trend-line along the top of the ranges and one along the bottom of the ranges. The line is added before(below) the points.\n\n(ggplot(df, aes(\"x\", \"y\"))\n + geom_linerange(aes(ymin=\"y-2\", ymax=\"y\"))\n \n + geom_line()\n + geom_point()\n\n + geom_line(aes(y=\"y-2\"))\n + geom_point(aes(y=\"y-2\"))\n\n)\n\n\n\n\n\n\n\n\nAdd some color.\n\n# Gallery, lines\nmagenta = \"#9E2F68\"\nmagenta_light = \"#E5C8D6\"\n\nsea_green = \"#2F9E65\"\nsea_green_light = \"#C8E5D7\"\n\n(ggplot(df, aes(\"x\", \"y\"))\n + geom_linerange(aes(ymin=\"y-2\", ymax=\"y\"))\n \n + geom_line(color=magenta, size=3)\n + geom_point(color=magenta, fill=magenta_light, size=3, stroke=0.5)\n \n + geom_line(aes(y=\"y-2\"), color=sea_green, size=3)\n + geom_point(aes(y=\"y-2\"), color=sea_green, fill=sea_green_light, size=3, stroke=0.5)\n)"
  },
  {
    "objectID": "gallery/dev/geom_path.html",
    "href": "gallery/dev/geom_path.html",
    "title": "Path plots",
    "section": "",
    "text": "import pandas as pd\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_path,\n    geom_line,\n    labs,\n    scale_color_continuous,\n    element_text,\n    theme,\n)\nfrom plotnine.data import economics\n\ngeom_path() connects the observations in the order in which they appear in the data, this is different from geom_line() which connects observations in order of the variable on the x axis.\n\neconomics.head(10)  # notice the rows are ordered by date\n\n\n\n\n\n\n\n\ndate\npce\npop\npsavert\nuempmed\nunemploy\n\n\n\n\n0\n1967-07-01\n507.4\n198712\n12.5\n4.5\n2944\n\n\n1\n1967-08-01\n510.5\n198911\n12.5\n4.7\n2945\n\n\n2\n1967-09-01\n516.3\n199113\n11.7\n4.6\n2958\n\n\n3\n1967-10-01\n512.9\n199311\n12.5\n4.9\n3143\n\n\n4\n1967-11-01\n518.1\n199498\n12.5\n4.7\n3066\n\n\n5\n1967-12-01\n525.8\n199657\n12.1\n4.8\n3018\n\n\n6\n1968-01-01\n531.5\n199808\n11.7\n5.1\n2878\n\n\n7\n1968-02-01\n534.2\n199920\n12.2\n4.5\n3001\n\n\n8\n1968-03-01\n544.9\n200056\n11.6\n4.1\n2877\n\n\n9\n1968-04-01\n544.6\n200208\n12.2\n4.6\n2709\n\n\n\n\n\n\n\nBecause the data is in date order geom_path() (in pint) produces the same result as geom_line() (in black):\n\n(\n    ggplot(economics, aes(x=\"date\", y=\"unemploy\"))\n    + geom_line(size=5)  # plot geom_line as the first layer\n    + geom_path(\n        colour=\"#ff69b4\",  # plot a path - colour pink\n        size=1,\n    )\n    + labs(x=\"date\", y=\"unemployment (,000)\")  # label x & y-axis\n)\n\n\n\n\n\n\n\n\nPlotting unemployment (scaled by population) versus savings rate shows how geom_path() differs from geom_line(). Because geom_path() connects the observations in the order in which they appear in the data, this line is like a “journey through time”:\n\n(\n    ggplot(economics, aes(x=\"unemploy/pop\", y=\"psavert\"))\n    + geom_path()  # plot geom path\n    + labs(x=\"scaled unemployment\", y=\"saving rate\")  # label x & y-axis\n)\n\n\n\n\n\n\n\n\nComparing geom_line() (black) to geom_path() (pink) shows how these two plots differ in what they can show: geom_path() shows the savings rate has gone down over time, which is not evident with geom_path().\n\n(\n    ggplot(economics, aes(x=\"unemploy/pop\", y=\"psavert\"))\n    + geom_path(\n        colour=\"#ff69b4\",  # plot geom_path as the first layer - colour pink\n        alpha=0.5,  # line transparency\n        size=2.5,\n    )  # line thickness\n    + geom_line()  # layer geom_line\n    + labs(x=\"scaled unemployment\", y=\"saving rate\")  # label x & y-axis\n)\n\n\n\n\n\n\n\n\nThe geom_path can be easier to interpret if time is coloured in. First convert time to a number, and use this number to colour the path:\n\n# convert date to a number\neconomics[\"date_as_number\"] = pd.to_numeric(economics[\"date\"])\n\n\n# inspect new column\neconomics.head()\n\n\n\n\n\n\n\n\ndate\npce\npop\npsavert\nuempmed\nunemploy\ndate_as_number\n\n\n\n\n0\n1967-07-01\n507.4\n198712\n12.5\n4.5\n2944\n-79056000000000000\n\n\n1\n1967-08-01\n510.5\n198911\n12.5\n4.7\n2945\n-76377600000000000\n\n\n2\n1967-09-01\n516.3\n199113\n11.7\n4.6\n2958\n-73699200000000000\n\n\n3\n1967-10-01\n512.9\n199311\n12.5\n4.9\n3143\n-71107200000000000\n\n\n4\n1967-11-01\n518.1\n199498\n12.5\n4.7\n3066\n-68428800000000000\n\n\n\n\n\n\n\nThe path is coloured such that it changes with time using the command aes(colour='date_as_number') within geom_path().\n\n# input\nlegend_breaks = [\n    -79056000000000000,\n    709948800000000000,\n    1401580800000000000,\n]  # used to modify colour-graded legend\nlegend_labels = [\"1967-Jul\", \"1992-Jun\", \"2014-Jun\"]\n\n# plot\n(\n    ggplot(economics, aes(x=\"unemploy/pop\", y=\"psavert\"))\n    + geom_path(\n        aes(colour=\"date_as_number\")\n    )  # colour geom_path using time variable \"date_as_number\"\n    + labs(x=\"scaled unemployment\", y=\"saving rate\")\n    + scale_color_continuous(\n        breaks=legend_breaks,  # set legend breaks (where labels will appear)\n        labels=legend_labels,\n    )  # set labels on legend\n    + theme(legend_title=element_text(text=\"Date\"))  # set title of legend\n)"
  },
  {
    "objectID": "gallery/dev/geom_segment.html",
    "href": "gallery/dev/geom_segment.html",
    "title": "An Elaborate Range Plot",
    "section": "",
    "text": "# NOTE: This notebook uses the polars package\nimport numpy as np\n\nfrom plotnine import *\nimport polars as pl\nfrom polars import col\n\nComparing the point to point difference of many similar variables\nRead the data.\nSource: Pew Research Global Attitudes Spring 2015\n\n!head -n 20 \"data/survey-social-media.csv\"\n\nPSRAID,COUNTRY,Q145,Q146,Q70,Q74\n100000,Ethiopia,Female,35,No, \n100001,Ethiopia,Female,25,No, \n100002,Ethiopia,Male,40,Don’t know, \n100003,Ethiopia,Female,30,Don’t know, \n100004,Ethiopia,Male,22,No, \n100005,Ethiopia,Male,40,No, \n100006,Ethiopia,Female,20,No, \n100007,Ethiopia,Female,18,No,No\n100008,Ethiopia,Male,50,No, \n100009,Ethiopia,Male,35,No, \n100010,Ethiopia,Female,20,No, \n100011,Ethiopia,Female,30,Don’t know, \n100012,Ethiopia,Male,60,No, \n100013,Ethiopia,Male,18,No, \n100014,Ethiopia,Male,40,No, \n100015,Ethiopia,Male,28,Don’t know, \n100016,Ethiopia,Female,55,Don’t know, \n100017,Ethiopia,Male,30,Don’t know, \n100018,Ethiopia,Female,22,No, \n\n\n\ncolumns = dict(\n    COUNTRY=\"country\",\n    Q145=\"gender\",\n    Q146=\"age\",\n    Q70=\"use_internet\",\n    Q74=\"use_social_media\",\n)\n\ndata = (\n    pl.scan_csv(\n        \"data/survey-social-media.csv\",\n        dtypes=dict(Q146=pl.Utf8),\n    )\n    .rename(columns)\n    .select([\"country\", \"age\", \"use_social_media\"])\n    .collect()\n)\n\ndata.sample(10, seed=123)\n\n\nshape: (10, 3)\n\n\n\ncountry\nage\nuse_social_media\n\n\nstr\nstr\nstr\n\n\n\n\n\"India\"\n\"23\"\n\" \"\n\n\n\"Pakistan\"\n\"18\"\n\" \"\n\n\n\"Peru\"\n\"39\"\n\"Yes\"\n\n\n\"Jordan\"\n\"56\"\n\" \"\n\n\n\"United Kingdom…\n\"35\"\n\"Yes\"\n\n\n\"Chile\"\n\"24\"\n\"Yes\"\n\n\n\"Israel\"\n\"32\"\n\"No\"\n\n\n\"Pakistan\"\n\"39\"\n\"No\"\n\n\n\"Chile\"\n\"26\"\n\"Yes\"\n\n\n\"Nigeria\"\n\"43\"\n\"Yes\"\n\n\n\n\n\n\nCreate age groups for users of social media\n\nyes_no = [\"Yes\", \"No\"]\nvalid_age_groups = [\"18-34\", \"35-49\", \"50+\"]\n\nrdata = (\n    data.with_columns(\n        age_group=pl.when(col(\"age\") &lt;= \"34\")\n        .then(pl.lit(\"18-34\"))\n        .when(col(\"age\") &lt;= \"49\")\n        .then(pl.lit(\"35-49\"))\n        .when(col(\"age\") &lt; \"98\")\n        .then(pl.lit(\"50+\"))\n        .otherwise(pl.lit(\"\")),\n        country_count=pl.count().over(\"country\"),\n    )\n    .filter(\n        col(\"age_group\").is_in(valid_age_groups) & col(\"use_social_media\").is_in(yes_no)\n    )\n    .group_by([\"country\", \"age_group\"])\n    .agg(\n        # social media use percentage\n        sm_use_percent=(col(\"use_social_media\") == \"Yes\").sum() * 100 / pl.count(),\n        # social media question response rate\n        smq_response_rate=col(\"use_social_media\").is_in(yes_no).sum()\n        * 100\n        / col(\"country_count\").first(),\n    )\n    .sort([\"country\", \"age_group\"])\n)\n\nrdata.head()\n\n\nshape: (5, 4)\n\n\n\ncountry\nage_group\nsm_use_percent\nsmq_response_rate\n\n\nstr\nstr\nf64\nf64\n\n\n\n\n\"Argentina\"\n\"18-34\"\n90.883191\n35.1\n\n\n\"Argentina\"\n\"35-49\"\n84.40367\n21.8\n\n\n\"Argentina\"\n\"50+\"\n67.333333\n15.0\n\n\n\"Australia\"\n\"18-34\"\n90.862944\n19.621514\n\n\n\"Australia\"\n\"35-49\"\n78.04878\n20.418327\n\n\n\n\n\n\nTop 14 countries by response rate to the social media question.\n\ndef col_format(name, fmt):\n    # Format useing python formating\n    # for more control over\n    return col(name).map_elements(lambda x: fmt.format(x=x))\n\n\ndef float_to_str_round(name):\n    return col_format(name, \"{x:.0f}\")\n\n\nn = 14\n\ntop = (\n    rdata.group_by(\"country\")\n    .agg(r=col(\"smq_response_rate\").sum())\n    .sort(\"r\", descending=True)\n    .head(n)\n)\ntop_countries = top[\"country\"]\n\nexpr = float_to_str_round(\"sm_use_percent\")\nexpr_pct = expr + \"%\"\n\npoint_data = rdata.filter(col(\"country\").is_in(top_countries)).with_columns(\n    col(\"country\").cast(pl.Categorical),\n    sm_use_percent_str=pl.when(col(\"country\") == \"France\")\n    .then(expr_pct)\n    .otherwise(expr),\n)\n\npoint_data.head()\n\n\nshape: (5, 5)\n\n\n\ncountry\nage_group\nsm_use_percent\nsmq_response_rate\nsm_use_percent_str\n\n\ncat\nstr\nf64\nf64\nstr\n\n\n\n\n\"Australia\"\n\"18-34\"\n90.862944\n19.621514\n\"91\"\n\n\n\"Australia\"\n\"35-49\"\n78.04878\n20.418327\n\"78\"\n\n\n\"Australia\"\n\"50+\"\n48.479087\n52.390438\n\"48\"\n\n\n\"Canada\"\n\"18-34\"\n92.063492\n25.099602\n\"92\"\n\n\n\"Canada\"\n\"35-49\"\n75.925926\n21.513944\n\"76\"\n\n\n\n\n\n\n\nsegment_data = (\n    point_data.group_by(\"country\")\n    .agg(\n        min=col(\"sm_use_percent\").min(),\n        max=col(\"sm_use_percent\").max(),\n    )\n    .with_columns(gap=(col(\"max\") - col(\"min\")))\n    .sort(\n        \"gap\",\n    )\n    .with_columns(\n        min_str=float_to_str_round(\"min\"),\n        max_str=float_to_str_round(\"max\"),\n        gap_str=float_to_str_round(\"gap\"),\n    )\n)\n\nsegment_data.head()\n\n\nshape: (5, 7)\n\n\n\ncountry\nmin\nmax\ngap\nmin_str\nmax_str\ngap_str\n\n\ncat\nf64\nf64\nf64\nstr\nstr\nstr\n\n\n\n\n\"Russia\"\n76.07362\n95.151515\n19.077896\n\"76\"\n\"95\"\n\"19\"\n\n\n\"Israel\"\n55.405405\n88.311688\n32.906283\n\"55\"\n\"88\"\n\"33\"\n\n\n\"United Kingdom…\n52.74463\n86.096257\n33.351627\n\"53\"\n\"86\"\n\"33\"\n\n\n\"United States\"\n52.597403\n88.669951\n36.072548\n\"53\"\n\"89\"\n\"36\"\n\n\n\"Canada\"\n53.986333\n92.063492\n38.077159\n\"54\"\n\"92\"\n\"38\"\n\n\n\n\n\n\nFormat the floating point data that will be plotted into strings\nFirst plot\n\n# The right column (youngest-oldest gap) location\nxgap = 112\n\n(\n    ggplot()\n    # Range strip\n    + geom_segment(\n        segment_data,\n        aes(x=\"min\", xend=\"max\", y=\"country\", yend=\"country\"),\n        size=6,\n        color=\"#a7a9ac\",\n    )\n    # Age group markers\n    + geom_point(\n        point_data,\n        aes(\"sm_use_percent\", \"country\", color=\"age_group\", fill=\"age_group\"),\n        size=5,\n        stroke=0.7,\n    )\n    # Age group percentages\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"50+\"),\n        aes(\n            x=\"sm_use_percent-2\",\n            y=\"country\",\n            label=\"sm_use_percent_str\",\n            color=\"age_group\",\n        ),\n        size=8,\n        ha=\"right\",\n    )\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"35-49\"),\n        aes(x=\"sm_use_percent+2\", y=\"country\", label=\"sm_use_percent_str\"),\n        size=8,\n        ha=\"left\",\n        va=\"center\",\n        color=\"white\",\n    )\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"18-34\"),\n        aes(\n            x=\"sm_use_percent+2\",\n            y=\"country\",\n            label=\"sm_use_percent_str\",\n            color=\"age_group\",\n        ),\n        size=8,\n        ha=\"left\",\n    )\n    # gap difference\n    + geom_text(\n        segment_data,\n        aes(x=xgap, y=\"country\", label=\"gap_str\"),\n        size=9,\n        fontweight=\"bold\",\n        format_string=\"+{}\",\n    )\n)\n\n\n\n\n\n\n\n\nTweak it\n\n# Gallery, elaborate\n\n# The right column (youngest-oldest gap) location\nxgap = 115\n\n(\n    ggplot()\n    # Background Strips                                     # new\n    + geom_segment(\n        segment_data,\n        aes(y=\"country\", yend=\"country\"),\n        x=0,\n        xend=101,\n        size=8.5,\n        color=\"#edece3\",\n    )\n    # vertical grid lines along the strips                  # new\n    + annotate(\n        \"segment\",\n        x=list(range(10, 100, 10)) * n,\n        xend=list(range(10, 100, 10)) * n,\n        y=np.tile(np.arange(1, n + 1), 9) - 0.25,\n        yend=np.tile(np.arange(1, n + 1), 9) + 0.25,\n        color=\"#CCCCCC\",\n    )\n    # Range strip\n    + geom_segment(\n        segment_data,\n        aes(x=\"min\", xend=\"max\", y=\"country\", yend=\"country\"),\n        size=6,\n        color=\"#a7a9ac\",\n    )\n    # Age group markers\n    + geom_point(\n        point_data,\n        aes(\"sm_use_percent\", \"country\", color=\"age_group\", fill=\"age_group\"),\n        size=5,\n        stroke=0.7,\n    )\n    # Age group percentages\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"50+\"),\n        aes(\n            x=\"sm_use_percent-2\",\n            y=\"country\",\n            label=\"sm_use_percent_str\",\n            color=\"age_group\",\n        ),\n        size=8,\n        ha=\"right\",\n    )\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"35-49\"),\n        aes(x=\"sm_use_percent+2\", y=\"country\", label=\"sm_use_percent_str\"),\n        size=8,\n        ha=\"left\",\n        va=\"center\",\n        color=\"white\",\n    )\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"18-34\"),\n        aes(\n            x=\"sm_use_percent+2\",\n            y=\"country\",\n            label=\"sm_use_percent_str\",\n            color=\"age_group\",\n        ),\n        size=8,\n        ha=\"left\",\n    )\n    # countries right-hand-size (instead of y-axis)         # new\n    + geom_text(\n        segment_data,\n        aes(y=\"country\", label=\"country\"),\n        x=-1,\n        size=8,\n        ha=\"right\",\n        fontweight=\"bold\",\n        color=\"#222222\",\n    )\n    # gap difference\n    + geom_vline(xintercept=xgap, color=\"#edece3\", size=32)  # new\n    + geom_text(\n        segment_data,\n        aes(x=xgap, y=\"country\", label=\"gap_str\"),\n        size=9,\n        fontweight=\"bold\",\n        format_string=\"+{}\",\n    )\n    # Annotations                                            # new\n    + annotate(\"text\", x=31, y=n + 1.1, label=\"50+\", size=9, color=\"#ea9f2f\", va=\"top\")\n    + annotate(\n        \"text\", x=56, y=n + 1.1, label=\"35-49\", size=9, color=\"#6d6e71\", va=\"top\"\n    )\n    + annotate(\n        \"text\", x=85, y=n + 1.1, label=\"18-34\", size=9, color=\"#939c49\", va=\"top\"\n    )\n    + annotate(\n        \"text\",\n        x=xgap,\n        y=n + 0.5,\n        label=\"Youngest-\\nOldest Gap\",\n        size=9,\n        color=\"#444444\",\n        va=\"bottom\",\n        ha=\"center\",\n    )\n    + annotate(\"point\", x=[31, 56, 85], y=n + 0.3, alpha=0.85, stroke=0)\n    + annotate(\n        \"segment\",\n        x=[31, 56, 85],\n        xend=[31, 56, 85],\n        y=n + 0.3,\n        yend=n + 0.8,\n        alpha=0.85,\n    )\n    + annotate(\n        \"hline\",\n        yintercept=[x + 0.5 for x in range(2, n, 2)],\n        alpha=0.5,\n        linetype=\"dotted\",\n        size=0.7,\n    )\n    # Better spacing and color                              # new\n    + scale_x_continuous(limits=(-18, xgap + 2))\n    + scale_y_discrete(expand=(0, 0.25, 0.1, 0))\n    + scale_fill_manual(values=[\"#c3ca8c\", \"#d1d3d4\", \"#f2c480\"])\n    + scale_color_manual(values=[\"#939c49\", \"#6d6e71\", \"#ea9f2f\"])\n    + guides(color=None, fill=None)\n    + theme_void()\n    + theme(figure_size=(8, 8.5))\n)\n\n\n\n\n\n\n\n\nInstead of looking at this plot as having a country variable on the y-axis and a percentage variable on the x-axis, we can view it as having vertically stacked up many indepedent variables, the values of which have a similar scale.\nProtip: Save a pdf file.\n\nChange in Order\nComparing a group of ranked items at two different times\nRead the data.\nSource: World Bank - Infanct Mortality Rate (per 1,000 live births)b\n\ndata = pl.read_csv(\n    \"data/API_SP.DYN.IMRT.IN_DS2_en_csv_v2/API_SP.DYN.IMRT.IN_DS2_en_csv_v2.csv\",\n    skip_rows=4,\n    null_values=\"\",\n    truncate_ragged_lines=True,\n)\n\n# Columns as valid python variables\nyear_columns = {c: f\"y{c}\" for c in data.columns if c[:2] in {\"19\", \"20\"}}\ndata = data.rename(\n    {\"Country Name\": \"country\", \"Country Code\": \"code\", **year_columns}\n).drop([\"Indicator Name\", \"Indicator Code\"])\ndata.head()\n\n\nshape: (5, 59)\n\n\n\ncountry\ncode\ny1960\ny1961\ny1962\ny1963\ny1964\ny1965\ny1966\ny1967\ny1968\ny1969\ny1970\ny1971\ny1972\ny1973\ny1974\ny1975\ny1976\ny1977\ny1978\ny1979\ny1980\ny1981\ny1982\ny1983\ny1984\ny1985\ny1986\ny1987\ny1988\ny1989\ny1990\ny1991\ny1992\ny1993\ny1994\ny1995\ny1996\ny1997\ny1998\ny1999\ny2000\ny2001\ny2002\ny2003\ny2004\ny2005\ny2006\ny2007\ny2008\ny2009\ny2010\ny2011\ny2012\ny2013\ny2014\ny2015\ny2016\n\n\nstr\nstr\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nstr\n\n\n\n\n\"Aruba\"\n\"ABW\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n\n\n\"Afghanistan\"\n\"AFG\"\nnull\n240.5\n236.3\n232.3\n228.5\n224.6\n220.7\n217.0\n213.3\n209.8\n206.1\n202.2\n198.2\n194.3\n190.3\n186.6\n182.6\n178.7\n174.5\n170.4\n166.1\n161.8\n157.5\n153.2\n148.7\n144.5\n140.2\n135.7\n131.3\n126.8\n122.5\n118.3\n114.4\n110.9\n107.7\n105.0\n102.7\n100.7\n98.9\n97.2\n95.4\n93.4\n91.2\n89.0\n86.7\n84.4\n82.3\n80.4\n78.6\n76.8\n75.1\n73.4\n71.7\n69.9\n68.1\n66.3\nnull\n\n\n\"Angola\"\n\"AGO\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n138.3\n137.5\n136.8\n136.0\n135.3\n134.9\n134.4\n134.1\n133.8\n133.6\n133.5\n133.5\n133.5\n133.4\n133.2\n132.8\n132.3\n131.5\n130.6\n129.5\n128.3\n126.9\n125.5\n124.1\n122.8\n121.2\n119.4\n117.1\n114.7\n112.2\n109.6\n106.8\n104.1\n101.4\n98.8\n96.0\nnull\n\n\n\"Albania\"\n\"ALB\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n73.0\n68.4\n64.0\n59.9\n56.1\n52.4\n49.1\n45.9\n43.2\n40.8\n38.6\n36.7\n35.1\n33.7\n32.5\n31.4\n30.3\n29.1\n27.9\n26.8\n25.5\n24.4\n23.2\n22.1\n21.0\n20.0\n19.1\n18.3\n17.4\n16.7\n16.0\n15.4\n14.8\n14.3\n13.8\n13.3\n12.9\n12.5\nnull\n\n\n\"Andorra\"\n\"AND\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n7.5\n7.0\n6.5\n6.1\n5.6\n5.2\n5.0\n4.6\n4.3\n4.1\n3.9\n3.7\n3.5\n3.3\n3.2\n3.1\n2.9\n2.8\n2.7\n2.6\n2.5\n2.4\n2.3\n2.2\n2.1\n2.1\nnull\n\n\n\n\n\n\nThe data includes regional aggregates. To tell apart the regional aggregates we need the metadata. Every row in the data table has a corresponding row in the metadata table. Where the row has regional aggregate data, the Region column in the metadata table is NaN.\n\ndef ordered_categorical(s, categories=None):\n    \"\"\"\n    Create a categorical ordered according to the categories\n    \"\"\"\n    name = getattr(s, \"name\", \"\")\n    if categories is None:\n        return pl.Series(name, s).cast(pl.Categorical)\n\n    with pl.StringCache():\n        pl.Series(categories).cast(pl.Categorical)\n        return pl.Series(name, s).cast(pl.Categorical)\n\n\ncolumns = {\"Country Code\": \"code\", \"Region\": \"region\", \"IncomeGroup\": \"income_group\"}\n\nmetadata = (\n    pl.scan_csv(\n        \"data/API_SP.DYN.IMRT.IN_DS2_en_csv_v2/Metadata_Country_API_SP.DYN.IMRT.IN_DS2_en_csv_v2.csv\"\n    )\n    .rename(columns)\n    .select(list(columns.values()))\n    .filter(\n        # Drop the regional aggregate information\n        (col(\"region\") != \"\") & (col(\"income_group\") != \"\")\n    )\n    .collect()\n)\n\ncat_order = [\"High income\", \"Upper middle income\", \"Lower middle income\", \"Low income\"]\nmetadata = metadata.with_columns(\n    ordered_categorical(metadata[\"income_group\"], cat_order)\n)\n\nmetadata.head(10)\n\n\nshape: (10, 3)\n\n\n\ncode\nregion\nincome_group\n\n\nstr\nstr\ncat\n\n\n\n\n\"ABW\"\n\"Latin America …\n\"High income\"\n\n\n\"AFG\"\n\"South Asia\"\n\"Low income\"\n\n\n\"AGO\"\n\"Sub-Saharan Af…\n\"Lower middle i…\n\n\n\"ALB\"\n\"Europe & Centr…\n\"Upper middle i…\n\n\n\"AND\"\n\"Europe & Centr…\n\"High income\"\n\n\n\"ARE\"\n\"Middle East & …\n\"High income\"\n\n\n\"ARG\"\n\"Latin America …\n\"Upper middle i…\n\n\n\"ARM\"\n\"Europe & Centr…\n\"Lower middle i…\n\n\n\"ASM\"\n\"East Asia & Pa…\n\"Upper middle i…\n\n\n\"ATG\"\n\"Latin America …\n\"High income\"\n\n\n\n\n\n\nRemove the regional aggregates, to create a table with only country data\n\ncountry_data = data.join(metadata, on=\"code\")\ncountry_data.head()\n\n\nshape: (5, 61)\n\n\n\ncountry\ncode\ny1960\ny1961\ny1962\ny1963\ny1964\ny1965\ny1966\ny1967\ny1968\ny1969\ny1970\ny1971\ny1972\ny1973\ny1974\ny1975\ny1976\ny1977\ny1978\ny1979\ny1980\ny1981\ny1982\ny1983\ny1984\ny1985\ny1986\ny1987\ny1988\ny1989\ny1990\ny1991\ny1992\ny1993\ny1994\ny1995\ny1996\ny1997\ny1998\ny1999\ny2000\ny2001\ny2002\ny2003\ny2004\ny2005\ny2006\ny2007\ny2008\ny2009\ny2010\ny2011\ny2012\ny2013\ny2014\ny2015\ny2016\nregion\nincome_group\n\n\nstr\nstr\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nstr\nstr\ncat\n\n\n\n\n\"Aruba\"\n\"ABW\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n\"Latin America …\n\"High income\"\n\n\n\"Afghanistan\"\n\"AFG\"\nnull\n240.5\n236.3\n232.3\n228.5\n224.6\n220.7\n217.0\n213.3\n209.8\n206.1\n202.2\n198.2\n194.3\n190.3\n186.6\n182.6\n178.7\n174.5\n170.4\n166.1\n161.8\n157.5\n153.2\n148.7\n144.5\n140.2\n135.7\n131.3\n126.8\n122.5\n118.3\n114.4\n110.9\n107.7\n105.0\n102.7\n100.7\n98.9\n97.2\n95.4\n93.4\n91.2\n89.0\n86.7\n84.4\n82.3\n80.4\n78.6\n76.8\n75.1\n73.4\n71.7\n69.9\n68.1\n66.3\nnull\n\"South Asia\"\n\"Low income\"\n\n\n\"Angola\"\n\"AGO\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n138.3\n137.5\n136.8\n136.0\n135.3\n134.9\n134.4\n134.1\n133.8\n133.6\n133.5\n133.5\n133.5\n133.4\n133.2\n132.8\n132.3\n131.5\n130.6\n129.5\n128.3\n126.9\n125.5\n124.1\n122.8\n121.2\n119.4\n117.1\n114.7\n112.2\n109.6\n106.8\n104.1\n101.4\n98.8\n96.0\nnull\n\"Sub-Saharan Af…\n\"Lower middle i…\n\n\n\"Albania\"\n\"ALB\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n73.0\n68.4\n64.0\n59.9\n56.1\n52.4\n49.1\n45.9\n43.2\n40.8\n38.6\n36.7\n35.1\n33.7\n32.5\n31.4\n30.3\n29.1\n27.9\n26.8\n25.5\n24.4\n23.2\n22.1\n21.0\n20.0\n19.1\n18.3\n17.4\n16.7\n16.0\n15.4\n14.8\n14.3\n13.8\n13.3\n12.9\n12.5\nnull\n\"Europe & Centr…\n\"Upper middle i…\n\n\n\"Andorra\"\n\"AND\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n7.5\n7.0\n6.5\n6.1\n5.6\n5.2\n5.0\n4.6\n4.3\n4.1\n3.9\n3.7\n3.5\n3.3\n3.2\n3.1\n2.9\n2.8\n2.7\n2.6\n2.5\n2.4\n2.3\n2.2\n2.1\n2.1\nnull\n\"Europe & Centr…\n\"High income\"\n\n\n\n\n\n\nWe are interested in the changes in rank between 1960 and 2015. To plot a reasonable sized graph, we randomly sample 35 countries.\n\nsampled_data = (\n    country_data.drop_nulls(subset=[\"y1960\", \"y2015\"])\n    .sample(n=35, seed=123)\n    .with_columns(\n        y1960_rank=col(\"y1960\").rank(method=\"ordinal\").cast(pl.Int64),\n        y2015_rank=col(\"y2015\").rank(method=\"ordinal\").cast(pl.Int64),\n    )\n    .sort(\"y2015_rank\", descending=True)\n)\n\nsampled_data.head()\n\n\nshape: (5, 63)\n\n\n\ncountry\ncode\ny1960\ny1961\ny1962\ny1963\ny1964\ny1965\ny1966\ny1967\ny1968\ny1969\ny1970\ny1971\ny1972\ny1973\ny1974\ny1975\ny1976\ny1977\ny1978\ny1979\ny1980\ny1981\ny1982\ny1983\ny1984\ny1985\ny1986\ny1987\ny1988\ny1989\ny1990\ny1991\ny1992\ny1993\ny1994\ny1995\ny1996\ny1997\ny1998\ny1999\ny2000\ny2001\ny2002\ny2003\ny2004\ny2005\ny2006\ny2007\ny2008\ny2009\ny2010\ny2011\ny2012\ny2013\ny2014\ny2015\ny2016\nregion\nincome_group\ny1960_rank\ny2015_rank\n\n\nstr\nstr\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nstr\nstr\ncat\ni64\ni64\n\n\n\n\n\"Sierra Leone\"\n\"SLE\"\n223.6\n220.5\n217.5\n214.2\n211.0\n207.6\n204.2\n200.8\n197.3\n194.1\n191.0\n188.0\n185.2\n182.6\n180.0\n177.5\n175.3\n173.2\n171.2\n169.2\n167.3\n165.6\n164.1\n162.8\n161.5\n160.4\n159.4\n158.3\n157.6\n157.0\n156.5\n156.1\n155.7\n155.2\n154.5\n153.4\n152.0\n150.1\n148.1\n145.8\n143.3\n140.5\n137.7\n134.6\n131.4\n128.1\n124.5\n120.5\n116.2\n111.7\n107.0\n102.3\n97.9\n93.8\n90.2\n87.1\nnull\n\"Sub-Saharan Af…\n\"Low income\"\n35\n35\n\n\n\"Cote d'Ivoire\"\n\"CIV\"\n208.4\n203.0\n197.7\n192.8\n188.0\n183.3\n178.7\n174.2\n169.9\n165.4\n161.0\n156.4\n151.3\n146.1\n140.7\n135.1\n129.7\n124.7\n120.2\n116.6\n113.7\n111.4\n109.5\n108.0\n106.9\n106.1\n105.5\n105.2\n104.9\n104.9\n104.9\n104.8\n104.7\n104.7\n104.6\n104.4\n104.0\n103.3\n102.3\n101.0\n99.5\n97.7\n95.7\n93.6\n91.4\n88.9\n86.7\n84.1\n81.3\n79.0\n76.9\n75.0\n72.8\n70.6\n68.5\n66.6\nnull\n\"Sub-Saharan Af…\n\"Lower middle i…\n33\n34\n\n\n\"Benin\"\n\"BEN\"\n186.9\n183.9\n180.6\n177.1\n173.6\n170.2\n166.8\n164.0\n161.5\n159.2\n157.1\n154.9\n152.5\n149.8\n146.8\n143.5\n140.1\n136.7\n133.6\n130.9\n128.7\n126.6\n124.7\n122.8\n120.9\n118.9\n116.9\n114.8\n112.6\n110.4\n108.0\n105.6\n103.2\n100.9\n98.9\n97.2\n95.6\n94.2\n92.7\n91.1\n89.3\n87.4\n85.2\n83.0\n80.8\n78.8\n76.9\n75.2\n73.7\n72.3\n71.0\n69.8\n68.5\n67.2\n65.7\n64.2\nnull\n\"Sub-Saharan Af…\n\"Low income\"\n32\n33\n\n\n\"Burkina Faso\"\n\"BFA\"\n161.3\n159.4\n157.5\n155.8\n154.3\n153.0\n151.8\n150.9\n150.2\n149.7\n149.3\n148.5\n147.1\n144.6\n141.0\n136.6\n131.9\n127.4\n123.4\n120.2\n117.6\n115.6\n113.9\n112.4\n110.8\n109.0\n107.1\n105.3\n103.8\n102.9\n102.5\n102.3\n102.4\n102.4\n102.1\n101.4\n100.5\n99.4\n98.3\n97.3\n96.2\n95.0\n93.4\n91.4\n88.9\n86.0\n82.7\n79.2\n75.8\n72.5\n69.7\n67.3\n65.4\n63.7\n62.2\n60.9\nnull\n\"Sub-Saharan Af…\n\"Low income\"\n30\n32\n\n\n\"Ghana\"\n\"GHA\"\n125.1\n123.8\n122.7\n121.8\n121.2\n120.8\n120.7\n120.6\n120.6\n120.5\n120.1\n119.5\n118.2\n116.5\n114.2\n111.5\n108.7\n106.0\n103.8\n102.1\n100.9\n100.1\n99.3\n98.4\n96.8\n94.7\n92.1\n89.0\n85.8\n82.7\n79.8\n77.5\n75.6\n74.1\n73.0\n72.0\n71.0\n69.8\n68.4\n66.7\n64.9\n63.0\n61.2\n59.6\n58.1\n56.8\n55.6\n54.4\n53.1\n51.7\n50.2\n48.6\n47.0\n45.5\n44.2\n42.8\nnull\n\"Sub-Saharan Af…\n\"Lower middle i…\n25\n31\n\n\n\n\n\n\nFirst graph\n\n(\n    ggplot(sampled_data)\n    + geom_text(aes(1, \"y1960_rank\", label=\"country\"), ha=\"right\", size=9)\n    + geom_text(aes(2, \"y2015_rank\", label=\"country\"), ha=\"left\", size=9)\n    + geom_point(aes(1, \"y1960_rank\", color=\"income_group\"), size=2.5)\n    + geom_point(aes(2, \"y2015_rank\", color=\"income_group\"), size=2.5)\n    + geom_segment(\n        aes(x=1, y=\"y1960_rank\", xend=2, yend=\"y2015_rank\", color=\"income_group\")\n    )\n    + scale_y_reverse()\n)\n\n\n\n\n\n\n\n\nIt has the form we want, but we need to tweak it.\n\n# Text colors\nblack1 = \"#252525\"\nblack2 = \"#222222\"\n\n# Gallery, elaborate\n\n(\n    ggplot(sampled_data)\n    # Slight modifications for the original lines,\n    # 1. Nudge the text to either sides of the points\n    # 2. Alter the color and alpha values\n    + geom_text(\n        aes(1, \"y1960_rank\", label=\"country\"),\n        nudge_x=-0.05,\n        ha=\"right\",\n        size=9,\n        color=black1,\n    )\n    + geom_text(\n        aes(2, \"y2015_rank\", label=\"country\"),\n        nudge_x=0.05,\n        ha=\"left\",\n        size=9,\n        color=black1,\n    )\n    + geom_point(aes(1, \"y1960_rank\", color=\"income_group\"), size=2.5, alpha=0.7)\n    + geom_point(aes(2, \"y2015_rank\", color=\"income_group\"), size=2.5, alpha=0.7)\n    + geom_segment(\n        aes(x=1, y=\"y1960_rank\", xend=2, yend=\"y2015_rank\", color=\"income_group\"),\n        alpha=0.7,\n    )\n    # Text Annotations\n    + annotate(\n        \"text\",\n        x=1,\n        y=0,\n        label=\"Rank in 1960\",\n        fontweight=\"bold\",\n        ha=\"right\",\n        size=10,\n        color=black2,\n    )\n    + annotate(\n        \"text\",\n        x=2,\n        y=0,\n        label=\"Rank in 2015\",\n        fontweight=\"bold\",\n        ha=\"left\",\n        size=10,\n        color=black2,\n    )\n    + annotate(\n        \"text\", x=1.5, y=0, label=\"Lines show change in rank\", size=9, color=black1\n    )\n    + annotate(\n        \"label\",\n        x=1.5,\n        y=3,\n        label=\"Lower infant\\ndeath rates\",\n        size=9,\n        color=black1,\n        label_size=0,\n        fontstyle=\"italic\",\n    )\n    + annotate(\n        \"label\",\n        x=1.5,\n        y=33,\n        label=\"Higher infant\\ndeath rates\",\n        size=9,\n        color=black1,\n        label_size=0,\n        fontstyle=\"italic\",\n    )\n    # Prevent country names from being chopped off\n    + lims(x=(0.35, 2.65))\n    + labs(color=\"Income Group\")\n    # Countries with lower rates on top\n    + scale_y_reverse()\n    # Change colors\n    + scale_color_brewer(type=\"qual\", palette=2)\n    # Removes all decorations\n    + theme_void()\n    # Changing the figure size prevents the country names from squishing up\n    + theme(figure_size=(8, 11))\n)"
  },
  {
    "objectID": "gallery/dev/geom_step.html",
    "href": "gallery/dev/geom_step.html",
    "title": "Step plots",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_step, geom_line, labs, theme, element_text\nfrom plotnine.data import economics\n\ngeom_step() connects points using ‘steps’ instead of a line.\n\n# inspect the data\neconomics.head()\n\n\n\n\n\n\n\n\ndate\npce\npop\npsavert\nuempmed\nunemploy\n\n\n\n\n0\n1967-07-01\n507.4\n198712\n12.5\n4.5\n2944\n\n\n1\n1967-08-01\n510.5\n198911\n12.5\n4.7\n2945\n\n\n2\n1967-09-01\n516.3\n199113\n11.7\n4.6\n2958\n\n\n3\n1967-10-01\n512.9\n199311\n12.5\n4.9\n3143\n\n\n4\n1967-11-01\n518.1\n199498\n12.5\n4.7\n3066\n\n\n\n\n\n\n\nPlot a step plot using geom_plot(). Notice from the first point the line travels vertically then horizontally:\n\n(\n    ggplot(\n        economics.iloc[:20],  # filter for first twenty rows (dates) to make steps more visible\n        aes(\"date\", \"unemploy\"),\n    )\n    + geom_step()  # step plot\n    + labs(x=\"date\", y=\"unemployment (,000)\")  # label x & y-axis\n    + theme(axis_text_x=element_text(angle=45))  # rotate x-axis text for readability\n)\n\n\n\n\n\n\n\n\nYou can see how geom_path() (shown in pink) differs from geom_line() (black):\n\n(\n    ggplot(economics.iloc[:20], aes(\"date\", \"unemploy\"))\n    + geom_step(\n        colour=\"#ff69b4\",  # plot geom_step as the first layer - colour pink\n        alpha=0.5,  # line transparency\n        size=2.5,\n    )  # line thickness\n    + geom_line()  # plot geom_line as the second layer\n    + labs(x=\"date\", y=\"unemployment (,000)\")\n    + theme(axis_text_x=element_text(angle=45))\n)\n\n\n\n\n\n\n\n\nRather than a line that travels vertically then horizontally, this order can be switched by specifying direction='vh' within geom_step(). Below direction='vh' is shown in black with the default direction='hv' shown in pink:\n\n(\n    ggplot(economics.iloc[:20], aes(\"date\", \"unemploy\"))\n    + geom_step(\n        colour=\"#ff69b4\",  # plot geom_path with default direction as the first layer - colour pink\n        linetype=\"dashed\",  # line type\n        size=2,  # line thickness\n        alpha=0.5,\n    )  # line transparency\n    + geom_step(direction=\"vh\")  # plot geom_path with step order reversed\n    + labs(x=\"date\", y=\"unemployment (,000)\")\n    + theme(axis_text_x=element_text(angle=45))\n)"
  },
  {
    "objectID": "gallery/dev/geom_violin.html",
    "href": "gallery/dev/geom_violin.html",
    "title": "Violins, Boxes, Points & Lines",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nimport pandas.api.types as pdtypes\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    stage,\n    geom_violin,\n    geom_point,\n    geom_line,\n    geom_boxplot,\n    guides,\n    scale_fill_manual,\n    theme,\n    theme_classic,\n)\n\nComparing repeated measurements and their summaries\nSuppose you have two sets of related data and each point in the first set maps onto a point in the second set. e.g. they could represent a transition from one state to another for example two measurements of the height of pupils in different years.\nFor demonstration we shall generate data with a before measurement and an after measurement.\n\nnp.random.seed(123)\nn = 20\nmu = (1, 2.3)\nsigma = (1, 1.6)\n\nbefore = np.random.normal(loc=mu[0], scale=sigma[0], size=n)\nafter = np.random.normal(loc=mu[1], scale=sigma[1], size=n)\n\ndf = pd.DataFrame(\n    {\n        \"value\": np.hstack([before, after]),\n        \"when\": np.repeat([\"before\", \"after\"], n),\n        \"id\": np.hstack([range(n), range(n)]),\n    }\n)\n\ndf[\"when\"] = df[\"when\"].astype(pdtypes.CategoricalDtype(categories=[\"before\", \"after\"]))\ndf.head()\n\n\n\n\n\n\n\n\nvalue\nwhen\nid\n\n\n\n\n0\n-0.085631\nbefore\n0\n\n\n1\n1.997345\nbefore\n1\n\n\n2\n1.282978\nbefore\n2\n\n\n3\n-0.506295\nbefore\n3\n\n\n4\n0.421400\nbefore\n4\n\n\n\n\n\n\n\nA basic violin plot shows distributions of the two sets of data.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(df)\n)\n\n\n\n\n\n\n\n\nAdd the original data in form of points.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(df)\n    + geom_point()\n)\n\n\n\n\n\n\n\n\nThe violins are symmetrical about the vertical axis and half a violin has the same information as the full violin. We cut (style) the violins in half and choose to alternate with the left half for the first one and the right half for the second.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(df, style=\"left-right\")  # changed\n    + geom_point()\n)\n\n\n\n\n\n\n\n\nLink up the points to get a sense of how the data the moves.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(df, style=\"left-right\")  # changed\n    + geom_point()\n    + geom_line(aes(group=\"id\"))  # new\n)\n\n\n\n\n\n\n\n\nMake gap between the points and the violions. i.e. shift the violins outward and the points & lines inward. We used stage mapping to get it done. For example\nx=stage('when', after_scale='x+shift*alt_sign(x)')\nsays, map the xaesthetic to the ‘when’ column/variable and after the scale computed the x locations add a shift to them. The calculated x locations of a discrete scale are consecutive numbers 1, 2, 3, ..., so we use that move objects of adjacent groups in opposite directions i.e $(-1)^1, (-1)^2, (-1)^3 … = -1, 1, -1… $\n\n# How much to shift the violin, points and lines\n# 0.1 is 10% of the allocated space for the category\nshift = 0.1\n\n\ndef alt_sign(x):\n    \"Alternate +1/-1 if x is even/odd\"\n    return (-1) ** x\n\n\nm1 = aes(x=stage(\"when\", after_scale=\"x+shift*alt_sign(x)\"))  # shift outward\nm2 = aes(x=stage(\"when\", after_scale=\"x-shift*alt_sign(x)\"), group=\"id\")  # shift inward\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(m1, style=\"left-right\")  # changed\n    + geom_point(m2)  # changed\n    + geom_line(m2)  # changed\n)\n\n\n\n\n\n\n\n\nAdd a boxplot in the gap. The space between the flat edge of the violin and the center of the points is 2 * shift, so we can use the shift to control the width of the boxplot.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(m1, style=\"left-right\")\n    + geom_point(m2)\n    + geom_line(m2)\n    + geom_boxplot(width=shift)\n)\n\n\n\n\n\n\n\n\nFinall, style it up.\n\n# Gallery, distributions\n\nlsize = 0.65\nfill_alpha = 0.7\n\n(\n    ggplot(df, aes(\"when\", \"value\", fill=\"when\"))\n    + geom_violin(m1, style=\"left-right\", alpha=fill_alpha, size=lsize)\n    + geom_point(m2, color=\"none\", alpha=fill_alpha, size=2)\n    + geom_line(m2, color=\"gray\", size=lsize, alpha=0.6)\n    + geom_boxplot(width=shift, alpha=fill_alpha, size=lsize)\n    + scale_fill_manual(values=[\"dodgerblue\", \"darkorange\"])\n    + guides(fill=False)  # Turn off the fill legend\n    + theme_classic()\n    + theme(figure_size=(8, 6))\n)\n\n\n\n\n\n\n\n\nCredit: This is example is motivated by the work of Jordy van Langen (@jorvlan) at https://github.com/jorvlan/open-visualizations."
  },
  {
    "objectID": "gallery/dev/labs.html",
    "href": "gallery/dev/labs.html",
    "title": "Text Outside the Panel(s)",
    "section": "",
    "text": "from plotnine import ggplot, aes, labs, geom_point, theme, theme_538, theme_set\nfrom plotnine.data import mtcars\n\ntheme_set(theme_538())\n\n\n# Gallery, labels\n\ncaption = \"\"\"\\\nThis graphic illustrates the inverse relationship between vehicle weight\nand fuel efficiency (MPG). It aims to highlight how heavier vehicles generally\nconsume more fuel, and how the complexity of an engine's cylinder count and\ntransmission system can affect its fuel economy.\n\"\"\"\n\nfrom plotnine import *\n(\n    ggplot(mtcars, aes(\"mpg\", \"wt\", colour=\"factor(cyl)\", size=\"gear\"))\n    + geom_point()\n    + labs(\n        x=\"Miles per Gallon\",\n        y=\"Weight\",\n        colour=\"Cylinders\",\n        size=\"Gears\",\n        title=\"Fuel Efficiency vs. Vehicle Weight\",\n        subtitle =\"Exploring Factors that Affect the Fuel Effeciency of a Car\",\n        caption=caption,\n    )\n\n    + theme(\n        # left justify the caption and have one line of space between it and\n        # the x-axis label\n        plot_caption=element_text(ha=\"left\", margin={\"t\": 1, \"units\": \"lines\"})\n    )\n    \n)"
  },
  {
    "objectID": "gallery/dev/scale_fill_continuous.html",
    "href": "gallery/dev/scale_fill_continuous.html",
    "title": "Simple heatmap",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    theme_matplotlib,\n    theme_set,\n    geom_tile,\n    scale_fill_continuous,\n    coord_cartesian\n)\n\nfrom plotnine.data import faithfuld\n\n# Set default theme for all the plots\ntheme_set(theme_matplotlib())\n\nMap data to color gradient\nWithout specifically calling scale_fill_continuous(), a default scale is applied to geom_tile().\n\nfaithfuld.head()\n\n\n\n\n\n\n\n\neruptions\nwaiting\ndensity\n\n\n\n\n0\n1.600000\n43.0\n0.003216\n\n\n1\n1.647297\n43.0\n0.003835\n\n\n2\n1.694595\n43.0\n0.004436\n\n\n3\n1.741892\n43.0\n0.004978\n\n\n4\n1.789189\n43.0\n0.005424\n\n\n\n\n\n\n\n\n(\n    ggplot(faithfuld, aes(\"waiting\", \"eruptions\", fill=\"density\")) \n    + geom_tile()\n)\n\n\n\n\n\n\n\n\nNotice that adding scale_fill_continuous() will not change the default plot.\n\n(\n    ggplot(faithfuld, aes(\"waiting\", \"eruptions\", fill=\"density\"))\n    + geom_tile()\n    + scale_fill_continuous()\n)\n\n\n\n\n\n\n\n\nThe scale aesthetics can be edited to other color maps. Use the cmap_name argument to specify an alternative palette. Find other available color maps in the matplotlib documentation.\n\n# Gallery, tiles\n\n(\n    ggplot(faithfuld, aes(\"waiting\", \"eruptions\", fill=\"density\"))\n    + geom_tile()\n    + scale_fill_continuous(cmap_name=\"plasma\")\n    + coord_cartesian(expand=False)\n)"
  },
  {
    "objectID": "gallery/dev/scale_x_continuous.html",
    "href": "gallery/dev/scale_x_continuous.html",
    "title": "Guitar Neck ###",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    geom_path,\n    scale_x_continuous,\n    scale_y_continuous,\n    guides,\n    theme,\n    element_line,\n    element_rect,\n)\nfrom mizani.transforms import trans\n\nUsing a transformed x-axis to visualise guitar chords\nThe x-axis is transformed to resemble the narrowing width of frets on a 25.5 inch Strat. To do that we create custom transformation.\nThe key parts of any transform object are the transform and inverse functions.\n\nclass frets_trans(trans):\n    \"\"\"\n    Frets Transformation\n    \"\"\"\n\n    number_of_frets = 23  # Including fret 0\n    domain = (0, number_of_frets - 1)\n\n    @staticmethod\n    def transform(x):\n        x = np.asarray(x)\n        return 25.5 - (25.5 / (2 ** (x / 12)))\n\n    @staticmethod\n    def inverse(x):\n        x = np.asarray(x)\n        return 12 * np.log2(25.5 / (25.5 - x))\n\n    @classmethod\n    def breaks_(cls, limits):\n        # Fixed major breaks\n        return cls.domain\n\n    @classmethod\n    def minor_breaks(cls, major, limits):\n        # The major breaks as passed to this method are in transformed space.\n        # The minor breaks are calculated in data space to reveal the\n        # non-linearity of the scale.\n        _major = cls.inverse(major)\n        minor = cls.transform(np.linspace(*_major, cls.number_of_frets))\n        return minor\n\nThe above transform is different from most in that, breaks and minor breaks do not change. This is common of very specialized scales. It can also be a key requirement when creating graphics for demontration purposes.\nSome chord Data\n\n# Notes: the 0 fret is an open strum, all other frets are played half-way between fret bars.\n# The strings are 1:low E, 2: A, 3: D, 4: G, 5: B, 6: E\nc_chord = pd.DataFrame({\"Fret\": [0, 2.5, 1.5, 0, 0.5, 0], \"String\": [1, 2, 3, 4, 5, 6]})\n\n# Sequence based on the number of notes in the chord\nc_chord[\"Sequence\"] = list(range(1, 1 + len(c_chord[\"Fret\"])))\n\n# Standard markings for a Stratocaster\nmarkings = pd.DataFrame(\n    {\n        \"Fret\": [2.5, 4.5, 6.5, 8.5, 11.5, 11.5, 14.5, 16.5, 18.5, 20.5],\n        \"String\": [3.5, 3.5, 3.5, 3.5, 2, 5, 3.5, 3.5, 3.5, 3.5],\n    }\n)\n\nVisualizing the chord\n\n# Gallery, elaborate\n\n# Look and feel of the graphic\nneck_color = \"#FFDDCC\"\nfret_color = \"#998888\"\nstring_color = \"#AA9944\"\n\nneck_theme = theme(\n    figure_size=(10, 2),\n    panel_background=element_rect(fill=neck_color),\n    panel_grid_major_y=element_line(color=string_color, size=2.2),\n    panel_grid_major_x=element_line(color=fret_color, size=2.2),\n    panel_grid_minor_x=element_line(color=fret_color, size=1),\n)\n\n(\n    ggplot(c_chord, aes(\"Fret\", \"String\"))\n    + geom_path(aes(color=\"Sequence\"), size=3)\n    + geom_point(aes(color=\"Sequence\"), fill=\"#FFFFFF\", size=3)\n    + geom_point(data=markings, fill=\"#000000\", size=4)\n    + scale_x_continuous(trans=frets_trans)\n    + scale_y_continuous(breaks=range(0, 7), minor_breaks=[])\n    + guides(color=False)\n    + neck_theme\n)\n\n\n\n\n\n\n\n\nCredit: This example was motivated by Jonathan Vitale who wanted to create graphics for a guitar scale trainer."
  },
  {
    "objectID": "gallery/dev/theme.html",
    "href": "gallery/dev/theme.html",
    "title": "plotnine {{< var version >}}",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    facet_grid,\n    labs,\n    guide_legend,\n    guides,\n    theme,\n    element_text,\n    element_line,\n    element_rect,\n    theme_set,\n    theme_void,\n)\nfrom plotnine.data import mtcars\n\n# We use theme_void as the base theme so that the modifications\n# we make in the code are transparent in the output\ntheme_set(theme_void())\nmtcars.head()\n\n\n\n\n\n\n\n\nname\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\n0\nMazda RX4\n21.0\n6\n160.0\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\n1\nMazda RX4 Wag\n21.0\n6\n160.0\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\n2\nDatsun 710\n22.8\n4\n108.0\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\n3\nHornet 4 Drive\n21.4\n6\n258.0\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\n4\nHornet Sportabout\n18.7\n8\n360.0\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\nThe base plots we will use for the demonstation and some colors.\np1 = (\n    ggplot(mtcars, aes(\"wt\", \"mpg\", color=\"factor(cyl)\"))\n    + geom_point()\n    + labs(title=\"mpg vs wt\")\n)\n\np2 = p1 + facet_grid(\"gear\", \"am\")\n\nblack = \"#222222\"\ngray = \"#666666\"\nred = \"#FF3333\"\ngreen = \"#66CC00\"\nblue = \"#3333FF\"\npurple = \"#9933FF\"\norange = \"#FF8000\"\nyellow = \"#FFFF33\"\nWhat the plots look like unmodified (unthemed).\np1\np2\nThere are 3 main top level theming elements:\nNote that none of the themeables control/modify the plotted data. e.g You cannot use text to change the appearance of objects plotted with geom_text.\ntext\np1 + theme(text=element_text(color=purple))\nrect\np1 + theme(rect=element_rect(color=black, size=3, fill=\"#EEBB0050\"))\nline\np1 + theme(line=element_line(color=black))"
  },
  {
    "objectID": "gallery/dev/theme.html#theming-specific-items",
    "href": "gallery/dev/theme.html#theming-specific-items",
    "title": "plotnine {{< var version >}}",
    "section": "Theming specific items",
    "text": "Theming specific items\n\naxis_line and axis_text\n\np1 + theme(\n    axis_line=element_line(size=2),\n    axis_line_x=element_line(color=red),\n    axis_line_y=element_line(color=blue),\n    axis_text=element_text(margin={\"t\": 5, \"r\": 5}),\n    axis_text_x=element_text(color=black),\n    axis_text_y=element_text(color=purple),\n)\n\n\n\n\n\n\n\n\n\np1 + theme(\n    axis_line=element_line(size=0.7, color=gray),\n    # We are focusing on the ticks, make them long\n    axis_ticks_length=20,\n    axis_ticks_length_minor=10,\n    axis_ticks_length_major=20,\n    axis_ticks=element_line(size=2),\n    axis_ticks_major=element_line(color=purple),\n    axis_ticks_major_x=element_line(size=4),  # override size=2\n    axis_ticks_major_y=element_line(color=yellow),  # override color=purple\n    axis_ticks_minor=element_line(color=red),\n    axis_ticks_minor_x=element_line(),  # do not override anything\n    axis_ticks_minor_y=element_line(color=gray),  # override color=red\n)\n\n\n\n\n\n\n\n\n\n\naxis_title and axis_ticks_pad\n\np1 + theme(\n    axis_line=element_line(size=0.7, color=gray),\n    axis_ticks=element_line(),\n    axis_title=element_text(),\n    axis_title_x=element_text(color=blue),\n    axis_title_y=element_text(color=red),\n    # The gap between the title and the ticks\n    axis_ticks_pad=20,\n    axis_ticks_pad_major=20,\n    axis_ticks_pad_minor=20,\n)\n\n\n\n\n\n\n\n\n\n\naxis_ticks_direction\n\np1 + theme(\n    axis_line=element_line(size=0.7, color=gray),\n    axis_ticks=element_line(),\n    axis_ticks_direction=\"in\",\n    axis_ticks_direction_x=\"in\",\n    axis_ticks_direction_y=\"out\",\n)\n\n\n\n\n\n\n\n\n\n\nLegend_box\nNot all themeables that affect the legend box are demonstrated\n\n(\n    p1\n    + aes(fill=\"drat\")\n    + theme(\n        legend_position=\"left\",\n        legend_direction=\"horizontal\",  # affected by the ncol=2\n        legend_box_margin=5,\n        legend_background=element_rect(color=purple, size=2, fill=\"white\"),\n        legend_box=\"vertical\",\n        legend_key=element_rect(fill=gray, alpha=0.3),\n        legend_title=element_text(color=orange, va=\"top\"),\n        legend_text=element_text(weight=\"bold\"),\n        legend_key_spacing=10,  # overridden\n        legend_key_spacing_x=15,\n        legend_key_spacing_y=5,\n    )\n    # so we can see legend_entry_spacing in action\n    + guides(color=guide_legend(ncol=2))\n)\n\n\n\n\n\n\n\n\n\n\nplot_background, panel_background and panel_border\n\np2 + theme(\n    plot_background=element_rect(fill=\"gray\", alpha=0.3),\n    panel_background=element_rect(fill=purple, alpha=0.2),\n    panel_border=element_rect(color=red, size=1),\n    panel_spacing=0.025,\n)\n\n\n\n\n\n\n\n\n\n\npanel_grid\n\np1 + theme(\n    panel_grid=element_line(color=purple),\n    panel_grid_major=element_line(size=1.4, alpha=1),\n    panel_grid_major_x=element_line(linetype=\"dashed\"),\n    panel_grid_major_y=element_line(linetype=\"dashdot\"),\n    panel_grid_minor=element_line(alpha=0.25),\n    panel_grid_minor_x=element_line(color=red),\n    panel_grid_minor_y=element_line(color=green),\n    panel_ontop=False,  # puts the points behind the grid\n)\n\n\n\n\n\n\n\n\n\n\nstrip_background, strip_align and strip_text\n\np2 + theme(\n    panel_spacing=0.025,\n    panel_background=element_rect(fill=gray, alpha=0.2),\n    strip_background=element_rect(color=purple, fill=orange, size=1.4, alpha=0.95),\n    strip_background_x=element_rect(x=1 / 6, width=2 / 3),  # you can get really crazy\n    strip_background_y=element_rect(),\n    strip_align=0,\n    strip_align_x=0.2,\n    strip_align_y=0.2,\n    strip_text=element_text(weight=\"bold\"),\n    strip_text_x=element_text(color=red),\n    strip_text_y=element_text(color=blue),\n)\n\n\n\n\n\n\n\n\n\n\naspect_ratio and figure_size\nThe aspect_ratio takes precedence over the figure_size, and it modifies the height. The effective width and height are:\nwidth = figure_size[0]\nheight = figure_size[0] * aspect_ratio\n\np1 + theme(\n    panel_background=element_rect(fill=gray, alpha=0.2),\n    figure_size=(8, 6),  # inches\n    aspect_ratio=1 / 3,  # height:width\n)"
  },
  {
    "objectID": "gallery/dev/theme_classic.html",
    "href": "gallery/dev/theme_classic.html",
    "title": "Classic",
    "section": "",
    "text": "from plotnine import ggplot, aes, labs, theme_classic, geom_point\nfrom plotnine.data import mtcars\n\n\n# Gallery, themes\n(\n    ggplot(mtcars, aes(x=\"wt\", y=\"mpg\", colour=\"factor(gear)\"))\n    + geom_point()\n    + labs(\n        title= \"Fuel economy declines as weight increases\",\n        subtitle=\"(1973-74)\",\n        caption=\"Data from the 1974 Motor Trend US magazine.\",\n        x=\"Weight (1000 lbs)\",\n        y=\"Fuel economy (mpg)\",\n        colour=\"Gears\"\n    )\n    + theme_classic()\n)"
  },
  {
    "objectID": "reference/examples/aes.html",
    "href": "reference/examples/aes.html",
    "title": "aes",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import ggplot, aes, geom_point\n\nMapping variables to the visual properties of a plot.\n\ndf = pd.DataFrame({\n    \"col1\": np.arange(11),\n    \"col2\": np.arange(11)\n})\n\n(\n    ggplot(df, aes(x=\"col1\", y=\"col2\"))\n    + geom_point()\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(df, aes(x=\"col1\", y=\"col2 ** 2\"))\n    + geom_point()\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(df, aes(x=\"col1\", y=\"np.square(col2)\"))\n    + geom_point()\n)\n\n\n\n\n\n\n\n\nThe first two positional arguments are x and y aesthetics. Any other aesthetic must be mapped with a keyword argument.\n\n(\n    ggplot(df, aes(\"col1\", \"np.square(col2)\", color=\"col2\"))\n    + geom_point(size=3)\n)"
  },
  {
    "objectID": "reference/examples/after_stat.html",
    "href": "reference/examples/after_stat.html",
    "title": "after_stat",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import ggplot, aes, after_stat, geom_bar, labs\n\ngeom_bar uses stat_count which by default maps the y aesthetic to the count which is the number of observations at a position.\n\ndf = pd.DataFrame({\n    \"var1\": [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]\n})\n\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar()\n)\n\n\n\n\n\n\n\n\nUsing the after_stat function, we can instead map to the prop which is the ratio of points in the panel at a position.\n\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar(aes(y=after_stat(\"prop\")))  # default is after_stat('count')\n)\n\n\n\n\n\n\n\n\nWith after_stat you can used the variables calculated by the stat in expressions. For example we use the count to calculated the prop.\n\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar(aes(y=after_stat(\"count / np.sum(count)\")))\n    + labs(y=\"prop\")\n)\n\n\n\n\n\n\n\n\nBy default geom_bar uses stat_count to compute a frequency table with the x aesthetic as the key column. As a result, any mapping (other than the x aesthetic is lost) to a continuous variable is lost (if you have a classroom and you compute a frequency table of the gender, you lose any other information like height of students).\nFor example, below fill='var1' has no effect, but the var1 variable has not been lost it has been turned into x aesthetic.\n\n(ggplot(df, aes(\"var1\")) + geom_bar(aes(fill=\"var1\")))\n\n\n\n\n\n\n\n\nWe use after_stat to map fill to the x aesthetic after it has been computed.\n\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar(aes(fill=after_stat(\"x\")))\n    + labs(fill=\"var1\")\n)"
  },
  {
    "objectID": "reference/examples/facet_wrap.html",
    "href": "reference/examples/facet_wrap.html",
    "title": "Facet wrap",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_point, labs, facet_wrap, theme\nfrom plotnine.data import mpg\n\nfacet_wrap() creates a collection of plots (facets), where each plot is differentiated by the faceting variable. These plots are wrapped into a certain number of columns or rows as specified by the user.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nBasic scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nFacet a discrete variable using facet_wrap():\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\"class\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nControl the number of rows and columns with the options nrow and ncol:\n\n# Selecting the number of columns to display\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\n        \"class\",\n        ncol=4,  # change the number of columns\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\n\n# Selecting the number of rows to display\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\n        \"class\",\n        nrow=4,  # change the number of columns\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nTo change the plot order of the facets, reorder the levels of the faceting variable in the data.\n\n# re-order categories\nmpg[\"class\"] = mpg[\"class\"].cat.reorder_categories(\n    [\"pickup\", \"suv\", \"minivan\", \"midsize\", \"compact\", \"subcompact\", \"2seater\"]\n)\n\n\n# facet plot with reorded drv category\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\"class\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nOrdinarily the facets are arranged horizontally (left-to-right from top to bottom). However if you would prefer a vertical layout (facets are arranged top-to-bottom, from left to right) use the dir option:\n\n# Facet plot with vertical layout\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\n        \"class\",\n        dir=\"v\",  # change to a vertical layout\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can choose if the scale of x- and y-axes are fixed or variable. Set the scales argument to free-y, free_x or free for a free scales on the y-axis, x-axis or both axes respectively. You may need to add spacing between the facets to ensure axis ticks and values are easy to read.\nA fixed scale is the default and does not need to be specified.\n\n# facet plot with free scales\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\n        \"class\",\n        scales=\"free_y\",  # set scales so y-scale varies with the data\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can add additional information to your facet labels, by using the labeller argument within the facet_wrap() command. Below we use labeller = 'label_both' to include the column name in the facet label.\n\n# facet plot with labeller\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap(\"class\", labeller=\"label_both\")\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can add two discrete variables to a facet:\n\n# add additional column for plotting exercise\nmpg[\"transmission\"] = mpg[\"trans\"].map(\n    lambda x: \"auto\" if \"auto\" in x else \"man\" if \"man\" in x else \"\"\n)\n\n\n# inspect new column transmission which identifies cars as having an automatic or manual transmission\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\ntransmission\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\nauto\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\nman\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\nman\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\nauto\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\nauto\n\n\n\n\n\n\n\n\n# facet plot with two variables on one facet\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + facet_wrap([\"class\", \"transmission\"])  # use a list to add additional facetting variables\n    + labs(x=\"displacement\", y=\"horsepower\")\n)"
  },
  {
    "objectID": "reference/examples/geom_abline.html",
    "href": "reference/examples/geom_abline.html",
    "title": "AB line",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_point, labs, geom_abline, facet_grid\nfrom plotnine.data import mpg\n\ngeom_abline() draws a line when the yintercept and gradient is supplied, and is useful as a guide.\n\n# inspect the data\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nIt’s useful to use geom_abline() with some data, so we start with a basic scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nNow layer a line over the scatter plot using geom_abline(). geom_abline() requires inputs for the slope (default slope is 1) and y-intercept (default value is [0,0]).\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_abline(\n        intercept=45,  # set the y-intercept value\n        slope=-5,  # set the slope value\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can plot two lines on one plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_abline(\n        intercept=[45, 45],  # add many lines to a plot using a list for the y-intercepts...\n        slope=[-5, -7],  # ... and for the slopes\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can change the look of the line:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_abline(\n        intercept=45,\n        slope=-5,\n        color=\"blue\",  # set line colour\n        size=2,  # set line thickness\n        linetype=\"dashed\",  # set line type\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\ngeom_abline() can be used with a facet plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_abline(intercept=45, slope=-5)  # add a line ...\n    + facet_grid(\"drv\")  # ... to a facet plot.\n    + labs(x=\"displacement\", y=\"horsepower\")\n)"
  },
  {
    "objectID": "reference/examples/geom_bar.html",
    "href": "reference/examples/geom_bar.html",
    "title": "Bar chart",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_bar, labs, coord_flip, theme_classic\nfrom plotnine.data import mpg\n\ngeom_bar() makes the height of the bar proportional to the number of cases in each group\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\n\nBar Plot with Counts\n\n# Gallery, distributions\nggplot(mpg) + geom_bar(aes(x=\"class\"))\n\n\n\n\n\n\n\n\n\n\nSorting the bars\nWe can use the internal function reorder to sort the bars depending on the size of each group. In this case we create a variable class2 with values equal to those of class so because class is a reserved name and:\nreorder(class, class, len)\nis not a valid python expression, while:\nreorder(class2, class2, len)\nis a valid python expression.\n\nmpg[\"class2\"] = mpg[\"class\"]\n\n(\n    ggplot(mpg)\n    + geom_bar(aes(x=\"reorder(class2, class2, len)\"))\n    + labs(x=\"class\")\n)\n\n\n\n\n\n\n\n\nAnd in descending order\n\n(\n    ggplot(mpg)\n    + geom_bar(\n        aes(x=\"reorder(class2, class2, len, ascending=False)\")\n    )\n    + labs(x=\"class\")\n)\n\n\n\n\n\n\n\n\n\n(\n    ggplot(mpg)\n    + geom_bar(aes(x=\"class\", fill=\"drv\"))\n)\n\n\n\n\n\n\n\n\n\n\nHorizontal Bar Plot with Counts\n\n# Gallery, distributions\n(\n    ggplot(mpg) \n    + geom_bar(aes(x=\"class\", fill=\"drv\"))\n    + coord_flip()\n    + theme_classic()\n)"
  },
  {
    "objectID": "reference/examples/geom_col.html",
    "href": "reference/examples/geom_col.html",
    "title": "Two Variable Bar Plot",
    "section": "",
    "text": "import pandas as pd\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_col,\n    geom_text,\n    position_dodge,\n    lims,\n    theme,\n    element_text,\n    element_blank,\n    element_rect,\n    element_line,\n)\n\nVisualising on a single plot the values of a variable that has nested (and independent) variables\nCreate the data\n\ndf = pd.DataFrame(\n    {\n        \"variable\": [\n            \"gender\",\n            \"gender\",\n            \"age\",\n            \"age\",\n            \"age\",\n            \"income\",\n            \"income\",\n            \"income\",\n            \"income\",\n        ],\n        \"category\": [\n            \"Female\",\n            \"Male\",\n            \"1-24\",\n            \"25-54\",\n            \"55+\",\n            \"Lo\",\n            \"Lo-Med\",\n            \"Med\",\n            \"High\",\n        ],\n        \"value\": [60, 40, 50, 30, 20, 10, 25, 25, 40],\n    }\n)\ndf[\"variable\"] = pd.Categorical(df[\"variable\"], categories=[\"gender\", \"age\", \"income\"])\ndf[\"category\"] = pd.Categorical(df[\"category\"], categories=df[\"category\"])\n\ndf\n\n\n\n\n\n\n\n\nvariable\ncategory\nvalue\n\n\n\n\n0\ngender\nFemale\n60\n\n\n1\ngender\nMale\n40\n\n\n2\nage\n1-24\n50\n\n\n3\nage\n25-54\n30\n\n\n4\nage\n55+\n20\n\n\n5\nincome\nLo\n10\n\n\n6\nincome\nLo-Med\n25\n\n\n7\nincome\nMed\n25\n\n\n8\nincome\nHigh\n40\n\n\n\n\n\n\n\nWe want to visualise this data and at a galance get an idea to how the value breaks down along the categorys for the different variable. Note that each variable has different categorys.\nFirst we make a simple plot with all this information and see what to draw from it.\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col()\n)\n\n\n\n\n\n\n\n\nAll the values along each variable add up to 100, but stacked together the difference within and without the groups is not clear. The solution is to dodge the bars.\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col(stat=\"identity\", position=\"dodge\")  # modified\n)  \n\n\n\n\n\n\n\n\nThis is good, it gives us the plot we want but the legend is not great. Each variable has a different set of categorys, but the legend has them all clamped together. We cannot easily change the legend, but we can replicate it’s purpose by labelling the individual bars.\nTo do this, we create a geom_text with position_dodge(width=0.9) to match the ratio of the space taken up by each variable. If there was no spacing between the bars of different variables, we would have width=1.\nA minor quack, when text extends beyond the limits we have to manually make space or it would get clipped. Therefore we adjust the bottom y limits.\n\ndodge_text = position_dodge(width=0.9)  # new\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col(stat=\"identity\", position=\"dodge\", show_legend=False)  # modified\n    + geom_text(\n        aes(y=-0.5, label=\"category\"),  # new\n        position=dodge_text,\n        color=\"gray\",\n        size=8,\n        angle=45,\n        va=\"top\",\n    )\n    + lims(y=(-5, 60))  # new\n)\n\n\n\n\n\n\n\n\nWould it look too crowded if we add value labels on top of the bars?\n\ndodge_text = position_dodge(width=0.9)\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col(stat=\"identity\", position=\"dodge\", show_legend=False)\n    + geom_text(\n        aes(y=-0.5, label=\"category\"),\n        position=dodge_text,\n        color=\"gray\",\n        size=8,\n        angle=45,\n        va=\"top\",\n    )\n    + geom_text(\n        aes(label=\"value\"),  # new\n        position=dodge_text,\n        size=8,\n        va=\"bottom\",\n        format_string=\"{}%\",\n    )\n    + lims(y=(-5, 60))\n)\n\n\n\n\n\n\n\n\nThat looks okay. The values line up with the categorys because we used the same dodge parameters. For the final polish, we remove the y-axis, clear out the panel and make the variable and category labels have the same color.\n\n# Gallery, bars\n\ndodge_text = position_dodge(width=0.9)\nccolor = \"#555555\"\n\n(\n    ggplot(df, aes(x=\"variable\", y=\"value\", fill=\"category\"))\n    + geom_col(stat=\"identity\", position=\"dodge\", show_legend=False)\n    + geom_text(\n        aes(y=-0.5, label=\"category\"),\n        position=dodge_text,\n        color=ccolor,\n        size=8,\n        angle=45,\n        va=\"top\",\n    )  # modified\n    + geom_text(\n        aes(label=\"value\"),\n        position=dodge_text,\n        size=8,\n        va=\"bottom\",\n        format_string=\"{}%\",\n    )\n    + lims(y=(-5, 60))\n    + theme(\n        panel_background=element_rect(fill=\"white\"),  # new\n        axis_title_y=element_blank(),\n        axis_line_x=element_line(color=\"black\"),\n        axis_line_y=element_blank(),\n        axis_text_y=element_blank(),\n        axis_text_x=element_text(color=ccolor),\n        axis_ticks_major_y=element_blank(),\n        panel_grid=element_blank(),\n        panel_border=element_blank(),\n    )\n)\n\n\n\n\n\n\n\n\nCredit: I saved a plot this example is based on a while ago and forgot/misplaced the link to the source. The user considered it a minor coup."
  },
  {
    "objectID": "reference/examples/geom_density.html",
    "href": "reference/examples/geom_density.html",
    "title": "plotnine {{< var version >}}",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    after_stat,\n    geom_density,\n    geom_histogram,\n    geom_vline,\n    geom_rect,\n    labs,\n    annotate,\n    theme_tufte,\n)\nfrom plotnine.data import mpg\n\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nThe defaults are not exactly beautiful, but still quite clear.\n\nBasic Density Plot\n\n# Gallery, distributions\n(\n    ggplot(mpg, aes(x=\"cty\"))\n    + geom_density()\n)\n\n\n\n\n\n\n\n\nPlotting multiple groups is straightforward, but as each group is plotted as an independent PDF summing to 1, the relative size of each group will be normalized.\n\n\nDensity Plot with Groups\n\n# Gallery, distributions\n(\n    ggplot(mpg, aes(x=\"cty\", color=\"drv\", fill=\"drv\"))\n    + geom_density(alpha=0.1)\n)\n\n\n\n\n\n\n\n\nTo plot multiple groups and scale them by their relative size, you can map the y aesthetic to 'count' (calculated by stat_density).\n\n(\n    ggplot(mpg, aes(x=\"cty\", color=\"drv\", fill=\"drv\"))\n    + geom_density(aes(y=after_stat(\"count\")), alpha=0.1)\n)\n\n\n\n\n\n\n\n\n\n\nDensity Plots + Histograms\nTo overlay a histogram onto the density, the y aesthetic of the density should be mapped to the 'count' scaled by the binwidth of the histograms.\nWhy?\nThe count calculated by stat_density is \\(count = density * n\\) where n is the number of points . The density curves have an area of 1 and have no information about the absolute frequency of the values along curve; only the relative frequencies. The count curve reveals the absolute frequencies. The scale of this count corresponds to the count calculated by the stat_bin for the histogram when the bins are 1 unit wide i.e. binwidth=1. The count * binwidth curve matches the scale of counts for the histogram for a give binwidth.\n\n# Gallery, distributions\n\nbinwidth = 2  # The same for geom_density and geom_histogram\n\n(\n    ggplot(mpg, aes(x=\"cty\", color=\"drv\", fill=\"drv\"))\n    + geom_density(aes(y=after_stat(\"count*binwidth\")), alpha=0.1)\n    + geom_histogram(\n        aes(fill=\"drv\", y=after_stat(\"count\")),\n        binwidth=binwidth,\n        color=\"none\",\n        alpha=0.5,\n    )\n    # It is the histogram that gives us the meaningful y axis label\n    # i.e. 'count' and not 'count*2'\n    + labs(y=\"count\")\n)\n\n\n\n\n\n\n\n\n\n\nShaded Range Under a Density Plot\nExtending geom_density to create an effect of a shaded range\nCreate some data and plot the density\n\nn = 101\ndf = pd.DataFrame({\"x\": np.arange(n)})\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n)\n\n\n\n\n\n\n\n\nSuppose we want to mark a region as special e.g. (40, 60), we can use vertical lines to annotate it.\n\nregion = (40, 60)\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n    + annotate(geom_vline, xintercept=region)  # new line\n)\n\n\n\n\n\n\n\n\nTo make it standout more we can highlight. To do that, the first thought is to use a rectangle.\n\nregion = (40, 60)\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n    + annotate(\n        geom_rect, xmin=region[0], xmax=region[1], ymin=0, ymax=float(\"inf\"), alpha=0.5\n    )  # new annotation layer\n    + annotate(geom_vline, xintercept=region)\n)\n\n\n\n\n\n\n\n\nSince y upper-bound varies along the curve, a rectangular highlight has to stretch up to the top of the panel.\nTo hightlight only within the density curve, we have to use a second density curve. We need to calculate the density as normal, but just before the curve & region are plotted, we should keep only the region we want.\nWe create our own geom_density_highlight and override the setup_data method. First, we override but do nothing, we only inspect the data to see what we have to work with.\n\n# new class\nclass geom_density_highlight(geom_density):\n    def setup_data(self, data):\n        data = super().setup_data(data)\n        print(data)\n        return data\n\n\nregion = (40, 60)\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n    + geom_density_highlight(fill=\"black\", alpha=0.5)  # new line\n    + annotate(geom_vline, xintercept=region)\n)\n\n      PANEL     count   density  group    n    scaled           x         y  \\\n0         1  0.519038  0.005139     -1  101  0.519039    0.000000  0.005139   \n1         1  0.522757  0.005176     -1  101  0.522758    0.097752  0.005176   \n2         1  0.526473  0.005213     -1  101  0.526474    0.195503  0.005213   \n3         1  0.530187  0.005249     -1  101  0.530188    0.293255  0.005249   \n4         1  0.533899  0.005286     -1  101  0.533900    0.391007  0.005286   \n...     ...       ...       ...    ...  ...       ...         ...       ...   \n1019      1  0.533899  0.005286     -1  101  0.533900   99.608993  0.005286   \n1020      1  0.530187  0.005249     -1  101  0.530188   99.706745  0.005249   \n1021      1  0.526473  0.005213     -1  101  0.526474   99.804497  0.005213   \n1022      1  0.522757  0.005176     -1  101  0.522758   99.902248  0.005176   \n1023      1  0.519038  0.005139     -1  101  0.519039  100.000000  0.005139   \n\n      ymin      ymax  \n0        0  0.005139  \n1        0  0.005176  \n2        0  0.005213  \n3        0  0.005249  \n4        0  0.005286  \n...    ...       ...  \n1019     0  0.005286  \n1020     0  0.005249  \n1021     0  0.005213  \n1022     0  0.005176  \n1023     0  0.005139  \n\n[1024 rows x 10 columns]\n\n\n\n\n\n\n\n\n\nThe highlight has filled the whole region, but the printed data suggests that we can limit the rows to those where x column is within our region.\n\nclass geom_density_highlight(geom_density):\n    # new method\n    def __init__(self, *args, region=(-np.inf, np.inf), **kwargs):\n        super().__init__(*args, **kwargs)\n        self.region = region\n\n    def setup_data(self, data):\n        data = super().setup_data(data)\n        s = f\"{self.region[0]} &lt;= x &lt;= {self.region[1]}\"  # new line\n        data = data.query(s).reset_index(drop=True)  # new line\n        return data\n\n\nregion = (40, 60)\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density()\n    + geom_density_highlight(region=region, fill=\"black\", alpha=0.5)  # modified line\n    + annotate(geom_vline, xintercept=region)\n)\n\n\n\n\n\n\n\n\nThat is it, but we can make it look better.\n\n# Gallery, distributions\n\nclass geom_density_highlight(geom_density):\n    def __init__(self, *args, region=(-np.inf, np.inf), **kwargs):\n        super().__init__(*args, **kwargs)\n        self.region = region\n\n    def setup_data(self, data):\n        data = super().setup_data(data)\n        s = f\"{self.region[0]} &lt;= x &lt;= {self.region[1]}\"\n        data = data.query(s).reset_index(drop=True)\n        return data\n\n\nregion = (40, 60)\nteal = \"#029386\"\n\n\n(\n    ggplot(df, aes(\"x\"))\n    + geom_density_highlight(region=region, fill=teal + \"88\", color=\"none\")\n    + geom_density(fill=teal + \"44\", color=teal, size=0.7)\n    + annotate(geom_vline, xintercept=region, color=teal, size=0.7)\n    + theme_tufte()\n)\n\n\n\n\n\n\n\n\nThis example was motivated by a question from github user Rishika-Ravindran."
  },
  {
    "objectID": "reference/examples/geom_hline.html",
    "href": "reference/examples/geom_hline.html",
    "title": "Horizontal line",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_point, geom_hline, facet_grid, labs\nfrom plotnine.data import mpg\n\ngeom_hline() draws a vertical line, and is useful as a guide.\n\nmpg.head()\n\n\n\n\n\n\n\n\nmanufacturer\nmodel\ndispl\nyear\ncyl\ntrans\ndrv\ncty\nhwy\nfl\nclass\n\n\n\n\n0\naudi\na4\n1.8\n1999\n4\nauto(l5)\nf\n18\n29\np\ncompact\n\n\n1\naudi\na4\n1.8\n1999\n4\nmanual(m5)\nf\n21\n29\np\ncompact\n\n\n2\naudi\na4\n2.0\n2008\n4\nmanual(m6)\nf\n20\n31\np\ncompact\n\n\n3\naudi\na4\n2.0\n2008\n4\nauto(av)\nf\n21\n30\np\ncompact\n\n\n4\naudi\na4\n2.8\n1999\n6\nauto(l5)\nf\n16\n26\np\ncompact\n\n\n\n\n\n\n\nIt’s useful to use geom_hline() with some data, so we start with a basic scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nNow add a horizontal line to the scatter plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_hline(yintercept=25)  # add one horizonal line\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can add many horizontal lines:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_hline(yintercept=[25, 35, 45])  # add many horizontal lines using a list\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nYou can change the look of the line:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_hline(\n        yintercept=25,\n        color=\"yellow\",  # set line colour\n        size=2,  # set line thickness\n        linetype=\"dashed\",  # set line type\n    )\n    + labs(x=\"displacement\", y=\"horsepower\")\n)\n\n\n\n\n\n\n\n\nAnd you can add horizontal lines to a facet plot:\n\n(\n    ggplot(mpg, aes(x=\"displ\", y=\"hwy\"))\n    + geom_point()\n    + geom_hline(yintercept=25)  # add a vertical line...\n    + facet_grid(\"drv\")  # ... to a facet plot\n    + labs(x=\"displacement\", y=\"horsepower\")\n)"
  },
  {
    "objectID": "reference/examples/geom_linerange.html",
    "href": "reference/examples/geom_linerange.html",
    "title": "Upper & Lower Trends",
    "section": "",
    "text": "import pandas as pd\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    geom_line,\n    geom_linerange,\n    element_blank,\n    element_rect,\n    theme,\n    theme_matplotlib,\n    theme_set,\n)\n\n# Set default theme\n# matplotlib + the background of 538\ntheme_set(\n    theme_matplotlib()\n    + theme(\n        plot_background=element_rect(fill=\"#F0F0F0\"),\n        panel_background=element_rect(fill=\"#F0F0F0\"),\n    )\n)\n\nThe data\n\ndf = pd.DataFrame({\n    \"x\": range(0, 6),\n    \"y\": [3, 4, 3.5, 4.5, 4, 4]\n})\n\nCreate the line ranges\n\n(ggplot(df, aes(\"x\", \"y\"))\n + geom_linerange(aes(ymin=\"y-2\", ymax=\"y\"))\n)\n\n\n\n\n\n\n\n\nAdd points at each end of the ranges.\n\n(ggplot(df, aes(\"x\", \"y\"))\n + geom_linerange(aes(ymin=\"y-2\", ymax=\"y\"))\n + geom_point()\n + geom_point(aes(y=\"y-2\"))\n\n)\n\n\n\n\n\n\n\n\nAdd a trend-line along the top of the ranges and one along the bottom of the ranges. The line is added before(below) the points.\n\n(ggplot(df, aes(\"x\", \"y\"))\n + geom_linerange(aes(ymin=\"y-2\", ymax=\"y\"))\n \n + geom_line()\n + geom_point()\n\n + geom_line(aes(y=\"y-2\"))\n + geom_point(aes(y=\"y-2\"))\n\n)\n\n\n\n\n\n\n\n\nAdd some color.\n\n# Gallery, lines\nmagenta = \"#9E2F68\"\nmagenta_light = \"#E5C8D6\"\n\nsea_green = \"#2F9E65\"\nsea_green_light = \"#C8E5D7\"\n\n(ggplot(df, aes(\"x\", \"y\"))\n + geom_linerange(aes(ymin=\"y-2\", ymax=\"y\"))\n \n + geom_line(color=magenta, size=3)\n + geom_point(color=magenta, fill=magenta_light, size=3, stroke=0.5)\n \n + geom_line(aes(y=\"y-2\"), color=sea_green, size=3)\n + geom_point(aes(y=\"y-2\"), color=sea_green, fill=sea_green_light, size=3, stroke=0.5)\n)"
  },
  {
    "objectID": "reference/examples/geom_path.html",
    "href": "reference/examples/geom_path.html",
    "title": "Path plots",
    "section": "",
    "text": "import pandas as pd\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_path,\n    geom_line,\n    labs,\n    scale_color_continuous,\n    element_text,\n    theme,\n)\nfrom plotnine.data import economics\n\ngeom_path() connects the observations in the order in which they appear in the data, this is different from geom_line() which connects observations in order of the variable on the x axis.\n\neconomics.head(10)  # notice the rows are ordered by date\n\n\n\n\n\n\n\n\ndate\npce\npop\npsavert\nuempmed\nunemploy\n\n\n\n\n0\n1967-07-01\n507.4\n198712\n12.5\n4.5\n2944\n\n\n1\n1967-08-01\n510.5\n198911\n12.5\n4.7\n2945\n\n\n2\n1967-09-01\n516.3\n199113\n11.7\n4.6\n2958\n\n\n3\n1967-10-01\n512.9\n199311\n12.5\n4.9\n3143\n\n\n4\n1967-11-01\n518.1\n199498\n12.5\n4.7\n3066\n\n\n5\n1967-12-01\n525.8\n199657\n12.1\n4.8\n3018\n\n\n6\n1968-01-01\n531.5\n199808\n11.7\n5.1\n2878\n\n\n7\n1968-02-01\n534.2\n199920\n12.2\n4.5\n3001\n\n\n8\n1968-03-01\n544.9\n200056\n11.6\n4.1\n2877\n\n\n9\n1968-04-01\n544.6\n200208\n12.2\n4.6\n2709\n\n\n\n\n\n\n\nBecause the data is in date order geom_path() (in pint) produces the same result as geom_line() (in black):\n\n(\n    ggplot(economics, aes(x=\"date\", y=\"unemploy\"))\n    + geom_line(size=5)  # plot geom_line as the first layer\n    + geom_path(\n        colour=\"#ff69b4\",  # plot a path - colour pink\n        size=1,\n    )\n    + labs(x=\"date\", y=\"unemployment (,000)\")  # label x & y-axis\n)\n\n\n\n\n\n\n\n\nPlotting unemployment (scaled by population) versus savings rate shows how geom_path() differs from geom_line(). Because geom_path() connects the observations in the order in which they appear in the data, this line is like a “journey through time”:\n\n(\n    ggplot(economics, aes(x=\"unemploy/pop\", y=\"psavert\"))\n    + geom_path()  # plot geom path\n    + labs(x=\"scaled unemployment\", y=\"saving rate\")  # label x & y-axis\n)\n\n\n\n\n\n\n\n\nComparing geom_line() (black) to geom_path() (pink) shows how these two plots differ in what they can show: geom_path() shows the savings rate has gone down over time, which is not evident with geom_path().\n\n(\n    ggplot(economics, aes(x=\"unemploy/pop\", y=\"psavert\"))\n    + geom_path(\n        colour=\"#ff69b4\",  # plot geom_path as the first layer - colour pink\n        alpha=0.5,  # line transparency\n        size=2.5,\n    )  # line thickness\n    + geom_line()  # layer geom_line\n    + labs(x=\"scaled unemployment\", y=\"saving rate\")  # label x & y-axis\n)\n\n\n\n\n\n\n\n\nThe geom_path can be easier to interpret if time is coloured in. First convert time to a number, and use this number to colour the path:\n\n# convert date to a number\neconomics[\"date_as_number\"] = pd.to_numeric(economics[\"date\"])\n\n\n# inspect new column\neconomics.head()\n\n\n\n\n\n\n\n\ndate\npce\npop\npsavert\nuempmed\nunemploy\ndate_as_number\n\n\n\n\n0\n1967-07-01\n507.4\n198712\n12.5\n4.5\n2944\n-79056000000000000\n\n\n1\n1967-08-01\n510.5\n198911\n12.5\n4.7\n2945\n-76377600000000000\n\n\n2\n1967-09-01\n516.3\n199113\n11.7\n4.6\n2958\n-73699200000000000\n\n\n3\n1967-10-01\n512.9\n199311\n12.5\n4.9\n3143\n-71107200000000000\n\n\n4\n1967-11-01\n518.1\n199498\n12.5\n4.7\n3066\n-68428800000000000\n\n\n\n\n\n\n\nThe path is coloured such that it changes with time using the command aes(colour='date_as_number') within geom_path().\n\n# input\nlegend_breaks = [\n    -79056000000000000,\n    709948800000000000,\n    1401580800000000000,\n]  # used to modify colour-graded legend\nlegend_labels = [\"1967-Jul\", \"1992-Jun\", \"2014-Jun\"]\n\n# plot\n(\n    ggplot(economics, aes(x=\"unemploy/pop\", y=\"psavert\"))\n    + geom_path(\n        aes(colour=\"date_as_number\")\n    )  # colour geom_path using time variable \"date_as_number\"\n    + labs(x=\"scaled unemployment\", y=\"saving rate\")\n    + scale_color_continuous(\n        breaks=legend_breaks,  # set legend breaks (where labels will appear)\n        labels=legend_labels,\n    )  # set labels on legend\n    + theme(legend_title=element_text(text=\"Date\"))  # set title of legend\n)"
  },
  {
    "objectID": "reference/examples/geom_segment.html",
    "href": "reference/examples/geom_segment.html",
    "title": "An Elaborate Range Plot",
    "section": "",
    "text": "# NOTE: This notebook uses the polars package\nimport numpy as np\n\nfrom plotnine import *\nimport polars as pl\nfrom polars import col\n\nComparing the point to point difference of many similar variables\nRead the data.\nSource: Pew Research Global Attitudes Spring 2015\n\n!head -n 20 \"data/survey-social-media.csv\"\n\nPSRAID,COUNTRY,Q145,Q146,Q70,Q74\n100000,Ethiopia,Female,35,No, \n100001,Ethiopia,Female,25,No, \n100002,Ethiopia,Male,40,Don’t know, \n100003,Ethiopia,Female,30,Don’t know, \n100004,Ethiopia,Male,22,No, \n100005,Ethiopia,Male,40,No, \n100006,Ethiopia,Female,20,No, \n100007,Ethiopia,Female,18,No,No\n100008,Ethiopia,Male,50,No, \n100009,Ethiopia,Male,35,No, \n100010,Ethiopia,Female,20,No, \n100011,Ethiopia,Female,30,Don’t know, \n100012,Ethiopia,Male,60,No, \n100013,Ethiopia,Male,18,No, \n100014,Ethiopia,Male,40,No, \n100015,Ethiopia,Male,28,Don’t know, \n100016,Ethiopia,Female,55,Don’t know, \n100017,Ethiopia,Male,30,Don’t know, \n100018,Ethiopia,Female,22,No, \n\n\n\ncolumns = dict(\n    COUNTRY=\"country\",\n    Q145=\"gender\",\n    Q146=\"age\",\n    Q70=\"use_internet\",\n    Q74=\"use_social_media\",\n)\n\ndata = (\n    pl.scan_csv(\n        \"data/survey-social-media.csv\",\n        schema_overrides=dict(Q146=pl.Utf8),\n    )\n    .rename(columns)\n    .select([\"country\", \"age\", \"use_social_media\"])\n    .collect()\n)\n\ndata.sample(10, seed=123)\n\n\nshape: (10, 3)\n\n\n\ncountry\nage\nuse_social_media\n\n\nstr\nstr\nstr\n\n\n\n\n\"India\"\n\"23\"\n\" \"\n\n\n\"Pakistan\"\n\"18\"\n\" \"\n\n\n\"Peru\"\n\"39\"\n\"Yes\"\n\n\n\"Jordan\"\n\"56\"\n\" \"\n\n\n\"United Kingdom\"\n\"35\"\n\"Yes\"\n\n\n\"Chile\"\n\"24\"\n\"Yes\"\n\n\n\"Israel\"\n\"32\"\n\"No\"\n\n\n\"Pakistan\"\n\"39\"\n\"No\"\n\n\n\"Chile\"\n\"26\"\n\"Yes\"\n\n\n\"Nigeria\"\n\"43\"\n\"Yes\"\n\n\n\n\n\n\nCreate age groups for users of social media\n\nyes_no = [\"Yes\", \"No\"]\nvalid_age_groups = [\"18-34\", \"35-49\", \"50+\"]\n\nrdata = (\n    data.with_columns(\n        age_group=pl.when(col(\"age\") &lt;= \"34\")\n        .then(pl.lit(\"18-34\"))\n        .when(col(\"age\") &lt;= \"49\")\n        .then(pl.lit(\"35-49\"))\n        .when(col(\"age\") &lt; \"98\")\n        .then(pl.lit(\"50+\"))\n        .otherwise(pl.lit(\"\")),\n        country_count=pl.len().over(\"country\"),\n    )\n    .filter(\n        col(\"age_group\").is_in(valid_age_groups) & col(\"use_social_media\").is_in(yes_no)\n    )\n    .group_by([\"country\", \"age_group\"])\n    .agg(\n        # social media use percentage\n        sm_use_percent=(col(\"use_social_media\") == \"Yes\").sum() * 100 / pl.len(),\n        # social media question response rate\n        smq_response_rate=col(\"use_social_media\").is_in(yes_no).sum()\n        * 100\n        / col(\"country_count\").first(),\n    )\n    .sort([\"country\", \"age_group\"])\n)\n\nrdata.head()\n\n\nshape: (5, 4)\n\n\n\ncountry\nage_group\nsm_use_percent\nsmq_response_rate\n\n\nstr\nstr\nf64\nf64\n\n\n\n\n\"Argentina\"\n\"18-34\"\n90.883191\n35.1\n\n\n\"Argentina\"\n\"35-49\"\n84.40367\n21.8\n\n\n\"Argentina\"\n\"50+\"\n67.333333\n15.0\n\n\n\"Australia\"\n\"18-34\"\n90.862944\n19.621514\n\n\n\"Australia\"\n\"35-49\"\n78.04878\n20.418327\n\n\n\n\n\n\nTop 14 countries by response rate to the social media question.\n\ndef format_column(column, fmt):\n    \"\"\"Format column using python format\"\"\"\n    def _fmt(s):\n        return pl.Series([fmt.format(x) if x is not None else x for x in s])\n    return pl.col(column).map_batches(_fmt)\n\nn = 14\n\ntop = (\n    rdata.group_by(\"country\")\n    .agg(r=col(\"smq_response_rate\").sum())\n    .sort(\"r\", descending=True)\n    .head(n)\n)\ntop_countries = set(top[\"country\"])\n\npoint_data = rdata.filter(col(\"country\").is_in(top_countries)).with_columns(\n    col(\"country\").cast(pl.Categorical),\n    sm_use_percent_str=pl.when(\n        col(\"country\")==\"United States\"\n    ).then(\n        format_column(\"sm_use_percent\", \"{:.0f}%\")\n    ).otherwise(\n        format_column(\"sm_use_percent\", \"{:.0f}\")\n    )\n)\n\npoint_data.head()\n\n\nshape: (5, 5)\n\n\n\ncountry\nage_group\nsm_use_percent\nsmq_response_rate\nsm_use_percent_str\n\n\ncat\nstr\nf64\nf64\nstr\n\n\n\n\n\"Australia\"\n\"18-34\"\n90.862944\n19.621514\n\"91\"\n\n\n\"Australia\"\n\"35-49\"\n78.04878\n20.418327\n\"78\"\n\n\n\"Australia\"\n\"50+\"\n48.479087\n52.390438\n\"48\"\n\n\n\"Canada\"\n\"18-34\"\n92.063492\n25.099602\n\"92\"\n\n\n\"Canada\"\n\"35-49\"\n75.925926\n21.513944\n\"76\"\n\n\n\n\n\n\n\nsegment_data = (\n    point_data.group_by(\"country\")\n    .agg(\n        min=col(\"sm_use_percent\").min(),\n        max=col(\"sm_use_percent\").max(),\n    )\n    .with_columns(gap=(col(\"max\") - col(\"min\")))\n    .sort(\n        \"gap\",\n    )\n    .with_columns(\n        min_str=format_column(\"min\", \"{:.0f}\"),\n        max_str=format_column(\"max\", \"{:.0f}\"),\n        gap_str=format_column(\"gap\", \"{:.0f}\"),\n    )\n)\n\nsegment_data.head()\n\n\nshape: (5, 7)\n\n\n\ncountry\nmin\nmax\ngap\nmin_str\nmax_str\ngap_str\n\n\ncat\nf64\nf64\nf64\nstr\nstr\nstr\n\n\n\n\n\"Russia\"\n76.07362\n95.151515\n19.077896\n\"76\"\n\"95\"\n\"19\"\n\n\n\"Israel\"\n55.405405\n88.311688\n32.906283\n\"55\"\n\"88\"\n\"33\"\n\n\n\"United Kingdom\"\n52.74463\n86.096257\n33.351627\n\"53\"\n\"86\"\n\"33\"\n\n\n\"United States\"\n52.597403\n88.669951\n36.072548\n\"53\"\n\"89\"\n\"36\"\n\n\n\"Canada\"\n53.986333\n92.063492\n38.077159\n\"54\"\n\"92\"\n\"38\"\n\n\n\n\n\n\nFormat the floating point data that will be plotted into strings\nFirst plot\n\n# The right column (youngest-oldest gap) location\nxgap = 112\n\n(\n    ggplot()\n    # Range strip\n    + geom_segment(\n        segment_data,\n        aes(x=\"min\", xend=\"max\", y=\"country\", yend=\"country\"),\n        size=6,\n        color=\"#a7a9ac\",\n    )\n    # Age group markers\n    + geom_point(\n        point_data,\n        aes(\"sm_use_percent\", \"country\", color=\"age_group\", fill=\"age_group\"),\n        size=5,\n        stroke=0.7,\n    )\n    # Age group percentages\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"50+\"),\n        aes(\n            x=\"sm_use_percent-2\",\n            y=\"country\",\n            label=\"sm_use_percent_str\",\n            color=\"age_group\",\n        ),\n        size=8,\n        ha=\"right\",\n        va=\"center_baseline\",\n    )\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"35-49\"),\n        aes(x=\"sm_use_percent+2\", y=\"country\", label=\"sm_use_percent_str\"),\n        size=8,\n        ha=\"left\",\n        va=\"center_baseline\",\n        color=\"white\",\n    )\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"18-34\"),\n        aes(\n            x=\"sm_use_percent+2\",\n            y=\"country\",\n            label=\"sm_use_percent_str\",\n            color=\"age_group\",\n        ),\n        size=8,\n        ha=\"left\",\n        va=\"center_baseline\",\n    )\n    # gap difference\n    + geom_text(\n        segment_data,\n        aes(x=xgap, y=\"country\", label=\"gap_str\"),\n        size=9,\n        fontweight=\"bold\",\n        format_string=\"+{}\",\n    )\n)\n\n\n\n\n\n\n\n\nTweak it\n\n# Gallery, elaborate\n\n# The right column (youngest-oldest gap) location\nxgap = 115\n\n(\n    ggplot()\n    # Background Strips                                     # new\n    + geom_segment(\n        segment_data,\n        aes(y=\"country\", yend=\"country\"),\n        x=0,\n        xend=101,\n        size=8.5,\n        color=\"#edece3\",\n    )\n    # vertical grid lines along the strips                  # new\n    + annotate(\n        \"segment\",\n        x=list(range(10, 100, 10)) * n,\n        xend=list(range(10, 100, 10)) * n,\n        y=np.tile(np.arange(1, n + 1), 9) - 0.25,\n        yend=np.tile(np.arange(1, n + 1), 9) + 0.25,\n        color=\"#CCCCCC\",\n    )\n    # Range strip\n    + geom_segment(\n        segment_data,\n        aes(x=\"min\", xend=\"max\", y=\"country\", yend=\"country\"),\n        size=6,\n        color=\"#a7a9ac\",\n    )\n    # Age group markers\n    + geom_point(\n        point_data,\n        aes(\"sm_use_percent\", \"country\", color=\"age_group\", fill=\"age_group\"),\n        size=5,\n        stroke=0.7,\n    )\n    # Age group percentages\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"50+\"),\n        aes(\n            x=\"sm_use_percent-2\",\n            y=\"country\",\n            label=\"sm_use_percent_str\",\n            color=\"age_group\",\n        ),\n        size=8,\n        ha=\"right\",\n        va=\"center_baseline\",\n    )\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"35-49\"),\n        aes(x=\"sm_use_percent+2\", y=\"country\", label=\"sm_use_percent_str\"),\n        size=8,\n        ha=\"left\",\n        va=\"center_baseline\",\n        color=\"white\",\n    )\n    + geom_text(\n        point_data.filter(col(\"age_group\") == \"18-34\"),\n        aes(\n            x=\"sm_use_percent+2\",\n            y=\"country\",\n            label=\"sm_use_percent_str\",\n            color=\"age_group\",\n        ),\n        size=8,\n        ha=\"left\",\n        va=\"center_baseline\",\n    )\n    # countries right-hand-size (instead of y-axis)         # new\n    + geom_text(\n        segment_data,\n        aes(y=\"country\", label=\"country\"),\n        x=-1,\n        size=8,\n        ha=\"right\",\n        va=\"center_baseline\",\n        fontweight=\"bold\",\n        color=\"#222222\",\n    )\n    # gap difference\n    + geom_vline(xintercept=xgap, color=\"#edece3\", size=32)  # new\n    + geom_text(\n        segment_data,\n        aes(x=xgap, y=\"country\", label=\"gap_str\"),\n        size=9,\n        va=\"center_baseline\",\n        fontweight=\"bold\",\n        format_string=\"+{}\",\n    )\n    # Annotations                                            # new\n    + annotate(\"text\", x=31, y=n + 1.1, label=\"50+\", size=9, color=\"#ea9f2f\", va=\"top\")\n    + annotate(\n        \"text\", x=56, y=n + 1.1, label=\"35-49\", size=9, color=\"#6d6e71\", va=\"top\"\n    )\n    + annotate(\n        \"text\", x=85, y=n + 1.1, label=\"18-34\", size=9, color=\"#939c49\", va=\"top\"\n    )\n    + annotate(\n        \"text\",\n        x=xgap,\n        y=n + 0.5,\n        label=\"Youngest-\\nOldest Gap\",\n        size=9,\n        color=\"#444444\",\n        va=\"bottom\",\n        ha=\"center\",\n    )\n    + annotate(\"point\", x=[31, 56, 85], y=n + 0.3, alpha=0.85, stroke=0)\n    + annotate(\n        \"segment\",\n        x=[31, 56, 85],\n        xend=[31, 56, 85],\n        y=n + 0.3,\n        yend=n + 0.8,\n        alpha=0.85,\n    )\n    + annotate(\n        \"hline\",\n        yintercept=[x + 0.5 for x in range(2, n, 2)],\n        alpha=0.5,\n        linetype=\"dotted\",\n        size=0.7,\n    )\n\n    # Better spacing and color                              # new\n    + scale_x_continuous(limits=(-18, xgap + 2))\n    + scale_y_discrete(expand=(0, 0.25, 0.1, 0))\n    + scale_fill_manual(values=[\"#c3ca8c\", \"#d1d3d4\", \"#f2c480\"])\n    + scale_color_manual(values=[\"#939c49\", \"#6d6e71\", \"#ea9f2f\"])\n    + guides(color=None, fill=None)\n    + theme_void()\n    + theme(figure_size=(8, 8.5))\n)\n\n\n\n\n\n\n\n\nInstead of looking at this plot as having a country variable on the y-axis and a percentage variable on the x-axis, we can view it as having vertically stacked up many indepedent variables, the values of which have a similar scale.\nProtip: Save a pdf file.\n\nChange in Order\nComparing a group of ranked items at two different times\nRead the data.\nSource: World Bank - Infanct Mortality Rate (per 1,000 live births)b\n\ndata = pl.read_csv(\n    \"data/API_SP.DYN.IMRT.IN_DS2_en_csv_v2/API_SP.DYN.IMRT.IN_DS2_en_csv_v2.csv\",\n    skip_rows=4,\n    null_values=\"\",\n    truncate_ragged_lines=True,\n)\n\n# Columns as valid python variables\nyear_columns = {c: f\"y{c}\" for c in data.columns if c[:2] in {\"19\", \"20\"}}\ndata = data.rename(\n    {\"Country Name\": \"country\", \"Country Code\": \"code\", **year_columns}\n).drop([\"Indicator Name\", \"Indicator Code\"])\ndata.head()\n\n\nshape: (5, 60)\n\n\n\ncountry\ncode\ny1960\ny1961\ny1962\ny1963\ny1964\ny1965\ny1966\ny1967\ny1968\ny1969\ny1970\ny1971\ny1972\ny1973\ny1974\ny1975\ny1976\ny1977\ny1978\ny1979\ny1980\ny1981\ny1982\ny1983\ny1984\ny1985\ny1986\ny1987\ny1988\ny1989\ny1990\ny1991\ny1992\ny1993\ny1994\ny1995\ny1996\ny1997\ny1998\ny1999\ny2000\ny2001\ny2002\ny2003\ny2004\ny2005\ny2006\ny2007\ny2008\ny2009\ny2010\ny2011\ny2012\ny2013\ny2014\ny2015\ny2016\n\n\n\nstr\nstr\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nstr\nstr\n\n\n\n\n\"Aruba\"\n\"ABW\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n\n\n\"Afghanistan\"\n\"AFG\"\nnull\n240.5\n236.3\n232.3\n228.5\n224.6\n220.7\n217.0\n213.3\n209.8\n206.1\n202.2\n198.2\n194.3\n190.3\n186.6\n182.6\n178.7\n174.5\n170.4\n166.1\n161.8\n157.5\n153.2\n148.7\n144.5\n140.2\n135.7\n131.3\n126.8\n122.5\n118.3\n114.4\n110.9\n107.7\n105.0\n102.7\n100.7\n98.9\n97.2\n95.4\n93.4\n91.2\n89.0\n86.7\n84.4\n82.3\n80.4\n78.6\n76.8\n75.1\n73.4\n71.7\n69.9\n68.1\n66.3\nnull\nnull\n\n\n\"Angola\"\n\"AGO\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n138.3\n137.5\n136.8\n136.0\n135.3\n134.9\n134.4\n134.1\n133.8\n133.6\n133.5\n133.5\n133.5\n133.4\n133.2\n132.8\n132.3\n131.5\n130.6\n129.5\n128.3\n126.9\n125.5\n124.1\n122.8\n121.2\n119.4\n117.1\n114.7\n112.2\n109.6\n106.8\n104.1\n101.4\n98.8\n96.0\nnull\nnull\n\n\n\"Albania\"\n\"ALB\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n73.0\n68.4\n64.0\n59.9\n56.1\n52.4\n49.1\n45.9\n43.2\n40.8\n38.6\n36.7\n35.1\n33.7\n32.5\n31.4\n30.3\n29.1\n27.9\n26.8\n25.5\n24.4\n23.2\n22.1\n21.0\n20.0\n19.1\n18.3\n17.4\n16.7\n16.0\n15.4\n14.8\n14.3\n13.8\n13.3\n12.9\n12.5\nnull\nnull\n\n\n\"Andorra\"\n\"AND\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n7.5\n7.0\n6.5\n6.1\n5.6\n5.2\n5.0\n4.6\n4.3\n4.1\n3.9\n3.7\n3.5\n3.3\n3.2\n3.1\n2.9\n2.8\n2.7\n2.6\n2.5\n2.4\n2.3\n2.2\n2.1\n2.1\nnull\nnull\n\n\n\n\n\n\nThe data includes regional aggregates. To tell apart the regional aggregates we need the metadata. Every row in the data table has a corresponding row in the metadata table. Where the row has regional aggregate data, the Region column in the metadata table is NaN.\n\ndef ordered_categorical(s, categories=None):\n    \"\"\"\n    Create a categorical ordered according to the categories\n    \"\"\"\n    name = getattr(s, \"name\", \"\")\n    if categories is None:\n        return pl.Series(name, s).cast(pl.Categorical)\n\n    with pl.StringCache():\n        pl.Series(categories).cast(pl.Categorical)\n        return pl.Series(name, s).cast(pl.Categorical)\n\n\ncolumns = {\"Country Code\": \"code\", \"Region\": \"region\", \"IncomeGroup\": \"income_group\"}\n\nmetadata = (\n    pl.scan_csv(\n        \"data/API_SP.DYN.IMRT.IN_DS2_en_csv_v2/Metadata_Country_API_SP.DYN.IMRT.IN_DS2_en_csv_v2.csv\"\n    )\n    .rename(columns)\n    .select(list(columns.values()))\n    .filter(\n        # Drop the regional aggregate information\n        (col(\"region\") != \"\") & (col(\"income_group\") != \"\")\n    )\n    .collect()\n)\n\ncat_order = [\"High income\", \"Upper middle income\", \"Lower middle income\", \"Low income\"]\nmetadata = metadata.with_columns(\n    ordered_categorical(metadata[\"income_group\"], cat_order)\n)\n\nmetadata.head(10)\n\n\nshape: (10, 3)\n\n\n\ncode\nregion\nincome_group\n\n\nstr\nstr\ncat\n\n\n\n\n\"ABW\"\n\"Latin America & Caribbean\"\n\"High income\"\n\n\n\"AFG\"\n\"South Asia\"\n\"Low income\"\n\n\n\"AGO\"\n\"Sub-Saharan Africa\"\n\"Lower middle income\"\n\n\n\"ALB\"\n\"Europe & Central Asia\"\n\"Upper middle income\"\n\n\n\"AND\"\n\"Europe & Central Asia\"\n\"High income\"\n\n\n\"ARE\"\n\"Middle East & North Africa\"\n\"High income\"\n\n\n\"ARG\"\n\"Latin America & Caribbean\"\n\"Upper middle income\"\n\n\n\"ARM\"\n\"Europe & Central Asia\"\n\"Lower middle income\"\n\n\n\"ASM\"\n\"East Asia & Pacific\"\n\"Upper middle income\"\n\n\n\"ATG\"\n\"Latin America & Caribbean\"\n\"High income\"\n\n\n\n\n\n\nRemove the regional aggregates, to create a table with only country data\n\ncountry_data = data.join(metadata, on=\"code\")\ncountry_data.head()\n\n\nshape: (5, 62)\n\n\n\ncountry\ncode\ny1960\ny1961\ny1962\ny1963\ny1964\ny1965\ny1966\ny1967\ny1968\ny1969\ny1970\ny1971\ny1972\ny1973\ny1974\ny1975\ny1976\ny1977\ny1978\ny1979\ny1980\ny1981\ny1982\ny1983\ny1984\ny1985\ny1986\ny1987\ny1988\ny1989\ny1990\ny1991\ny1992\ny1993\ny1994\ny1995\ny1996\ny1997\ny1998\ny1999\ny2000\ny2001\ny2002\ny2003\ny2004\ny2005\ny2006\ny2007\ny2008\ny2009\ny2010\ny2011\ny2012\ny2013\ny2014\ny2015\ny2016\n\nregion\nincome_group\n\n\nstr\nstr\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nstr\nstr\nstr\ncat\n\n\n\n\n\"Aruba\"\n\"ABW\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n\"Latin America & Caribbean\"\n\"High income\"\n\n\n\"Afghanistan\"\n\"AFG\"\nnull\n240.5\n236.3\n232.3\n228.5\n224.6\n220.7\n217.0\n213.3\n209.8\n206.1\n202.2\n198.2\n194.3\n190.3\n186.6\n182.6\n178.7\n174.5\n170.4\n166.1\n161.8\n157.5\n153.2\n148.7\n144.5\n140.2\n135.7\n131.3\n126.8\n122.5\n118.3\n114.4\n110.9\n107.7\n105.0\n102.7\n100.7\n98.9\n97.2\n95.4\n93.4\n91.2\n89.0\n86.7\n84.4\n82.3\n80.4\n78.6\n76.8\n75.1\n73.4\n71.7\n69.9\n68.1\n66.3\nnull\nnull\n\"South Asia\"\n\"Low income\"\n\n\n\"Angola\"\n\"AGO\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n138.3\n137.5\n136.8\n136.0\n135.3\n134.9\n134.4\n134.1\n133.8\n133.6\n133.5\n133.5\n133.5\n133.4\n133.2\n132.8\n132.3\n131.5\n130.6\n129.5\n128.3\n126.9\n125.5\n124.1\n122.8\n121.2\n119.4\n117.1\n114.7\n112.2\n109.6\n106.8\n104.1\n101.4\n98.8\n96.0\nnull\nnull\n\"Sub-Saharan Africa\"\n\"Lower middle income\"\n\n\n\"Albania\"\n\"ALB\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n73.0\n68.4\n64.0\n59.9\n56.1\n52.4\n49.1\n45.9\n43.2\n40.8\n38.6\n36.7\n35.1\n33.7\n32.5\n31.4\n30.3\n29.1\n27.9\n26.8\n25.5\n24.4\n23.2\n22.1\n21.0\n20.0\n19.1\n18.3\n17.4\n16.7\n16.0\n15.4\n14.8\n14.3\n13.8\n13.3\n12.9\n12.5\nnull\nnull\n\"Europe & Central Asia\"\n\"Upper middle income\"\n\n\n\"Andorra\"\n\"AND\"\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n7.5\n7.0\n6.5\n6.1\n5.6\n5.2\n5.0\n4.6\n4.3\n4.1\n3.9\n3.7\n3.5\n3.3\n3.2\n3.1\n2.9\n2.8\n2.7\n2.6\n2.5\n2.4\n2.3\n2.2\n2.1\n2.1\nnull\nnull\n\"Europe & Central Asia\"\n\"High income\"\n\n\n\n\n\n\nWe are interested in the changes in rank between 1960 and 2015. To plot a reasonable sized graph, we randomly sample 35 countries.\n\nsampled_data = (\n    country_data.drop_nulls(subset=[\"y1960\", \"y2015\"])\n    .sample(n=35, seed=123)\n    .with_columns(\n        y1960_rank=col(\"y1960\").rank(method=\"ordinal\").cast(pl.Int64),\n        y2015_rank=col(\"y2015\").rank(method=\"ordinal\").cast(pl.Int64),\n    )\n    .sort(\"y2015_rank\", descending=True)\n)\n\nsampled_data.head()\n\n\nshape: (5, 64)\n\n\n\ncountry\ncode\ny1960\ny1961\ny1962\ny1963\ny1964\ny1965\ny1966\ny1967\ny1968\ny1969\ny1970\ny1971\ny1972\ny1973\ny1974\ny1975\ny1976\ny1977\ny1978\ny1979\ny1980\ny1981\ny1982\ny1983\ny1984\ny1985\ny1986\ny1987\ny1988\ny1989\ny1990\ny1991\ny1992\ny1993\ny1994\ny1995\ny1996\ny1997\ny1998\ny1999\ny2000\ny2001\ny2002\ny2003\ny2004\ny2005\ny2006\ny2007\ny2008\ny2009\ny2010\ny2011\ny2012\ny2013\ny2014\ny2015\ny2016\n\nregion\nincome_group\ny1960_rank\ny2015_rank\n\n\nstr\nstr\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nstr\nstr\nstr\ncat\ni64\ni64\n\n\n\n\n\"Sierra Leone\"\n\"SLE\"\n223.6\n220.5\n217.5\n214.2\n211.0\n207.6\n204.2\n200.8\n197.3\n194.1\n191.0\n188.0\n185.2\n182.6\n180.0\n177.5\n175.3\n173.2\n171.2\n169.2\n167.3\n165.6\n164.1\n162.8\n161.5\n160.4\n159.4\n158.3\n157.6\n157.0\n156.5\n156.1\n155.7\n155.2\n154.5\n153.4\n152.0\n150.1\n148.1\n145.8\n143.3\n140.5\n137.7\n134.6\n131.4\n128.1\n124.5\n120.5\n116.2\n111.7\n107.0\n102.3\n97.9\n93.8\n90.2\n87.1\nnull\nnull\n\"Sub-Saharan Africa\"\n\"Low income\"\n35\n35\n\n\n\"Cote d'Ivoire\"\n\"CIV\"\n208.4\n203.0\n197.7\n192.8\n188.0\n183.3\n178.7\n174.2\n169.9\n165.4\n161.0\n156.4\n151.3\n146.1\n140.7\n135.1\n129.7\n124.7\n120.2\n116.6\n113.7\n111.4\n109.5\n108.0\n106.9\n106.1\n105.5\n105.2\n104.9\n104.9\n104.9\n104.8\n104.7\n104.7\n104.6\n104.4\n104.0\n103.3\n102.3\n101.0\n99.5\n97.7\n95.7\n93.6\n91.4\n88.9\n86.7\n84.1\n81.3\n79.0\n76.9\n75.0\n72.8\n70.6\n68.5\n66.6\nnull\nnull\n\"Sub-Saharan Africa\"\n\"Lower middle income\"\n33\n34\n\n\n\"Benin\"\n\"BEN\"\n186.9\n183.9\n180.6\n177.1\n173.6\n170.2\n166.8\n164.0\n161.5\n159.2\n157.1\n154.9\n152.5\n149.8\n146.8\n143.5\n140.1\n136.7\n133.6\n130.9\n128.7\n126.6\n124.7\n122.8\n120.9\n118.9\n116.9\n114.8\n112.6\n110.4\n108.0\n105.6\n103.2\n100.9\n98.9\n97.2\n95.6\n94.2\n92.7\n91.1\n89.3\n87.4\n85.2\n83.0\n80.8\n78.8\n76.9\n75.2\n73.7\n72.3\n71.0\n69.8\n68.5\n67.2\n65.7\n64.2\nnull\nnull\n\"Sub-Saharan Africa\"\n\"Low income\"\n32\n33\n\n\n\"Burkina Faso\"\n\"BFA\"\n161.3\n159.4\n157.5\n155.8\n154.3\n153.0\n151.8\n150.9\n150.2\n149.7\n149.3\n148.5\n147.1\n144.6\n141.0\n136.6\n131.9\n127.4\n123.4\n120.2\n117.6\n115.6\n113.9\n112.4\n110.8\n109.0\n107.1\n105.3\n103.8\n102.9\n102.5\n102.3\n102.4\n102.4\n102.1\n101.4\n100.5\n99.4\n98.3\n97.3\n96.2\n95.0\n93.4\n91.4\n88.9\n86.0\n82.7\n79.2\n75.8\n72.5\n69.7\n67.3\n65.4\n63.7\n62.2\n60.9\nnull\nnull\n\"Sub-Saharan Africa\"\n\"Low income\"\n30\n32\n\n\n\"Ghana\"\n\"GHA\"\n125.1\n123.8\n122.7\n121.8\n121.2\n120.8\n120.7\n120.6\n120.6\n120.5\n120.1\n119.5\n118.2\n116.5\n114.2\n111.5\n108.7\n106.0\n103.8\n102.1\n100.9\n100.1\n99.3\n98.4\n96.8\n94.7\n92.1\n89.0\n85.8\n82.7\n79.8\n77.5\n75.6\n74.1\n73.0\n72.0\n71.0\n69.8\n68.4\n66.7\n64.9\n63.0\n61.2\n59.6\n58.1\n56.8\n55.6\n54.4\n53.1\n51.7\n50.2\n48.6\n47.0\n45.5\n44.2\n42.8\nnull\nnull\n\"Sub-Saharan Africa\"\n\"Lower middle income\"\n25\n31\n\n\n\n\n\n\nFirst graph\n\n(\n    ggplot(sampled_data)\n    + geom_text(aes(1, \"y1960_rank\", label=\"country\"), ha=\"right\", size=9)\n    + geom_text(aes(2, \"y2015_rank\", label=\"country\"), ha=\"left\", size=9)\n    + geom_point(aes(1, \"y1960_rank\", color=\"income_group\"), size=2.5)\n    + geom_point(aes(2, \"y2015_rank\", color=\"income_group\"), size=2.5)\n    + geom_segment(\n        aes(x=1, y=\"y1960_rank\", xend=2, yend=\"y2015_rank\", color=\"income_group\")\n    )\n    + scale_y_reverse()\n)\n\n\n\n\n\n\n\n\nIt has the form we want, but we need to tweak it.\n\n# Text colors\nblack1 = \"#252525\"\nblack2 = \"#222222\"\n\n# Gallery, elaborate\n\n(\n    ggplot(sampled_data)\n    # Slight modifications for the original lines,\n    # 1. Nudge the text to either sides of the points\n    # 2. Alter the color and alpha values\n    + geom_text(\n        aes(1, \"y1960_rank\", label=\"country\"),\n        nudge_x=-0.05,\n        ha=\"right\",\n        size=9,\n        color=black1,\n    )\n    + geom_text(\n        aes(2, \"y2015_rank\", label=\"country\"),\n        nudge_x=0.05,\n        ha=\"left\",\n        size=9,\n        color=black1,\n    )\n    + geom_point(aes(1, \"y1960_rank\", color=\"income_group\"), size=2.5, alpha=0.7)\n    + geom_point(aes(2, \"y2015_rank\", color=\"income_group\"), size=2.5, alpha=0.7)\n    + geom_segment(\n        aes(x=1, y=\"y1960_rank\", xend=2, yend=\"y2015_rank\", color=\"income_group\"),\n        alpha=0.7,\n    )\n    # Text Annotations\n    + annotate(\n        \"text\",\n        x=1,\n        y=0,\n        label=\"Rank in 1960\",\n        fontweight=\"bold\",\n        ha=\"right\",\n        size=10,\n        color=black2,\n    )\n    + annotate(\n        \"text\",\n        x=2,\n        y=0,\n        label=\"Rank in 2015\",\n        fontweight=\"bold\",\n        ha=\"left\",\n        size=10,\n        color=black2,\n    )\n    + annotate(\n        \"text\", x=1.5, y=0, label=\"Lines show change in rank\", size=9, color=black1\n    )\n    + annotate(\n        \"label\",\n        x=1.5,\n        y=3,\n        label=\"Lower infant\\ndeath rates\",\n        size=9,\n        color=black1,\n        label_size=0,\n        fontstyle=\"italic\",\n    )\n    + annotate(\n        \"label\",\n        x=1.5,\n        y=33,\n        label=\"Higher infant\\ndeath rates\",\n        size=9,\n        color=black1,\n        label_size=0,\n        fontstyle=\"italic\",\n    )\n    # Prevent country names from being chopped off\n    + lims(x=(0.35, 2.65))\n    + labs(color=\"Income Group\")\n    # Countries with lower rates on top\n    + scale_y_reverse()\n    # Change colors\n    + scale_color_brewer(type=\"qual\", palette=2)\n    # Removes all decorations\n    + theme_void()\n    # Changing the figure size prevents the country names from squishing up\n    + theme(figure_size=(8, 11))\n)"
  },
  {
    "objectID": "reference/examples/geom_step.html",
    "href": "reference/examples/geom_step.html",
    "title": "Step plots",
    "section": "",
    "text": "from plotnine import ggplot, aes, geom_step, geom_line, labs, theme, element_text\nfrom plotnine.data import economics\n\ngeom_step() connects points using ‘steps’ instead of a line.\n\n# inspect the data\neconomics.head()\n\n\n\n\n\n\n\n\ndate\npce\npop\npsavert\nuempmed\nunemploy\n\n\n\n\n0\n1967-07-01\n507.4\n198712\n12.5\n4.5\n2944\n\n\n1\n1967-08-01\n510.5\n198911\n12.5\n4.7\n2945\n\n\n2\n1967-09-01\n516.3\n199113\n11.7\n4.6\n2958\n\n\n3\n1967-10-01\n512.9\n199311\n12.5\n4.9\n3143\n\n\n4\n1967-11-01\n518.1\n199498\n12.5\n4.7\n3066\n\n\n\n\n\n\n\nPlot a step plot using geom_plot(). Notice from the first point the line travels vertically then horizontally:\n\n(\n    ggplot(\n        economics.iloc[:20],  # filter for first twenty rows (dates) to make steps more visible\n        aes(\"date\", \"unemploy\"),\n    )\n    + geom_step()  # step plot\n    + labs(x=\"date\", y=\"unemployment (,000)\")  # label x & y-axis\n    + theme(axis_text_x=element_text(angle=45))  # rotate x-axis text for readability\n)\n\n\n\n\n\n\n\n\nYou can see how geom_path() (shown in pink) differs from geom_line() (black):\n\n(\n    ggplot(economics.iloc[:20], aes(\"date\", \"unemploy\"))\n    + geom_step(\n        colour=\"#ff69b4\",  # plot geom_step as the first layer - colour pink\n        alpha=0.5,  # line transparency\n        size=2.5,\n    )  # line thickness\n    + geom_line()  # plot geom_line as the second layer\n    + labs(x=\"date\", y=\"unemployment (,000)\")\n    + theme(axis_text_x=element_text(angle=45))\n)\n\n\n\n\n\n\n\n\nRather than a line that travels vertically then horizontally, this order can be switched by specifying direction='vh' within geom_step(). Below direction='vh' is shown in black with the default direction='hv' shown in pink:\n\n(\n    ggplot(economics.iloc[:20], aes(\"date\", \"unemploy\"))\n    + geom_step(\n        colour=\"#ff69b4\",  # plot geom_path with default direction as the first layer - colour pink\n        linetype=\"dashed\",  # line type\n        size=2,  # line thickness\n        alpha=0.5,\n    )  # line transparency\n    + geom_step(direction=\"vh\")  # plot geom_path with step order reversed\n    + labs(x=\"date\", y=\"unemployment (,000)\")\n    + theme(axis_text_x=element_text(angle=45))\n)"
  },
  {
    "objectID": "reference/examples/geom_violin.html",
    "href": "reference/examples/geom_violin.html",
    "title": "Violins, Boxes, Points & Lines",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nimport pandas.api.types as pdtypes\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    stage,\n    geom_violin,\n    geom_point,\n    geom_line,\n    geom_boxplot,\n    guides,\n    scale_fill_manual,\n    theme,\n    theme_classic,\n)\n\nComparing repeated measurements and their summaries\nSuppose you have two sets of related data and each point in the first set maps onto a point in the second set. e.g. they could represent a transition from one state to another for example two measurements of the height of pupils in different years.\nFor demonstration we shall generate data with a before measurement and an after measurement.\n\nnp.random.seed(123)\nn = 20\nmu = (1, 2.3)\nsigma = (1, 1.6)\n\nbefore = np.random.normal(loc=mu[0], scale=sigma[0], size=n)\nafter = np.random.normal(loc=mu[1], scale=sigma[1], size=n)\n\ndf = pd.DataFrame(\n    {\n        \"value\": np.hstack([before, after]),\n        \"when\": np.repeat([\"before\", \"after\"], n),\n        \"id\": np.hstack([range(n), range(n)]),\n    }\n)\n\ndf[\"when\"] = df[\"when\"].astype(pdtypes.CategoricalDtype(categories=[\"before\", \"after\"]))\ndf.head()\n\n\n\n\n\n\n\n\nvalue\nwhen\nid\n\n\n\n\n0\n-0.085631\nbefore\n0\n\n\n1\n1.997345\nbefore\n1\n\n\n2\n1.282978\nbefore\n2\n\n\n3\n-0.506295\nbefore\n3\n\n\n4\n0.421400\nbefore\n4\n\n\n\n\n\n\n\nA basic violin plot shows distributions of the two sets of data.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(df)\n)\n\n\n\n\n\n\n\n\nAdd the original data in form of points.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(df)\n    + geom_point()\n)\n\n\n\n\n\n\n\n\nThe violins are symmetrical about the vertical axis and half a violin has the same information as the full violin. We cut (style) the violins in half and choose to alternate with the left half for the first one and the right half for the second.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(df, style=\"left-right\")  # changed\n    + geom_point()\n)\n\n\n\n\n\n\n\n\nLink up the points to get a sense of how the data the moves.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(df, style=\"left-right\")  # changed\n    + geom_point()\n    + geom_line(aes(group=\"id\"))  # new\n)\n\n\n\n\n\n\n\n\nMake gap between the points and the violions. i.e. shift the violins outward and the points & lines inward. We used stage mapping to get it done. For example\nx=stage('when', after_scale='x+shift*alt_sign(x)')\nsays, map the xaesthetic to the ‘when’ column/variable and after the scale computed the x locations add a shift to them. The calculated x locations of a discrete scale are consecutive numbers 1, 2, 3, ..., so we use that move objects of adjacent groups in opposite directions i.e $(-1)^1, (-1)^2, (-1)^3 … = -1, 1, -1… $\n\n# How much to shift the violin, points and lines\n# 0.1 is 10% of the allocated space for the category\nshift = 0.1\n\n\ndef alt_sign(x):\n    \"Alternate +1/-1 if x is even/odd\"\n    return (-1) ** x\n\n\nm1 = aes(x=stage(\"when\", after_scale=\"x+shift*alt_sign(x)\"))  # shift outward\nm2 = aes(x=stage(\"when\", after_scale=\"x-shift*alt_sign(x)\"), group=\"id\")  # shift inward\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(m1, style=\"left-right\")  # changed\n    + geom_point(m2)  # changed\n    + geom_line(m2)  # changed\n)\n\n\n\n\n\n\n\n\nAdd a boxplot in the gap. The space between the flat edge of the violin and the center of the points is 2 * shift, so we can use the shift to control the width of the boxplot.\n\n(\n    ggplot(df, aes(\"when\", \"value\"))\n    + geom_violin(m1, style=\"left-right\")\n    + geom_point(m2)\n    + geom_line(m2)\n    + geom_boxplot(width=shift)\n)\n\n\n\n\n\n\n\n\nFinall, style it up.\n\n# Gallery, distributions\n\nlsize = 0.65\nfill_alpha = 0.7\n\n(\n    ggplot(df, aes(\"when\", \"value\", fill=\"when\"))\n    + geom_violin(m1, style=\"left-right\", alpha=fill_alpha, size=lsize)\n    + geom_point(m2, color=\"none\", alpha=fill_alpha, size=2)\n    + geom_line(m2, color=\"gray\", size=lsize, alpha=0.6)\n    + geom_boxplot(width=shift, alpha=fill_alpha, size=lsize)\n    + scale_fill_manual(values=[\"dodgerblue\", \"darkorange\"])\n    + guides(fill=False)  # Turn off the fill legend\n    + theme_classic()\n    + theme(figure_size=(8, 6))\n)\n\n\n\n\n\n\n\n\nCredit: This is example is motivated by the work of Jordy van Langen (@jorvlan) at https://github.com/jorvlan/open-visualizations."
  },
  {
    "objectID": "reference/examples/labs.html",
    "href": "reference/examples/labs.html",
    "title": "Text Outside the Panel(s)",
    "section": "",
    "text": "from plotnine import ggplot, aes, labs, geom_point, theme, theme_538, theme_set\nfrom plotnine.data import mtcars\n\ntheme_set(theme_538())\n\n\n# Gallery, labels\n\ncaption = \"\"\"\\\nThis graphic illustrates the inverse relationship between vehicle weight\nand fuel efficiency (MPG). It aims to highlight how heavier vehicles generally\nconsume more fuel, and how the complexity of an engine's cylinder count and\ntransmission system can affect its fuel economy.\n\"\"\"\n\nfrom plotnine import *\n(\n    ggplot(mtcars, aes(\"mpg\", \"wt\", colour=\"factor(cyl)\", size=\"gear\"))\n    + geom_point()\n    + labs(\n        x=\"Miles per Gallon\",\n        y=\"Weight\",\n        colour=\"Cylinders\",\n        size=\"Gears\",\n        title=\"Fuel Efficiency vs. Vehicle Weight\",\n        subtitle =\"Exploring Factors that Affect the Fuel Effeciency of a Car\",\n        caption=caption,\n    )\n\n    + theme(\n        # left justify the caption and have one line of space between it and\n        # the x-axis label\n        plot_caption=element_text(ha=\"left\", margin={\"t\": 1, \"units\": \"lines\"})\n    )\n    \n)"
  },
  {
    "objectID": "reference/examples/scale_color_discrete.html",
    "href": "reference/examples/scale_color_discrete.html",
    "title": "plotnine {{< var version >}}",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nfrom plotnine import (\n    ggplot,\n    aes,\n    geom_path,\n    geom_point,\n    geom_col,\n    labs,\n    scale_color_discrete,\n    scale_fill_discrete,\n    guides,\n    guide_legend,\n)\n\nMake some data\n\nn = 9\ndf = pd.DataFrame(\n    {\n        \"x\": np.arange(1, n+1),\n        \"y\": np.arange(1, n+1),\n        \"yfit\": np.arange(1, n+1) + np.tile([-0.2, 0, 0.2], n // 3),\n        \"cat\": [\"a\", \"b\", \"c\"] * (n // 3),\n    }\n)\n\nDraw an initial plot.\n\n(\n    ggplot(df)\n    + geom_col(aes(\"x\", \"y\"))\n)\n\n\n\n\n\n\n\n\nMapping the fill to a discrete variable uses the default color palette from the scale_fill_discrete\n\n(\n    ggplot(df)\n    + geom_col(aes(\"x\", \"y\", fill=\"cat\")) # changed\n)\n\n\n\n\n\n\n\n\nAssuming we want to visualise a “model” on top of the data. We could add this model data as points and a path through the points.\n\n(\n    ggplot(df)\n    + geom_col(aes(\"x\", \"y\", fill=\"cat\"))\n    + geom_point(aes(\"x\", y=\"yfit\", color=\"cat\"))  # new\n    + geom_path(aes(\"x\", y=\"yfit\", color=\"cat\"))   # new\n)\n\n\n\n\n\n\n\n\nThere is a clash of colors between the actual data (the bars) and the fitted model (the points and lines). A simple solution is to adjust the colors of the fitted model slightly. We do that by varying the lightness of the default color scale, make them a little darker.\n\n(\n    ggplot(df)\n    + geom_col(aes(\"x\", \"y\", fill=\"cat\"))\n    + geom_point(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + geom_path(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + scale_color_discrete(l=0.4)   # new\n)\n\n\n\n\n\n\n\n\nThere are two main pieces of information in the plot, but we a single combined legend. Since we use separate aesthetics for the actual data and fitted model, we can have distinct legends for both by giving a name to the scales associated with each.\n\n(\n    ggplot(df)\n    + geom_col(aes(\"x\", \"y\", fill=\"cat\"))\n    + geom_point(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + geom_path(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + scale_color_discrete(l=0.4, name=\"Model\") # modified\n    + scale_fill_discrete(name=\"Data\")          # new\n)\n\n\n\n\n\n\n\n\nAlternatively, we could use the labs class to set the names.\n\n(\n    ggplot(df)\n    + geom_col(aes(\"x\", \"y\", fill=\"cat\"))\n    + geom_point(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + geom_path(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + scale_color_discrete(l=0.4)\n    + labs(fill=\"Data\", color=\"Model\") # new\n)\n\n\n\n\n\n\n\n\nOr we could use guide_legend to rename the titles of the legends.\n\n(\n    ggplot(df)\n    + geom_col(aes(\"x\", \"y\", fill=\"cat\"))\n    + geom_point(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + geom_path(aes(\"x\", y=\"yfit\", color=\"cat\"))\n    + scale_color_discrete(l=0.4)\n    + guides( # new\n        fill=guide_legend(title=\"Data\"), color=guide_legend(title=\"Model\")\n    )\n)"
  },
  {
    "objectID": "reference/examples/scale_shape_identity.html",
    "href": "reference/examples/scale_shape_identity.html",
    "title": "Scatter Plot Shapes",
    "section": "",
    "text": "from plotnine import (\n    aes,\n    annotate,\n    coord_equal,\n    element_rect,\n    element_text,\n    facet_wrap,\n    geom_point,\n    geom_segment,\n    geom_text,\n    geom_tile,\n    ggplot,\n    lims,\n    scale_shape_identity,\n    theme,\n    theme_void,\n)\n\nimport polars as pl\nimport numpy as np\n\nList the shapes and prepare dataframe with what is required to display them.\n\nfilled_shapes = (\n    \"o\",  # circle\n    \"^\",  # triangle up\n    \"s\",  # square\n    \"D\",  # Diamond\n    \"v\",  # triangle down\n    \"*\",  # star\n    \"p\",  # pentagon\n    \"8\",  # octagon\n    \"&lt;\",  # triangle left\n    \"h\",  # hexagon1\n    \"&gt;\",  # triangle right\n    \"H\",  # hexagon1\n    \"d\",  # thin diamond\n)\n\nunfilled_shapes = (\n    \"+\",  # plus\n    \"x\",  # x\n    \".\",  # point\n    \"1\",  # tri_down\n    \"2\",  # tri_up\n    \"3\",  # tri_left\n    \"4\",  # tri_right\n    \",\",  # pixel\n    \"_\",  # hline\n    \"|\",  # vline\n    0,  # tickleft\n    1,  # tickright\n    2,  # tickup\n    3,  # tickdown\n    4,  # caretleft\n    5,  # caretright\n    6,  # caretup\n    7,  # caretdown\n)\n\nn1 = len(filled_shapes)\nn2 = len(unfilled_shapes)\nncols = 10\nshapes = filled_shapes + unfilled_shapes\n\ndf = pl.DataFrame({\n    \"x\": np.hstack([np.arange(n1) % ncols, np.arange(n2) % ncols]),\n    \"y\": 4 - 1.5 * np.hstack([np.arange(n1) // ncols, np.arange(n2) // ncols]),\n    \"shape\": pl.Series(shapes, dtype=object),\n    \"shape_kind\": np.repeat([\"Filled Shapes\", \"Unfilled Shapes\"], (n1, n2))\n})\n\ndf\n\n\nshape: (31, 4)\n\n\n\nx\ny\nshape\nshape_kind\n\n\ni64\nf64\nobject\nstr\n\n\n\n\n0\n4.0\no\n\"Filled Shapes\"\n\n\n1\n4.0\n^\n\"Filled Shapes\"\n\n\n2\n4.0\ns\n\"Filled Shapes\"\n\n\n3\n4.0\nD\n\"Filled Shapes\"\n\n\n4\n4.0\nv\n\"Filled Shapes\"\n\n\n…\n…\n…\n…\n\n\n3\n2.5\n3\n\"Unfilled Shapes\"\n\n\n4\n2.5\n4\n\"Unfilled Shapes\"\n\n\n5\n2.5\n5\n\"Unfilled Shapes\"\n\n\n6\n2.5\n6\n\"Unfilled Shapes\"\n\n\n7\n2.5\n7\n\"Unfilled Shapes\"\n\n\n\n\n\n\n\n# Gallery, points\n\ndef double_quote_strings(series):\n    return [\n        '\"{}\"'.format(s) if isinstance(s, str) else \"{}\".format(s)\n        for s in series\n    ]\n\n(\n    ggplot(df, aes(\"x\", \"y\"))\n    \n    # Background\n    + geom_tile(aes(width=0.9, height=0.9), fill=\"#F8F8F8\")\n    \n    # Cross-grid to help see the centering of the shapes\n    + geom_segment(aes(x=\"x-0.45\", xend=\"x+0.45\", yend=\"y\"), color=\"Crimson\", alpha=0.05)\n    + geom_segment(aes(xend=\"x\", y=\"y-0.45\", yend=\"y+0.45\"), color=\"Crimson\", alpha=0.05)\n    \n    # The shape\n    + geom_point(aes(shape=\"shape\"), fill=\"#E5C8D6\", size=8)\n\n    # Specification value for the shape\n    + geom_text(\n        aes(y=\"y+.5\", label=\"double_quote_strings(shape)\"),\n        color=\"darkblue\",\n        va=\"bottom\",\n    )\n\n    # Separate the shapes by their kind\n    + facet_wrap(\"shape_kind\", ncol=1)\n\n    # Make things pretty\n    + lims(y=(2, 5))\n    + scale_shape_identity()\n    + coord_equal()\n    + theme_void()\n    + theme(\n        plot_background=element_rect(fill=\"white\"),\n        strip_text=element_text(size=12)\n    )\n)\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nFile ~/.uvenv/plotnine/lib/python3.13/site-packages/IPython/core/formatters.py:984, in IPythonDisplayFormatter.__call__(self, obj)\n    982 method = get_real_method(obj, self.print_method)\n    983 if method is not None:\n--&gt; 984     method()\n    985     return True\n\nFile ~/scm/python/plotnine/plotnine/ggplot.py:149, in ggplot._ipython_display_(self)\n    142 def _ipython_display_(self):\n    143     \"\"\"\n    144     Display plot in the output of the cell\n    145 \n    146     This method will always be called when a ggplot object is the\n    147     last in the cell.\n    148     \"\"\"\n--&gt; 149     self._display()\n\nFile ~/scm/python/plotnine/plotnine/ggplot.py:190, in ggplot._display(self)\n    187     self.theme = self.theme.to_retina()\n    189 buf = BytesIO()\n--&gt; 190 self.save(buf, \"png\" if format == \"retina\" else format, verbose=False)\n    191 figure_size_px = self.theme._figure_size_px\n    192 display_func = get_display_function(format, figure_size_px)\n\nFile ~/scm/python/plotnine/plotnine/ggplot.py:702, in ggplot.save(self, filename, format, path, width, height, units, dpi, limitsize, verbose, **kwargs)\n    653 def save(\n    654     self,\n    655     filename: Optional[str | Path | BytesIO] = None,\n   (...)    664     **kwargs: Any,\n    665 ):\n    666     \"\"\"\n    667     Save a ggplot object as an image file\n    668 \n   (...)    700         Additional arguments to pass to matplotlib `savefig()`.\n    701     \"\"\"\n--&gt; 702     sv = self.save_helper(\n    703         filename=filename,\n    704         format=format,\n    705         path=path,\n    706         width=width,\n    707         height=height,\n    708         units=units,\n    709         dpi=dpi,\n    710         limitsize=limitsize,\n    711         verbose=verbose,\n    712         **kwargs,\n    713     )\n    715     with plot_context(self).rc_context:\n    716         sv.figure.savefig(**sv.kwargs)\n\nFile ~/scm/python/plotnine/plotnine/ggplot.py:650, in ggplot.save_helper(self, filename, format, path, width, height, units, dpi, limitsize, verbose, **kwargs)\n    647 if dpi is not None:\n    648     self.theme = self.theme + theme(dpi=dpi)\n--&gt; 650 figure = self.draw(show=False)\n    651 return mpl_save_view(figure, fig_kwargs)\n\nFile ~/scm/python/plotnine/plotnine/ggplot.py:322, in ggplot.draw(self, show)\n    319     self._create_figure()\n    320 figure = self.figure\n--&gt; 322 self._build()\n    324 # setup\n    325 self.axs = self.facet.setup(self)\n\nFile ~/scm/python/plotnine/plotnine/ggplot.py:419, in ggplot._build(self)\n    417 npscales = scales.non_position_scales()\n    418 if len(npscales):\n--&gt; 419     layers.train(npscales)\n    420     layers.map(npscales)\n    422 # Train coordinate system\n\nFile ~/scm/python/plotnine/plotnine/layer.py:492, in Layers.train(self, scales)\n    490 def train(self, scales: Scales):\n    491     for l in self:\n--&gt; 492         scales.train_df(l.data)\n\nFile ~/scm/python/plotnine/plotnine/scales/scales.py:203, in Scales.train_df(self, data, drop)\n    201 # Each scale trains the columns it understands\n    202 for sc in self:\n--&gt; 203     sc.train_df(data)\n\nFile ~/scm/python/plotnine/plotnine/scales/scale.py:284, in scale.train_df(self, df)\n    282 aesthetics = sorted(set(self.aesthetics) & set(df.columns))\n    283 for ae in aesthetics:\n--&gt; 284     self.train(df[ae])\n\nFile ~/scm/python/plotnine/plotnine/scales/scale_identity.py:36, in MapTrainMixin.train(self, x, drop)\n     33 if self.guide is None:  # pyright: ignore\n     34     return\n---&gt; 36 return super().train(x)\n\nFile ~/scm/python/plotnine/plotnine/scales/scale_discrete.py:107, in scale_discrete.train(self, x, drop)\n    104     return\n    106 na_rm = not self.na_translate\n--&gt; 107 self._range.train(x, drop, na_rm=na_rm)\n\nFile ~/scm/python/plotnine/plotnine/scales/range.py:67, in RangeDiscrete.train(self, x, drop, na_rm)\n     63 \"\"\"\n     64 Train discrete range\n     65 \"\"\"\n     66 rng = None if self.is_empty() else self.range\n---&gt; 67 self.range = scale_discrete.train(x, rng, drop, na_rm=na_rm)\n\nFile ~/.uvenv/plotnine/lib/python3.13/site-packages/mizani/scale.py:269, in scale_discrete.train(cls, new_data, old, drop, na_rm)\n    267     limits = [c for c in ordered_cats if c in all_set]\n    268 else:\n--&gt; 269     new = np.unique(new_data)\n    270     new.sort()\n    272     limits = old + [i for i in new if (i not in old_set)]\n\nFile ~/.uvenv/plotnine/lib/python3.13/site-packages/numpy/lib/_arraysetops_impl.py:286, in unique(ar, return_index, return_inverse, return_counts, axis, equal_nan)\n    284 ar = np.asanyarray(ar)\n    285 if axis is None:\n--&gt; 286     ret = _unique1d(ar, return_index, return_inverse, return_counts,\n    287                     equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)\n    288     return _unpack_tuple(ret)\n    290 # axis was specified and not None\n\nFile ~/.uvenv/plotnine/lib/python3.13/site-packages/numpy/lib/_arraysetops_impl.py:353, in _unique1d(ar, return_index, return_inverse, return_counts, equal_nan, inverse_shape, axis)\n    351     aux = ar[perm]\n    352 else:\n--&gt; 353     ar.sort()\n    354     aux = ar\n    355 mask = np.empty(aux.shape, dtype=np.bool)\n\nTypeError: '&lt;' not supported between instances of 'int' and 'str'\n\n\n\n&lt;plotnine.ggplot.ggplot at 0x10acd1220&gt;"
  },
  {
    "objectID": "reference/examples/stage.html",
    "href": "reference/examples/stage.html",
    "title": "stage",
    "section": "",
    "text": "%load_ext autoreload\n%autoreload 2\n%aimport plotnine\n\nimport pandas as pd\nimport numpy as np\n\nfrom plotnine import (\n    ggplot,\n    aes,\n    after_stat,\n    stage,\n    geom_bar,\n    geom_text,\n    geom_bin_2d,\n    stat_bin_2d,\n)\ndf = pd.DataFrame({\n    \"var1\": list(\"abbcccddddeeeee\"),\n    \"cat\": list(\"RSRSRSRRRSRSSRS\")\n})\n\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar()\n)\nAdd the corresponding count on top of each bar.\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar()\n    + geom_text(aes(label=after_stat(\"count\")), stat=\"count\")\n)\nAdjust the y position so that the counts do not overlap the bars.\n(\n    ggplot(df, aes(\"var1\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"count\"), y=stage(after_stat=\"count\", after_scale=\"y+.1\")),\n        stat=\"count\",\n    )\n)\nNote that this will work even nicely for stacked bars where adjustig the position with nudge_y=0.1 would not.\n(\n    ggplot(df, aes(\"var1\", fill=\"cat\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"count\"), y=stage(after_stat=\"count\", after_scale=\"y+.1\")),\n        stat=\"count\",\n        position=\"stack\",\n    )\n)"
  },
  {
    "objectID": "reference/examples/stage.html#create-a-binned-2d-plot-with-counts",
    "href": "reference/examples/stage.html#create-a-binned-2d-plot-with-counts",
    "title": "stage",
    "section": "Create a binned 2d plot with counts",
    "text": "Create a binned 2d plot with counts\n\nnp.random.seed(123)\ndf = pd.DataFrame({\n    \"col_1\": np.random.rand(1000),\n    \"col_2\": np.random.rand(1000)\n})\n\n\n(\n    ggplot(df, aes(x=\"col_1\", y=\"col_2\"))\n    + geom_bin_2d(position=\"identity\", binwidth=0.1)\n)\n\n\n\n\n\n\n\n\nAdd counts to the bins. stat_bin_2d bins are specified using retangular minimum and maximum end-points for dimension; we use these values to compute the mid-points at which to place the counts.\nFirst x and y aesthetics are mapped to col_1 and col_2 variables, then after the statistic consumes them and creates xmin, xmax, ymin & ymax values for each bin along with associated count. After the statistic computation the x and y aesthetics do not exist, but we create meaningful values using the minimum and maximum end-points.\nNote that the binning parameters for the geom and stat combination must be the same. In this case it is the binwidth.\n\n(\n    ggplot(df, aes(x=\"col_1\", y=\"col_2\"))\n    + geom_bin_2d(position=\"identity\", binwidth=0.1)\n    + stat_bin_2d(\n        aes(\n            x=stage(start=\"col_1\", after_stat=\"(xmin+xmax)/2\"),\n            y=stage(start=\"col_2\", after_stat=\"(ymin+ymax)/2\"),\n            label=after_stat(\"count\"),\n        ),\n        binwidth=0.1,\n        geom=\"text\",\n        format_string=\"{:.0f}\",\n        size=10,\n    )\n)"
  },
  {
    "objectID": "reference/examples/theme_bw.html",
    "href": "reference/examples/theme_bw.html",
    "title": "Black & White",
    "section": "",
    "text": "from plotnine import ggplot, geom_point, aes, labs, theme_bw\nfrom plotnine.data import mtcars\n\n\n# Gallery, themes\n(\n    ggplot(mtcars, aes(x=\"wt\", y=\"mpg\", colour=\"factor(gear)\"))\n    + geom_point()\n    + labs(\n        title= \"Fuel economy declines as weight increases\",\n        subtitle=\"(1973-74)\",\n        caption=\"Data from the 1974 Motor Trend US magazine.\",\n        x=\"Weight (1000 lbs)\",\n        y=\"Fuel economy (mpg)\",\n        colour=\"Gears\"\n    )\n    + theme_bw()\n)"
  },
  {
    "objectID": "tutorials/miscellaneous-a-pyqt5-application.html",
    "href": "tutorials/miscellaneous-a-pyqt5-application.html",
    "title": "A PyQt5 Application",
    "section": "",
    "text": "import sys\nimport random\n\nfrom plotnine import ggplot, geom_point, aes, geom_line, theme\nimport pandas as pd\nimport numpy as np\n\nfrom PyQt5.QtWidgets import QApplication, QPushButton, QDialog, QVBoxLayout\n\nimport matplotlib.pyplot as plt\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\nfrom matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar\nfrom matplotlib.figure import Figure\nThis example applicate creates a gui windows with a canvas and a plot button which when pressed draws out a plot from random data.\ndpi = 72\nsize_inches = (11, 8)  # size in inches (for the plot)\nsize_px = int(size_inches[0] * dpi), int(size_inches[1] * dpi)  # For the canvas\n\n\nclass Window(QDialog):\n    def __init__(self, parent=None):\n        super(Window, self).__init__(parent)\n\n        self.figure = Figure()\n        self.canvas = FigureCanvas(self.figure)\n        self.toolbar = NavigationToolbar(self.canvas, self)\n\n        self.button = QPushButton(\"Plot\")\n        self.button.clicked.connect(self.plot)\n\n        self.canvas.setMinimumSize(*size_px)\n\n        layout = QVBoxLayout()\n        layout.addWidget(self.toolbar)\n        layout.addWidget(self.canvas)\n        layout.addWidget(self.button)\n        self.setLayout(layout)\n\n    def plot(self):\n        # generate some 'data' to plot\n        n = 100\n        x = np.linspace(0, 2 * np.pi, n)\n        df = pd.DataFrame(\n            {\n                \"x\": x,\n                \"y1\": np.random.rand(n),\n                \"y2\": np.sin(x),\n                \"y3\": np.cos(x) * np.sin(x),\n            }\n        )\n\n        # change the dependent variable and color each time this method is called\n        y = random.choice([\"y1\", \"y2\", \"y3\"])\n        color = random.choice([\"blue\", \"red\", \"green\"])\n\n        # specify the plot and get the figure object\n        ff = (\n            ggplot(df, aes(\"x\", y))\n            + geom_point(color=color)\n            + geom_line()\n            + theme(figure_size=size_inches, dpi=dpi)\n        )\n        fig = ff.draw()\n\n        # update to the new figure\n        self.canvas.figure = fig\n\n        # refresh canvas\n        self.canvas.draw()\n\n        # close the figure so that we don't create too many figure instances\n        plt.close(fig)\n\n\n# To prevent random crashes when rerunning the code,\n# first check if there is instance of the app before creating another.\napp = QApplication.instance()\nif app is None:\n    app = QApplication(sys.argv)\n\nmain = Window()\nmain.show()\napp.exec_()\n\n0"
  },
  {
    "objectID": "tutorials/miscellaneous-a-pyqt5-application.html#the-application",
    "href": "tutorials/miscellaneous-a-pyqt5-application.html#the-application",
    "title": "A PyQt5 Application",
    "section": "The Application",
    "text": "The Application\n\n\n\nPyQT5 Application\n\n\nCredit: Brad Reisfeld (@breisfeld) for putting this workflow together."
  },
  {
    "objectID": "tutorials/miscellaneous-automatic-grouping-insufficient.html",
    "href": "tutorials/miscellaneous-automatic-grouping-insufficient.html",
    "title": "When the automatic groups are not sufficient",
    "section": "",
    "text": "import pandas as pd\nfrom plotnine import ggplot, aes, geom_col, geom_line, labs, scale_color_hue\n\nSome data to plot\n\ndf = pd.DataFrame(\n    {\n        \"letter\": [\"Alpha\", \"Beta\", \"Delta\", \"Gamma\"],\n        \"pos\": [1, 2, 3, 4],\n        \"num_of_letters\": [5, 4, 5, 5],\n    }\n)\n\ndf\n\n\n\n\n\n\n\n\nletter\npos\nnum_of_letters\n\n\n\n\n0\nAlpha\n1\n5\n\n\n1\nBeta\n2\n4\n\n\n2\nDelta\n3\n5\n\n\n3\nGamma\n4\n5\n\n\n\n\n\n\n\n\n(\n    ggplot(df)\n    + geom_col(aes(x=\"letter\", y=\"pos\"))\n    + geom_line(aes(x=\"letter\", y=\"num_of_letters\"))\n    + labs(title=\"Greek Letter Analysis\")\n)\n\n\n\n\n\n\n\n\nWe get a plot with a warning and no line(s). This is not what we expected.\nThe issue is we have 4 groups (Alpha, Beta, …) and each of those groups has a single point. This is a case where the automatic grouping is not sufficient (or just not what you expect). The solution is to manually set the group for geom_line so that all points belong to one group.\n\n(\n    ggplot(df)\n    + geom_col(aes(x=\"letter\", y=\"pos\"))\n    + geom_line(aes(x=\"letter\", y=\"num_of_letters\"), group=1)\n    + labs(title=\"Greek Letter Analysis\")\n)\n\n\n\n\n\n\n\n\nThat looks like it.\nTo understand why the behaviour behind the warning is not wrong, let us try a dataframe with 2 points per group.\n\ndf2 = pd.DataFrame(\n    {\n        \"letter\": [\"Alpha\", \"Beta\", \"Delta\", \"Gamma\"] * 2,\n        \"pos\": [1, 2, 3, 4] * 2,\n        \"num_of_letters\": [5, 4, 5, 5] * 2,\n    }\n)\n\ndf2.loc[4:, \"num_of_letters\"] += 0.8\n\n(\n    ggplot(df2)\n    + geom_col(aes(x=\"letter\", y=\"pos\"))\n    + geom_line(aes(x=\"letter\", y=\"num_of_letters\"))\n    + labs(title=\"Greek Letter Analysis\")\n)\n\n\n\n\n\n\n\n\nWe get no warning and we get lines.\nWe can add some color to such a plot.\n\n(\n    ggplot(df2)\n    + geom_col(aes(x=\"letter\", y=\"pos\", fill=\"letter\"))\n    + geom_line(aes(x=\"letter\", y=\"num_of_letters\", color=\"letter\"), size=1)\n    + scale_color_hue(l=0.45)  # some contrast to make the lines stick out\n    + labs(title=\"Greek Letter Analysis\")\n)\n\n\n\n\n\n\n\n\nCredit: github user @datavistics (derek) whose encounter with this issue motivated this example."
  },
  {
    "objectID": "tutorials/miscellaneous-order-plot-series.html",
    "href": "tutorials/miscellaneous-order-plot-series.html",
    "title": "Custom sorting of plot series",
    "section": "",
    "text": "import pandas as pd\nfrom plotnine import ggplot, aes, geom_bar, coord_flip, labs, scale_x_discrete\nfrom plotnine.data import mpg"
  },
  {
    "objectID": "tutorials/miscellaneous-order-plot-series.html#bar-plot-of-manufacturer---default-output",
    "href": "tutorials/miscellaneous-order-plot-series.html#bar-plot-of-manufacturer---default-output",
    "title": "Custom sorting of plot series",
    "section": "Bar plot of manufacturer - Default Output",
    "text": "Bar plot of manufacturer - Default Output\n\n(\n    ggplot(mpg)\n    + aes(x=\"manufacturer\")\n    + geom_bar(size=20)\n    + coord_flip()\n    + labs(y=\"Count\", x=\"Manufacturer\", title=\"Number of Cars by Make\")\n)\n\n\n\n\n\n\n\n\n\nOrdered Horizontal Bars\nBy default the discrete values along axis are ordered alphabetically. If we want a specific ordering we use a pandas.Categorical variable with categories ordered to our preference.\n\n# Determine order and create a categorical type\n# Note that value_counts() is already sorted\nmanufacturer_list = mpg[\"manufacturer\"].value_counts().index.tolist()\nmanufacturer_cat = pd.Categorical(mpg[\"manufacturer\"], categories=manufacturer_list)\n\n# assign to a new column in the DataFrame\nmpg = mpg.assign(manufacturer_cat=manufacturer_cat)\n\n(\n    ggplot(mpg)\n    + aes(x=\"manufacturer_cat\")\n    + geom_bar(size=20)\n    + coord_flip()\n    + labs(y=\"Count\", x=\"Manufacturer\", title=\"Number of Cars by Make\")\n)\n\n\n\n\n\n\n\n\nWe could also modify the existing manufacturer category to set it as ordered instead of having to create a new CategoricalDtype and apply that to the data.\n\nmpg = mpg.assign(\n    manufacturer_cat=mpg[\"manufacturer\"].cat.reorder_categories(manufacturer_list)\n)\n\nAlternatively\nAnother method to quickly reorder a discrete axis without changing the data is to change it’s limits\n\n# Determine order and create a categorical type\n# Note that value_counts() is already sorted\nmanufacturer_list = mpg[\"manufacturer\"].value_counts().index.tolist()\n\n(\n    ggplot(mpg)\n    + aes(x=\"manufacturer_cat\")\n    + geom_bar(size=20)\n    + scale_x_discrete(limits=manufacturer_list)\n    + coord_flip()\n    + labs(y=\"Count\", x=\"Manufacturer\", title=\"Number of Cars by Make\")\n)\n\n\n\n\n\n\n\n\nYou can ‘flip’ an axis (independent of limits) by reversing the order of the limits.\n\n# Gallery, bars\n# Determine order and create a categorical type\n# Note that value_counts() is already sorted\nmanufacturer_list = mpg[\"manufacturer\"].value_counts().index.tolist()[::-1]\n\n(\n    ggplot(mpg)\n    + aes(x=\"manufacturer_cat\")\n    + geom_bar(size=20)\n    + scale_x_discrete(limits=manufacturer_list)\n    + coord_flip()\n    + labs(y=\"Count\", x=\"Manufacturer\", title=\"Number of Cars by Make\")\n)\n\n\n\n\n\n\n\n\n\n\nFurther Reading\n\nPandas documentation of how to use categorical data in practice\nPandas API Reference for categorical\nPandas documentation of pd.Categorical"
  },
  {
    "objectID": "tutorials/miscellaneous-show-counts-and-percentages-for-bar-plots.html",
    "href": "tutorials/miscellaneous-show-counts-and-percentages-for-bar-plots.html",
    "title": "Show counts and percentages for bar plots",
    "section": "",
    "text": "import pandas as pd\nfrom plotnine import (\n    ggplot,\n    aes,\n    after_stat,\n    stage,\n    geom_bar,\n    geom_text,\n    geom_label,\n    position_dodge2,\n    facet_wrap,\n)\nfrom plotnine.data import mtcars\n\nWe can plot a bar graph and easily show the counts for each bar\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(cyl)\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"count\")), stat=\"count\", nudge_y=0.125, va=\"bottom\"\n    )\n)\n\n\n\n\n\n\n\n\nstat_count also calculates proportions (as prop) and a proportion can be converted to a percentage.\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(cyl)\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"prop*100\")),\n        stat=\"count\",\n        nudge_y=0.125,\n        va=\"bottom\",\n        format_string=\"{:.1f}% \",\n    )\n)\n\n\n\n\n\n\n\n\nThese are clearly wrong percentages. The system puts each bar in a separate group. We need to tell it to put all bars in the panel in single group, so that the percentage are what we expect.\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(cyl)\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"prop*100\"), group=1),\n        stat=\"count\",\n        nudge_y=0.125,\n        va=\"bottom\",\n        format_string=\"{:.1f}%\",\n    )\n)\n\n\n\n\n\n\n\n\nWithout group=1, you can calculate the proportion / percentage after statistics have been calculated. This works because mapping expressions are evaluated across the whole panel. It can work when you have more than 1 categorical.\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(cyl)\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"count / sum(count) * 100\")),\n        stat=\"count\",\n        nudge_y=0.125,\n        va=\"bottom\",\n        format_string=\"{:.1f}%\",\n    )\n)\n\n\n\n\n\n\n\n\nFor more on why automatic grouping may work the way you want, see this tutorial.\nWe can get the counts and we can get the percentages we need to print both. We can do that in two ways,\n\nUsing two geom_text layers.\n\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(cyl)\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"count\")),\n        stat=\"count\",\n        nudge_x=-0.14,\n        nudge_y=0.125,\n        va=\"bottom\",\n    )\n    + geom_text(\n        aes(label=after_stat(\"prop*100\"), group=1),\n        stat=\"count\",\n        nudge_x=0.14,\n        nudge_y=0.125,\n        va=\"bottom\",\n        format_string=\"({:.1f}%)\",\n    )\n)\n\n\n\n\n\n\n\n\n\nUsing a function to combine the counts and percentages\n\n\ndef combine(counts, percentages):\n    fmt = \"{} ({:.1f}%)\".format\n    return [fmt(c, p) for c, p in zip(counts, percentages)]\n\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(cyl)\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"combine(count, prop*100)\"), group=1),\n        stat=\"count\",\n        nudge_y=0.125,\n        va=\"bottom\",\n    )\n)\n\n\n\n\n\n\n\n\nIt works with facetting.\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(cyl)\"))\n    + geom_bar()\n    + geom_text(\n        aes(label=after_stat(\"combine(count, prop*100)\"), group=1),\n        stat=\"count\",\n        nudge_y=0.125,\n        va=\"bottom\",\n        size=9,\n    )\n    + facet_wrap(\"am\")\n)\n\n\n\n\n\n\n\n\nCredit: This example was motivated by the github user Fandekasp (Adrien Lemaire) and difficulty he faced in displaying percentages of bar plots.\n\nPercentages when you have more than one categorical.\ngroup = 1 does not work when you have more than one categories per x location.\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(am)\"))\n    + geom_bar(position=\"dodge2\")\n    + geom_text(\n        aes(label=after_stat(\"prop * 100\"), group=1),\n        stat=\"count\",\n        position=position_dodge2(width=0.9),\n        format_string=\"{:.1f}%\",\n        size=9,\n    )\n)\n\n\n\n\n\n\n\n\nYou have to calculate the percentages after statistics for the panel have been calculated.\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(am)\"))\n    + geom_bar(position=\"dodge2\")\n    + geom_text(\n        aes(\n            label=after_stat(\"count / sum(count) * 100\"),\n            y=stage(after_stat=\"count\", after_scale=\"y + 0.25\"),\n        ),\n        stat=\"count\",\n        position=position_dodge2(width=0.9),\n        format_string=\"{:.1f}%\",\n        size=9,\n    )\n)\n\n\n\n\n\n\n\n\nFor percentages per bar at each x location, you have to group the counts per location can compute the proportions.\n\n\nBars with Group Percentages\n\n# Gallery, bars\n\ndef prop_per_x(x, count):\n    \"\"\"\n    Compute the proportion of the counts for each value of x\n    \"\"\"\n    df = pd.DataFrame({\"x\": x, \"count\": count})\n    prop = df[\"count\"] / df.groupby(\"x\")[\"count\"].transform(\"sum\")\n    return prop\n\n\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(am)\"))\n    + geom_bar(position=\"dodge2\")\n    + geom_text(\n        aes(\n            label=after_stat(\"prop_per_x(x, count) * 100\"),\n            y=stage(after_stat=\"count\", after_scale=\"y+.25\"),\n        ),\n        stat=\"count\",\n        position=position_dodge2(width=0.9),\n        format_string=\"{:.1f}%\",\n        size=9,\n    )\n)\n\n\n\n\n\n\n\n\n\n\nStacked Bars with Group Percentages\n\n# Gallery, bars\n(\n    ggplot(mtcars, aes(\"factor(cyl)\", fill=\"factor(am)\"))\n    + geom_bar(position=\"fill\")\n    + geom_label(\n        aes(label=after_stat(\"prop_per_x(x, count) * 100\")),\n        stat=\"count\",\n        position=\"fill\",\n        format_string=\"{:.1f}%\",\n        size=9,\n    )\n)\n\n\n\n\n\n\n\n\nNOTE\nWith more categories, if it becomes harder get the right groupings withing plotnine, the solution is to do all (or most) the data manipulation in pandas then plot using geom_col + geom_text."
  },
  {
    "objectID": "tutorials/miscellaneous-using-letter-as-shapes.html",
    "href": "tutorials/miscellaneous-using-letter-as-shapes.html",
    "title": "Using letters as shapes",
    "section": "",
    "text": "from plotnine import (\n    ggplot,\n    aes,\n    geom_point,\n    scale_shape_manual,\n)\nfrom plotnine.data import mtcars\n\nYou can create shape symbols using \\(\\TeX\\). For example\n\nmixed_shapes = (\n    r\"$\\mathrm{A}$\",\n    r\"$\\mathrm{B}$\",\n    r\"$\\mathrm{C}$\",\n    r\"$\\mathrm{D}$\",\n)\n\n\n(\n    ggplot(mtcars, aes(\"wt\", \"mpg\", shape=\"factor(gear)\", colour=\"factor(gear)\"))\n    + geom_point(size=6)\n    + scale_shape_manual(values=mixed_shapes)\n)\n\n\n\n\n\n\n\n\nSee matplotlib documentation for more."
  }
]