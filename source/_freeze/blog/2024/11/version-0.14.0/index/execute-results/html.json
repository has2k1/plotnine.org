{
  "hash": "1daf461a7b7ca3229e1226d5b697ea11",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Version 0.14.0\"\ndate: \"2024-11-07\"\ncategories: [releases]\nformat:\n   html:\n      fig-width: 6\n      fig-height: 4\n      fig-format: retina\njupyter: python3\n---\n\n::: {#imports .cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Code - Imports\"}\nimport pandas as pd\nfrom plotnine import (\n   aes,\n   ggplot,\n   geom_point,\n   geom_text,\n   scale_x_datetime,\n   theme,\n   theme_set,\n   theme_matplotlib,\n)\ntheme_set(theme_matplotlib());\n```\n:::\n\n\n![](images/logo-512.png){.float-end width=20% fig-alt=\"plotnine logo\"}\n\nWe are happy to announce the release of plotnine v0.14! This version requires _python 3.10 or later_, a change aligned with [NumPy's deprecation policy](https://numpy.org/neps/nep-0029-deprecation_policy.html#support-table).\n\nThis release also introduces our new hex logo!\n\n## No More `print` for Plots\n\nOne of the most significant updates in v0.14 is the removal of `print` as a way to render plot objects. Starting with v0.13, we began deprecating this approach, encouraging users to transition to `ggplot.show()` for displaying plots.\n\nNow, `print` on a plot object will simply return the display size (in pixels) rather than rendering the plot.\n\n::: {#no-print .cell execution_count=2}\n``` {.python .cell-code}\ndata = pd.DataFrame({\"x\": [1, 2, 3], \"y\": [1, 2, 3 ]})\np = (\n   ggplot(data, aes(\"x\", \"y\"))\n   + geom_point()\n   + theme(figure_size=(4, 2))\n)\n\nprint(p)\nprint(\"There is no figure above this output sentence.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<ggplot: (768 x 384)>\nThere is no figure above this output sentence.\n```\n:::\n:::\n\n\nIn environments with `retina` output, the exact pixel-size dimensions of the image will be double the display size.\n\n::: {#cell-use-show .cell execution_count=3}\n``` {.python .cell-code}\np.show()\nprint(\"There is a figure above this output sentence.\")\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/use-show-output-1.png){#use-show width=384 height=192}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nThere is a figure above this output sentence.\n```\n:::\n:::\n\n\n## Enhancements\n\nIf you have worked with scales and passed in parameters, you might have encountered an inconvenience: your IDE could not provide meaningful suggestions. Previously, scales used `**kwargs` to capture common parameters, making it challenging for IDEs to offer specific guidance. With around [100 scales](https://plotnine.org/reference/#scales), each with subtle differences, we handled these parameters dynamically to avoid extensive duplication while also generating docstrings automatically.\n\nWith Python >= 3.10, we have converted scales to `dataclasses` and leveraged finer controls over [keyword-only parameters](https://docs.python.org/3.10/library/dataclasses.html#dataclasses.KW_ONLY). This allows us to provide explicit signatures and enables the documentation system to automatically include inherited docstrings for parameters. For example, where an IDE previously displayed something like this:\n\n![](images/scale-signature-old.png){width=75% fig-align=\"center\" fig-alt=\"Old Scale Signature IDE Hint\"}\n\nit will now display:\n\n![](images/scale-signature-new.png){width=75% fig-align=\"center\" fig-alt=\"New Scale Signature IDE Hint\"}\n\n\n## Datetimes and Timedeltas\n\nWorking with datetimes can be challenging (sometimes even [hellish](https://ondata.blog/articles/nine-circles-of-hell-time-in-python/)), but we aim to simplify this experience for you. In Python, there are three main types of datetime objects you are likely to encounter:\n\n1. [`datetime.datetime`](https://docs.python.org/3/library/datetime.html#datetime-objects) from the standard library\n2. [`pandas.Timestamp`](https://pandas.pydata.org/docs/reference/api/pandas.Timestamp.html) from pandas\n3. [`numpy.datetime64`](https://numpy.org/devdocs/reference/arrays.datetime.html#basic-datetimes) from numpy\n\nEach of these types covers different ranges and resolutions. The standard library’s `datetime` has the smallest range, with a constant millisecond (ms) resolution; pandas offers a middle ground with a larger range and nanosecond (ns) resolution; and numpy provides varying resolutions (from years to attoseconds) with different ranges for each resolution. These differences mean that these types are not always directly interchangeable, though we work to make them feel that way. Since our data is stored in a dataframe, any datetime values are converted to the pandas type, which then stores values as numpy types!\n\nArithmetic operations on each datetime type yield corresponding timedelta types also with their unique resolutions. Certain ranges can exceed valid limits—for example, the range of `pandas.Timestamp` cannot be represented as a timedelta. This means there are edge cases. But you should not be too worried unless your desired time resolution is dictacted by the [vagaries](https://en.wikipedia.org/wiki/2011_OPERA_faster-than-light_neutrino_anomaly) of sub-atomic particles.\n\nIn this release, you can now expand the limits of datetime and timedelta scales with additional constants.\n\n::: {#cell-expanding-with-a-timedelta .cell execution_count=4}\n``` {.python .cell-code}\nimport datetime\n\ndata = pd.DataFrame({\n    \"x\": [datetime.datetime(2024, 8, i) for i in range(1, 6)],\n    \"y\": range(5)\n})\n\n(\n    ggplot(data, aes(\"x\", \"y\"))\n    + geom_point()\n    + scale_x_datetime(\n        expand=(0, datetime.timedelta(days=1))\n    )\n    + theme(figure_size=(6, 4))\n)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/expanding-with-a-timedelta-output-1.png){#expanding-with-a-timedelta width=576 height=384}\n:::\n:::\n\n\nYou can also set the limits through the coordinate system.\n\n```python\ncoord_cartesian(xlim=(datetime(1999, 1, 1), datetime(2006, 1, 1)))\n```\n\nBeyond datetime and timezone scales, this robustness now applies to any scale created for data types that are not strictly numeric.\n\n## Integration with Quarto\n\nplotnine now recognizes [figure options](https://quarto.org/docs/computations/execution-options.html#figure-options) specified in the meta section of a Quarto document. These options control the size and format of output images, including `fig-dpi`, `fig-width`, `fig-height`, and `fig-format`.\n\nWhile these Quarto options are set as defaults, you can still override them for any specific plot. For example:\n\n```` quarto\n---\ntitle: \"Plotnine Playing well with Quarto\"\nformat: html\njupyter: python3\nfig-dpi: 100\nfig-width: 6\nfig-height: 4\nfig-format: retina\n---\n\n```{{python}}\n#| label: using-quarto-figure-options\nfrom pandas import pd\nfrom plotnine import aes, geom_point, ggplot, theme\n\ndata = pd.DataFrame({\"x\": range(5), \"y\": range(5)})\n\n(\n  ggplot(data, aes(\"x\", \"y\"))\n  + geom_point()\n)\n```\n\n```{{python}}\n#| label: overriding-quarto-figure-options\n(\n  ggplot(data, aes(\"x\", \"y\"))\n  + geom_point()\n  + theme(figure_size=(4, 3))\n)\n```\n\n````\n\nNote that, at the moment using these options at the chunk level has no effect.\n\n## Font Aesthetics\n\nIn theory, aesthetics represent any properties we can perceive; in practice, only those we can see and vary predictably can be useful aesthetics. Previously, text attributes like `family`, `fontweight`, `fontstyle`, and `fontvariant` were parameters but not aesthetics, meaning you could not map variables to them. Not anymore, these attributes of a text are now aesthetics!\n\n`fontweight` controls the boldness of text. It accepts any number in the range `[0, 1000]`, with common levels being _normal_ (400) and _bold_ (700). Some fonts provide multiple levels of boldness, with up to nine variations, typically at intervals like `[100, 200, 300, 400, 500, 600, 700, 800, 900]`. A given numeric weight will be mapped to the nearest available level.\n\nFor instance, here is an example comparing two fonts: `Helvetica`, which doesn’t have multiple weight levels (the one on your system may differ), and `Open Sans` (again, the one on your system may differ), which does.\n\n\n\n::: {#cell-variable-font-weight .cell execution_count=6}\n``` {.python .cell-code}\nfrom mizani.bounds import rescale\n\ndata = pd.DataFrame({\n    \"x\": range(5),\n    \"y\": range(5),\n    \"w\": rescale(range(5), to=(0, 1000)),\n    \"label\": \"Zero One Two Three Four\".split()\n})\n\n(\n    ggplot(data, aes(\"x\", label=\"label\", fontweight=\"w\"))\n    + geom_text(aes(y=\"y\"), family=\"Helvetica\", colour=\"red\", size=16)\n    + geom_text(aes(y=\"y-.25\"), family=\"Open Sans\", colour=\"green\", size=16)\n)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/variable-font-weight-output-1.png){#variable-font-weight width=576 height=384}\n:::\n:::\n\n\nNote that, there is no scale for `fontweight` so we had to explicitly scale the value to the expected range. Currently you should expect at most 9 levels of bold variations, but pending better support, completely [variable fonts](https://fonts.google.com/knowledge/introducing_type/introducing_variable_fonts) are now a thing and will allow continuous variation on the range `[0, 1000]`.\n\nNote that there is no scale for `fontweight`, so values must be explicitly scaled to the expected range. And, you can expect a maximum of 9 levels of bold variations. However, with the growing support for [variable fonts](https://fonts.google.com/knowledge/introducing_type/introducing_variable_fonts), continuous variation across the full `[0, 1000]` range may be possible.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}